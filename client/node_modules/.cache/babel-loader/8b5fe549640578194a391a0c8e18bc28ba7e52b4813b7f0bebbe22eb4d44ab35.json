{"ast":null,"code":"import O, { createContext as J, useContext as V, useMemo as A, useReducer as se, useRef as j, useEffect as ue } from \"react\";\nimport { forwardRefWithAs as X, render as q, compact as de } from '../../utils/render.js';\nimport { useId as Q } from '../../hooks/use-id.js';\nimport { match as ce } from '../../utils/match.js';\nimport { useIsoMorphicEffect as fe } from '../../hooks/use-iso-morphic-effect.js';\nimport { Keys as D } from '../../components/keyboard.js';\nimport { focusIn as Y, Focus as I, FocusResult as Z, sortByDomNode as Te } from '../../utils/focus-management.js';\nimport { useFlags as me } from '../../hooks/use-flags.js';\nimport { Label as ye, useLabels as z } from '../../components/label/label.js';\nimport { Description as Re, useDescriptions as ee } from '../../components/description/description.js';\nimport { useTreeWalker as be } from '../../hooks/use-tree-walker.js';\nimport { useSyncRefs as te } from '../../hooks/use-sync-refs.js';\nimport { Hidden as ge, Features as Oe } from '../../internal/hidden.js';\nimport { attemptSubmit as Ee, objectToFormEntries as ve } from '../../utils/form.js';\nimport { getOwnerDocument as Pe } from '../../utils/owner.js';\nimport { useEvent as E } from '../../hooks/use-event.js';\nimport { useControllable as Ae } from '../../hooks/use-controllable.js';\nimport { isDisabledReactIssue7711 as re } from '../../utils/bugs.js';\nimport { useLatestValue as De } from '../../hooks/use-latest-value.js';\nimport { useDisposables as Ge } from '../../hooks/use-disposables.js';\nvar Ce = (t => (t[t.RegisterOption = 0] = \"RegisterOption\", t[t.UnregisterOption = 1] = \"UnregisterOption\", t))(Ce || {});\nlet ke = {\n    [0](r, o) {\n      let t = [...r.options, {\n        id: o.id,\n        element: o.element,\n        propsRef: o.propsRef\n      }];\n      return {\n        ...r,\n        options: Te(t, p => p.element.current)\n      };\n    },\n    [1](r, o) {\n      let t = r.options.slice(),\n        p = r.options.findIndex(T => T.id === o.id);\n      return p === -1 ? r : (t.splice(p, 1), {\n        ...r,\n        options: t\n      });\n    }\n  },\n  B = J(null);\nB.displayName = \"RadioGroupDataContext\";\nfunction oe(r) {\n  let o = V(B);\n  if (o === null) {\n    let t = new Error(`<${r} /> is missing a parent <RadioGroup /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(t, oe), t;\n  }\n  return o;\n}\nlet $ = J(null);\n$.displayName = \"RadioGroupActionsContext\";\nfunction ne(r) {\n  let o = V($);\n  if (o === null) {\n    let t = new Error(`<${r} /> is missing a parent <RadioGroup /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(t, ne), t;\n  }\n  return o;\n}\nfunction Le(r, o) {\n  return ce(o.type, ke, r, o);\n}\nlet he = \"div\";\nfunction Fe(r, o) {\n  let t = Q(),\n    {\n      id: p = `headlessui-radiogroup-${t}`,\n      value: T,\n      defaultValue: v,\n      form: S,\n      name: m,\n      onChange: M,\n      by: G = (e, i) => e === i,\n      disabled: C = !1,\n      ...H\n    } = r,\n    y = E(typeof G == \"string\" ? (e, i) => {\n      let n = G;\n      return (e == null ? void 0 : e[n]) === (i == null ? void 0 : i[n]);\n    } : G),\n    [P, h] = se(Le, {\n      options: []\n    }),\n    a = P.options,\n    [N, R] = z(),\n    [k, U] = ee(),\n    L = j(null),\n    W = te(L, o),\n    [l, s] = Ae(T, M, v),\n    b = A(() => a.find(e => !e.propsRef.current.disabled), [a]),\n    F = A(() => a.some(e => y(e.propsRef.current.value, l)), [a, l]),\n    d = E(e => {\n      var n;\n      if (C || y(e, l)) return !1;\n      let i = (n = a.find(f => y(f.propsRef.current.value, e))) == null ? void 0 : n.propsRef.current;\n      return i != null && i.disabled ? !1 : (s == null || s(e), !0);\n    });\n  be({\n    container: L.current,\n    accept(e) {\n      return e.getAttribute(\"role\") === \"radio\" ? NodeFilter.FILTER_REJECT : e.hasAttribute(\"role\") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;\n    },\n    walk(e) {\n      e.setAttribute(\"role\", \"none\");\n    }\n  });\n  let x = E(e => {\n      let i = L.current;\n      if (!i) return;\n      let n = Pe(i),\n        f = a.filter(u => u.propsRef.current.disabled === !1).map(u => u.element.current);\n      switch (e.key) {\n        case D.Enter:\n          Ee(e.currentTarget);\n          break;\n        case D.ArrowLeft:\n        case D.ArrowUp:\n          if (e.preventDefault(), e.stopPropagation(), Y(f, I.Previous | I.WrapAround) === Z.Success) {\n            let g = a.find(K => K.element.current === (n == null ? void 0 : n.activeElement));\n            g && d(g.propsRef.current.value);\n          }\n          break;\n        case D.ArrowRight:\n        case D.ArrowDown:\n          if (e.preventDefault(), e.stopPropagation(), Y(f, I.Next | I.WrapAround) === Z.Success) {\n            let g = a.find(K => K.element.current === (n == null ? void 0 : n.activeElement));\n            g && d(g.propsRef.current.value);\n          }\n          break;\n        case D.Space:\n          {\n            e.preventDefault(), e.stopPropagation();\n            let u = a.find(g => g.element.current === (n == null ? void 0 : n.activeElement));\n            u && d(u.propsRef.current.value);\n          }\n          break;\n      }\n    }),\n    c = E(e => (h({\n      type: 0,\n      ...e\n    }), () => h({\n      type: 1,\n      id: e.id\n    }))),\n    _ = A(() => ({\n      value: l,\n      firstOption: b,\n      containsCheckedOption: F,\n      disabled: C,\n      compare: y,\n      ...P\n    }), [l, b, F, C, y, P]),\n    ie = A(() => ({\n      registerOption: c,\n      change: d\n    }), [c, d]),\n    ae = {\n      ref: W,\n      id: p,\n      role: \"radiogroup\",\n      \"aria-labelledby\": N,\n      \"aria-describedby\": k,\n      onKeyDown: x\n    },\n    pe = A(() => ({\n      value: l\n    }), [l]),\n    w = j(null),\n    le = Ge();\n  return ue(() => {\n    w.current && v !== void 0 && le.addEventListener(w.current, \"reset\", () => {\n      d(v);\n    });\n  }, [w, d]), O.createElement(U, {\n    name: \"RadioGroup.Description\"\n  }, O.createElement(R, {\n    name: \"RadioGroup.Label\"\n  }, O.createElement($.Provider, {\n    value: ie\n  }, O.createElement(B.Provider, {\n    value: _\n  }, m != null && l != null && ve({\n    [m]: l\n  }).map(([e, i], n) => O.createElement(ge, {\n    features: Oe.Hidden,\n    ref: n === 0 ? f => {\n      var u;\n      w.current = (u = f == null ? void 0 : f.closest(\"form\")) != null ? u : null;\n    } : void 0,\n    ...de({\n      key: e,\n      as: \"input\",\n      type: \"radio\",\n      checked: i != null,\n      hidden: !0,\n      readOnly: !0,\n      form: S,\n      name: e,\n      value: i\n    })\n  })), q({\n    ourProps: ae,\n    theirProps: H,\n    slot: pe,\n    defaultTag: he,\n    name: \"RadioGroup\"\n  })))));\n}\nvar xe = (t => (t[t.Empty = 1] = \"Empty\", t[t.Active = 2] = \"Active\", t))(xe || {});\nlet _e = \"div\";\nfunction we(r, o) {\n  var x;\n  let t = Q(),\n    {\n      id: p = `headlessui-radiogroup-option-${t}`,\n      value: T,\n      disabled: v = !1,\n      ...S\n    } = r,\n    m = j(null),\n    M = te(m, o),\n    [G, C] = z(),\n    [H, y] = ee(),\n    {\n      addFlag: P,\n      removeFlag: h,\n      hasFlag: a\n    } = me(1),\n    N = De({\n      value: T,\n      disabled: v\n    }),\n    R = oe(\"RadioGroup.Option\"),\n    k = ne(\"RadioGroup.Option\");\n  fe(() => k.registerOption({\n    id: p,\n    element: m,\n    propsRef: N\n  }), [p, k, m, r]);\n  let U = E(c => {\n      var _;\n      if (re(c.currentTarget)) return c.preventDefault();\n      k.change(T) && (P(2), (_ = m.current) == null || _.focus());\n    }),\n    L = E(c => {\n      if (re(c.currentTarget)) return c.preventDefault();\n      P(2);\n    }),\n    W = E(() => h(2)),\n    l = ((x = R.firstOption) == null ? void 0 : x.id) === p,\n    s = R.disabled || v,\n    b = R.compare(R.value, T),\n    F = {\n      ref: M,\n      id: p,\n      role: \"radio\",\n      \"aria-checked\": b ? \"true\" : \"false\",\n      \"aria-labelledby\": G,\n      \"aria-describedby\": H,\n      \"aria-disabled\": s ? !0 : void 0,\n      tabIndex: (() => s ? -1 : b || !R.containsCheckedOption && l ? 0 : -1)(),\n      onClick: s ? void 0 : U,\n      onFocus: s ? void 0 : L,\n      onBlur: s ? void 0 : W\n    },\n    d = A(() => ({\n      checked: b,\n      disabled: s,\n      active: a(2)\n    }), [b, s, a]);\n  return O.createElement(y, {\n    name: \"RadioGroup.Description\"\n  }, O.createElement(C, {\n    name: \"RadioGroup.Label\"\n  }, q({\n    ourProps: F,\n    theirProps: S,\n    slot: d,\n    defaultTag: _e,\n    name: \"RadioGroup.Option\"\n  })));\n}\nlet Ie = X(Fe),\n  Se = X(we),\n  yt = Object.assign(Ie, {\n    Option: Se,\n    Label: ye,\n    Description: Re\n  });\nexport { yt as RadioGroup };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}