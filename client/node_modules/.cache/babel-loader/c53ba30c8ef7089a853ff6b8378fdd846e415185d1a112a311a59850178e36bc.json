{"ast":null,"code":"import { disconnect as h, getAccount as l, watchAccount as d, fetchBalance as u, getNetwork as w, watchNetwork as p, switchNetwork as m, fetchEnsName as C, fetchEnsAvatar as f, connect as a, InjectedConnector as g } from \"@wagmi/core\";\nimport { WalletConnectConnector as v } from \"@wagmi/core/connectors/walletConnect\";\nimport { jsonRpcProvider as I } from \"@wagmi/core/providers/jsonRpc\";\nconst A = \"wallet_addEthereumChain\";\nclass j {\n  constructor(t, e) {\n    this.wagmi = {}, this.chains = [], this.namespace = \"eip155\", this.disconnect = h, this.getAccount = l, this.watchAccount = d, this.fetchBalance = u, this.getNetwork = w, this.watchNetwork = p, this.switchNetwork = m, this.fetchEnsName = C, this.fetchEnsAvatar = f, this.wagmi = t, this.chains = e;\n  }\n  getWalletConnectConnector() {\n    const t = this.wagmi.connectors.find(e => e.id === \"walletConnect\");\n    if (!t) throw new Error(\"WalletConnectConnector is required\");\n    return t;\n  }\n  async connectWalletConnectProvider(t, e) {\n    return await t.getProvider(), new Promise(n => {\n      t.once(\"message\", o => {\n        o.type === \"display_uri\" && (e(o.data), n());\n      });\n    });\n  }\n  getConnectorById(t) {\n    const e = this.wagmi.connectors.find(n => n.id === t);\n    if (!e) throw new Error(`Connector for id ${t} was not found`);\n    return e;\n  }\n  getConnectors() {\n    return this.wagmi.connectors.filter(t => !t.id.includes(\"walletConnect\"));\n  }\n  async connectWalletConnect(t, e) {\n    const n = this.getWalletConnectConnector(),\n      o = {\n        connector: n\n      };\n    return e && (o.chainId = e), Promise.all([a(o), this.connectWalletConnectProvider(n, t)]);\n  }\n  async connectConnector(t, e) {\n    const n = {\n      connector: this.getConnectorById(t)\n    };\n    return e && (n.chainId = e), await a(n);\n  }\n  isInjectedProviderInstalled() {\n    return typeof window.ethereum < \"u\";\n  }\n  safeCheckInjectedProvider(t) {\n    var e;\n    try {\n      const n = String(t);\n      return Boolean((e = window.ethereum) == null ? void 0 : e[n]);\n    } catch (n) {\n      return console.error(n), !1;\n    }\n  }\n  async getConnectedChainIds() {\n    var t, e, n;\n    const o = (e = (t = (await this.getWalletConnectConnector().getProvider()).signer) == null ? void 0 : t.session) == null ? void 0 : e.namespaces,\n      s = (n = o?.[this.namespace]) == null ? void 0 : n.methods;\n    if (s != null && s.includes(A)) return \"ALL\";\n    if (o) {\n      const i = [];\n      return Object.keys(o).forEach(r => {\n        r.includes(this.namespace) && i.push(...o[r].accounts);\n      }), i?.map(r => r.split(\":\")[1]);\n    }\n    return \"ALL\";\n  }\n}\nconst P = \"eip155\",\n  y = \"https://rpc.walletconnect.com\";\nfunction W({\n  projectId: c\n}) {\n  return I({\n    rpc: t => {\n      var e;\n      return [1, 3, 4, 5, 10, 42, 56, 69, 97, 100, 137, 280, 324, 420, 42161, 42220, 43114, 80001, 421611, 421613, 1313161554, 1313161555].includes(t.id) ? {\n        http: `${y}/v1/?chainId=${P}:${t.id}&projectId=${c}`\n      } : {\n        http: t.rpcUrls.default.http[0],\n        webSocket: (e = t.rpcUrls.default.webSocket) == null ? void 0 : e[0]\n      };\n    }\n  });\n}\nfunction B({\n  chains: c,\n  projectId: t\n}) {\n  return [new v({\n    chains: c,\n    options: {\n      projectId: t,\n      showQrModal: !1\n    }\n  }), new g({\n    chains: c,\n    options: {\n      shimDisconnect: !0\n    }\n  })];\n}\nexport { j as EthereumClient, B as w3mConnectors, W as w3mProvider };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}