{"ast":null,"code":"import { RELAYER_DEFAULT_PROTOCOL as ge, RELAYER_EVENTS as Z, VERIFY_SERVER as me, EXPIRER_EVENTS as we, PAIRING_EVENTS as ye, Store as k, Core as Se } from \"@walletconnect/core\";\nimport { pino as Ee, getDefaultLoggerOptions as Re, generateChildLogger as Ie, getLoggerContext as _e } from \"@walletconnect/logger\";\nimport { IEngine as Ne, ISignClient as qe } from \"@walletconnect/types\";\nimport { TYPE_1 as fe, createDelayedPromise as x, engineEvent as u, getInternalError as l, calcExpiry as _, isValidObject as z, getRequiredNamespacesFromNamespaces as ve, getSdkError as N, handleDeeplinkRedirect as Pe, isSessionCompatible as Oe, isBrowser as Ve, hashMessage as Y, isExpired as P, MemoryStore as $, isValidParams as E, isUndefined as D, isValidRelays as Te, isValidRequiredNamespaces as xe, isValidNamespaces as j, isConformingNamespaces as ee, isValidString as C, isValidErrorReason as De, isValidRelay as Ce, isValidController as Ae, isValidNamespacesChainId as se, isValidRequest as be, isValidNamespacesRequest as Le, isValidRequestExpiry as $e, isValidResponse as Ge, isValidEvent as Me, isValidNamespacesEvent as Ue, parseExpirerTarget as Qe, isValidId as Ke, getAppMetadata as ke } from \"@walletconnect/utils\";\nimport ze, { EventEmitter as Ye } from \"events\";\nimport { THIRTY_DAYS as je, SEVEN_DAYS as te, FIVE_MINUTES as y, ONE_DAY as O, THIRTY_SECONDS as ie, ONE_SECOND as Je, toMiliseconds as re } from \"@walletconnect/time\";\nimport { payloadId as Xe, isJsonRpcResult as q, isJsonRpcError as f, formatJsonRpcRequest as J, formatJsonRpcResult as Fe, formatJsonRpcError as He, isJsonRpcRequest as We, isJsonRpcResponse as Be } from \"@walletconnect/jsonrpc-utils\";\nconst X = \"wc\",\n  F = 2,\n  H = \"client\",\n  G = `${X}@${F}:${H}:`,\n  M = {\n    name: H,\n    logger: \"error\",\n    controller: !1,\n    relayUrl: \"wss://relay.walletconnect.com\"\n  },\n  Ze = {\n    session_proposal: \"session_proposal\",\n    session_update: \"session_update\",\n    session_extend: \"session_extend\",\n    session_ping: \"session_ping\",\n    session_delete: \"session_delete\",\n    session_expire: \"session_expire\",\n    session_request: \"session_request\",\n    session_request_sent: \"session_request_sent\",\n    session_event: \"session_event\",\n    proposal_expire: \"proposal_expire\"\n  },\n  es = {\n    database: \":memory:\"\n  },\n  W = \"WALLETCONNECT_DEEPLINK_CHOICE\",\n  ss = {\n    created: \"history_created\",\n    updated: \"history_updated\",\n    deleted: \"history_deleted\",\n    sync: \"history_sync\"\n  },\n  ts = \"history\",\n  is = \"0.3\",\n  ne = \"proposal\",\n  rs = je,\n  oe = \"Proposal expired\",\n  ae = \"session\",\n  A = te,\n  ce = \"engine\",\n  V = {\n    wc_sessionPropose: {\n      req: {\n        ttl: y,\n        prompt: !0,\n        tag: 1100\n      },\n      res: {\n        ttl: y,\n        prompt: !1,\n        tag: 1101\n      }\n    },\n    wc_sessionSettle: {\n      req: {\n        ttl: y,\n        prompt: !1,\n        tag: 1102\n      },\n      res: {\n        ttl: y,\n        prompt: !1,\n        tag: 1103\n      }\n    },\n    wc_sessionUpdate: {\n      req: {\n        ttl: O,\n        prompt: !1,\n        tag: 1104\n      },\n      res: {\n        ttl: O,\n        prompt: !1,\n        tag: 1105\n      }\n    },\n    wc_sessionExtend: {\n      req: {\n        ttl: O,\n        prompt: !1,\n        tag: 1106\n      },\n      res: {\n        ttl: O,\n        prompt: !1,\n        tag: 1107\n      }\n    },\n    wc_sessionRequest: {\n      req: {\n        ttl: y,\n        prompt: !0,\n        tag: 1108\n      },\n      res: {\n        ttl: y,\n        prompt: !1,\n        tag: 1109\n      }\n    },\n    wc_sessionEvent: {\n      req: {\n        ttl: y,\n        prompt: !0,\n        tag: 1110\n      },\n      res: {\n        ttl: y,\n        prompt: !1,\n        tag: 1111\n      }\n    },\n    wc_sessionDelete: {\n      req: {\n        ttl: O,\n        prompt: !1,\n        tag: 1112\n      },\n      res: {\n        ttl: O,\n        prompt: !1,\n        tag: 1113\n      }\n    },\n    wc_sessionPing: {\n      req: {\n        ttl: ie,\n        prompt: !1,\n        tag: 1114\n      },\n      res: {\n        ttl: ie,\n        prompt: !1,\n        tag: 1115\n      }\n    }\n  },\n  U = {\n    min: y,\n    max: te\n  },\n  I = {\n    idle: \"IDLE\",\n    active: \"ACTIVE\"\n  },\n  le = \"request\",\n  pe = [\"wc_sessionPropose\", \"wc_sessionRequest\", \"wc_authRequest\"];\nvar ns = Object.defineProperty,\n  os = Object.defineProperties,\n  as = Object.getOwnPropertyDescriptors,\n  he = Object.getOwnPropertySymbols,\n  cs = Object.prototype.hasOwnProperty,\n  ls = Object.prototype.propertyIsEnumerable,\n  de = (m, r, e) => r in m ? ns(m, r, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : m[r] = e,\n  g = (m, r) => {\n    for (var e in r || (r = {})) cs.call(r, e) && de(m, e, r[e]);\n    if (he) for (var e of he(r)) ls.call(r, e) && de(m, e, r[e]);\n    return m;\n  },\n  b = (m, r) => os(m, as(r));\nclass ps extends Ne {\n  constructor(r) {\n    super(r), this.name = ce, this.events = new ze(), this.initialized = !1, this.ignoredPayloadTypes = [fe], this.requestQueue = {\n      state: I.idle,\n      queue: []\n    }, this.sessionRequestQueue = {\n      state: I.idle,\n      queue: []\n    }, this.requestQueueDelay = Je, this.init = async () => {\n      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({\n        methods: Object.keys(V)\n      }), this.initialized = !0, setTimeout(() => {\n        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();\n      }, re(this.requestQueueDelay)));\n    }, this.connect = async e => {\n      await this.isInitialized();\n      const s = b(g({}, e), {\n        requiredNamespaces: e.requiredNamespaces || {},\n        optionalNamespaces: e.optionalNamespaces || {}\n      });\n      await this.isValidConnect(s);\n      const {\n        pairingTopic: t,\n        requiredNamespaces: i,\n        optionalNamespaces: n,\n        sessionProperties: o,\n        relays: a\n      } = s;\n      let c = t,\n        p,\n        d = !1;\n      if (c && (d = this.client.core.pairing.pairings.get(c).active), !c || !d) {\n        const {\n          topic: v,\n          uri: S\n        } = await this.client.core.pairing.create();\n        c = v, p = S;\n      }\n      const h = await this.client.core.crypto.generateKeyPair(),\n        R = g({\n          requiredNamespaces: i,\n          optionalNamespaces: n,\n          relays: a ?? [{\n            protocol: ge\n          }],\n          proposer: {\n            publicKey: h,\n            metadata: this.client.metadata\n          }\n        }, o && {\n          sessionProperties: o\n        }),\n        {\n          reject: w,\n          resolve: T,\n          done: K\n        } = x(y, oe);\n      if (this.events.once(u(\"session_connect\"), async ({\n        error: v,\n        session: S\n      }) => {\n        if (v) w(v);else if (S) {\n          S.self.publicKey = h;\n          const B = b(g({}, S), {\n            requiredNamespaces: S.requiredNamespaces,\n            optionalNamespaces: S.optionalNamespaces\n          });\n          await this.client.session.set(S.topic, B), await this.setExpiry(S.topic, S.expiry), c && (await this.client.core.pairing.updateMetadata({\n            topic: c,\n            metadata: S.peer.metadata\n          })), T(B);\n        }\n      }), !c) {\n        const {\n          message: v\n        } = l(\"NO_MATCHING_KEY\", `connect() pairing topic: ${c}`);\n        throw new Error(v);\n      }\n      const L = await this.sendRequest({\n          topic: c,\n          method: \"wc_sessionPropose\",\n          params: R\n        }),\n        ue = _(y);\n      return await this.setProposal(L, g({\n        id: L,\n        expiry: ue\n      }, R)), {\n        uri: p,\n        approval: K\n      };\n    }, this.pair = async e => (await this.isInitialized(), await this.client.core.pairing.pair(e)), this.approve = async e => {\n      await this.isInitialized(), await this.isValidApprove(e);\n      const {\n          id: s,\n          relayProtocol: t,\n          namespaces: i,\n          sessionProperties: n\n        } = e,\n        o = this.client.proposal.get(s);\n      let {\n        pairingTopic: a,\n        proposer: c,\n        requiredNamespaces: p,\n        optionalNamespaces: d\n      } = o;\n      a = a || \"\", z(p) || (p = ve(i, \"approve()\"));\n      const h = await this.client.core.crypto.generateKeyPair(),\n        R = c.publicKey,\n        w = await this.client.core.crypto.generateSharedKey(h, R);\n      a && s && (await this.client.core.pairing.updateMetadata({\n        topic: a,\n        metadata: c.metadata\n      }), await this.sendResult({\n        id: s,\n        topic: a,\n        result: {\n          relay: {\n            protocol: t ?? \"irn\"\n          },\n          responderPublicKey: h\n        }\n      }), await this.client.proposal.delete(s, N(\"USER_DISCONNECTED\")), await this.client.core.pairing.activate({\n        topic: a\n      }));\n      const T = g({\n        relay: {\n          protocol: t ?? \"irn\"\n        },\n        namespaces: i,\n        requiredNamespaces: p,\n        optionalNamespaces: d,\n        pairingTopic: a,\n        controller: {\n          publicKey: h,\n          metadata: this.client.metadata\n        },\n        expiry: _(A)\n      }, n && {\n        sessionProperties: n\n      });\n      await this.client.core.relayer.subscribe(w), await this.sendRequest({\n        topic: w,\n        method: \"wc_sessionSettle\",\n        params: T,\n        throwOnFailedPublish: !0\n      });\n      const K = b(g({}, T), {\n        topic: w,\n        pairingTopic: a,\n        acknowledged: !1,\n        self: T.controller,\n        peer: {\n          publicKey: c.publicKey,\n          metadata: c.metadata\n        },\n        controller: h\n      });\n      return await this.client.session.set(w, K), await this.setExpiry(w, _(A)), {\n        topic: w,\n        acknowledged: () => new Promise(L => setTimeout(() => L(this.client.session.get(w)), 500))\n      };\n    }, this.reject = async e => {\n      await this.isInitialized(), await this.isValidReject(e);\n      const {\n          id: s,\n          reason: t\n        } = e,\n        {\n          pairingTopic: i\n        } = this.client.proposal.get(s);\n      i && (await this.sendError(s, i, t), await this.client.proposal.delete(s, N(\"USER_DISCONNECTED\")));\n    }, this.update = async e => {\n      await this.isInitialized(), await this.isValidUpdate(e);\n      const {\n          topic: s,\n          namespaces: t\n        } = e,\n        i = await this.sendRequest({\n          topic: s,\n          method: \"wc_sessionUpdate\",\n          params: {\n            namespaces: t\n          }\n        }),\n        {\n          done: n,\n          resolve: o,\n          reject: a\n        } = x();\n      return this.events.once(u(\"session_update\", i), ({\n        error: c\n      }) => {\n        c ? a(c) : o();\n      }), await this.client.session.update(s, {\n        namespaces: t\n      }), {\n        acknowledged: n\n      };\n    }, this.extend = async e => {\n      await this.isInitialized(), await this.isValidExtend(e);\n      const {\n          topic: s\n        } = e,\n        t = await this.sendRequest({\n          topic: s,\n          method: \"wc_sessionExtend\",\n          params: {}\n        }),\n        {\n          done: i,\n          resolve: n,\n          reject: o\n        } = x();\n      return this.events.once(u(\"session_extend\", t), ({\n        error: a\n      }) => {\n        a ? o(a) : n();\n      }), await this.setExpiry(s, _(A)), {\n        acknowledged: i\n      };\n    }, this.request = async e => {\n      await this.isInitialized(), await this.isValidRequest(e);\n      const {\n          chainId: s,\n          request: t,\n          topic: i,\n          expiry: n\n        } = e,\n        o = Xe(),\n        {\n          done: a,\n          resolve: c,\n          reject: p\n        } = x(n);\n      return this.events.once(u(\"session_request\", o), ({\n        error: d,\n        result: h\n      }) => {\n        d ? p(d) : c(h);\n      }), await Promise.all([new Promise(async d => {\n        await this.sendRequest({\n          clientRpcId: o,\n          topic: i,\n          method: \"wc_sessionRequest\",\n          params: {\n            request: t,\n            chainId: s\n          },\n          expiry: n,\n          throwOnFailedPublish: !0\n        }).catch(h => p(h)), this.client.events.emit(\"session_request_sent\", {\n          topic: i,\n          request: t,\n          chainId: s,\n          id: o\n        }), d();\n      }), new Promise(async d => {\n        const h = await this.client.core.storage.getItem(W);\n        Pe({\n          id: o,\n          topic: i,\n          wcDeepLink: h\n        }), d();\n      }), a()]).then(d => d[2]);\n    }, this.respond = async e => {\n      await this.isInitialized(), await this.isValidRespond(e);\n      const {\n          topic: s,\n          response: t\n        } = e,\n        {\n          id: i\n        } = t;\n      q(t) ? await this.sendResult({\n        id: i,\n        topic: s,\n        result: t.result,\n        throwOnFailedPublish: !0\n      }) : f(t) && (await this.sendError(i, s, t.error)), this.cleanupAfterResponse(e);\n    }, this.ping = async e => {\n      await this.isInitialized(), await this.isValidPing(e);\n      const {\n        topic: s\n      } = e;\n      if (this.client.session.keys.includes(s)) {\n        const t = await this.sendRequest({\n            topic: s,\n            method: \"wc_sessionPing\",\n            params: {}\n          }),\n          {\n            done: i,\n            resolve: n,\n            reject: o\n          } = x();\n        this.events.once(u(\"session_ping\", t), ({\n          error: a\n        }) => {\n          a ? o(a) : n();\n        }), await i();\n      } else this.client.core.pairing.pairings.keys.includes(s) && (await this.client.core.pairing.ping({\n        topic: s\n      }));\n    }, this.emit = async e => {\n      await this.isInitialized(), await this.isValidEmit(e);\n      const {\n        topic: s,\n        event: t,\n        chainId: i\n      } = e;\n      await this.sendRequest({\n        topic: s,\n        method: \"wc_sessionEvent\",\n        params: {\n          event: t,\n          chainId: i\n        }\n      });\n    }, this.disconnect = async e => {\n      await this.isInitialized(), await this.isValidDisconnect(e);\n      const {\n        topic: s\n      } = e;\n      this.client.session.keys.includes(s) ? (await this.sendRequest({\n        topic: s,\n        method: \"wc_sessionDelete\",\n        params: N(\"USER_DISCONNECTED\"),\n        throwOnFailedPublish: !0\n      }), await this.deleteSession(s)) : await this.client.core.pairing.disconnect({\n        topic: s\n      });\n    }, this.find = e => (this.isInitialized(), this.client.session.getAll().filter(s => Oe(s, e))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async e => {\n      if (e.pairingTopic) try {\n        const s = this.client.core.pairing.pairings.get(e.pairingTopic),\n          t = this.client.core.pairing.pairings.getAll().filter(i => {\n            var n, o;\n            return ((n = i.peerMetadata) == null ? void 0 : n.url) && ((o = i.peerMetadata) == null ? void 0 : o.url) === e.peer.metadata.url && i.topic && i.topic !== s.topic;\n          });\n        if (t.length === 0) return;\n        this.client.logger.info(`Cleaning up ${t.length} duplicate pairing(s)`), await Promise.all(t.map(i => this.client.core.pairing.disconnect({\n          topic: i.topic\n        }))), this.client.logger.info(\"Duplicate pairings clean up finished\");\n      } catch (s) {\n        this.client.logger.error(s);\n      }\n    }, this.deleteSession = async (e, s) => {\n      const {\n        self: t\n      } = this.client.session.get(e);\n      await this.client.core.relayer.unsubscribe(e), this.client.session.delete(e, N(\"USER_DISCONNECTED\")), this.client.core.crypto.keychain.has(t.publicKey) && (await this.client.core.crypto.deleteKeyPair(t.publicKey)), this.client.core.crypto.keychain.has(e) && (await this.client.core.crypto.deleteSymKey(e)), s || this.client.core.expirer.del(e), this.client.core.storage.removeItem(W).catch(i => this.client.logger.warn(i));\n    }, this.deleteProposal = async (e, s) => {\n      await Promise.all([this.client.proposal.delete(e, N(\"USER_DISCONNECTED\")), s ? Promise.resolve() : this.client.core.expirer.del(e)]);\n    }, this.deletePendingSessionRequest = async (e, s, t = !1) => {\n      await Promise.all([this.client.pendingRequest.delete(e, s), t ? Promise.resolve() : this.client.core.expirer.del(e)]), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter(i => i.id !== e), t && (this.sessionRequestQueue.state = I.idle);\n    }, this.setExpiry = async (e, s) => {\n      this.client.session.keys.includes(e) && (await this.client.session.update(e, {\n        expiry: s\n      })), this.client.core.expirer.set(e, s);\n    }, this.setProposal = async (e, s) => {\n      await this.client.proposal.set(e, s), this.client.core.expirer.set(e, s.expiry);\n    }, this.setPendingSessionRequest = async e => {\n      const s = V.wc_sessionRequest.req.ttl,\n        {\n          id: t,\n          topic: i,\n          params: n,\n          verifyContext: o\n        } = e;\n      await this.client.pendingRequest.set(t, {\n        id: t,\n        topic: i,\n        params: n,\n        verifyContext: o\n      }), s && this.client.core.expirer.set(t, _(s));\n    }, this.sendRequest = async e => {\n      const {\n          topic: s,\n          method: t,\n          params: i,\n          expiry: n,\n          relayRpcId: o,\n          clientRpcId: a,\n          throwOnFailedPublish: c\n        } = e,\n        p = J(t, i, a);\n      if (Ve() && pe.includes(t)) {\n        const R = Y(JSON.stringify(p));\n        this.client.core.verify.register({\n          attestationId: R\n        });\n      }\n      const d = await this.client.core.crypto.encode(s, p),\n        h = V[t].req;\n      return n && (h.ttl = n), o && (h.id = o), this.client.core.history.set(s, p), c ? (h.internal = b(g({}, h.internal), {\n        throwOnFailedPublish: !0\n      }), await this.client.core.relayer.publish(s, d, h)) : this.client.core.relayer.publish(s, d, h).catch(R => this.client.logger.error(R)), p.id;\n    }, this.sendResult = async e => {\n      const {\n          id: s,\n          topic: t,\n          result: i,\n          throwOnFailedPublish: n\n        } = e,\n        o = Fe(s, i),\n        a = await this.client.core.crypto.encode(t, o),\n        c = await this.client.core.history.get(t, s),\n        p = V[c.request.method].res;\n      n ? (p.internal = b(g({}, p.internal), {\n        throwOnFailedPublish: !0\n      }), await this.client.core.relayer.publish(t, a, p)) : this.client.core.relayer.publish(t, a, p).catch(d => this.client.logger.error(d)), await this.client.core.history.resolve(o);\n    }, this.sendError = async (e, s, t) => {\n      const i = He(e, t),\n        n = await this.client.core.crypto.encode(s, i),\n        o = await this.client.core.history.get(s, e),\n        a = V[o.request.method].res;\n      this.client.core.relayer.publish(s, n, a), await this.client.core.history.resolve(i);\n    }, this.cleanup = async () => {\n      const e = [],\n        s = [];\n      this.client.session.getAll().forEach(t => {\n        P(t.expiry) && e.push(t.topic);\n      }), this.client.proposal.getAll().forEach(t => {\n        P(t.expiry) && s.push(t.id);\n      }), await Promise.all([...e.map(t => this.deleteSession(t)), ...s.map(t => this.deleteProposal(t))]);\n    }, this.onRelayEventRequest = async e => {\n      this.requestQueue.queue.push(e), await this.processRequestsQueue();\n    }, this.processRequestsQueue = async () => {\n      if (this.requestQueue.state === I.active) {\n        this.client.logger.info(\"Request queue already active, skipping...\");\n        return;\n      }\n      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0;) {\n        this.requestQueue.state = I.active;\n        const e = this.requestQueue.queue.shift();\n        if (e) try {\n          this.processRequest(e), await new Promise(s => setTimeout(s, 300));\n        } catch (s) {\n          this.client.logger.warn(s);\n        }\n      }\n      this.requestQueue.state = I.idle;\n    }, this.processRequest = e => {\n      const {\n          topic: s,\n          payload: t\n        } = e,\n        i = t.method;\n      switch (i) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeRequest(s, t);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleRequest(s, t);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateRequest(s, t);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendRequest(s, t);\n        case \"wc_sessionPing\":\n          return this.onSessionPingRequest(s, t);\n        case \"wc_sessionDelete\":\n          return this.onSessionDeleteRequest(s, t);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequest(s, t);\n        case \"wc_sessionEvent\":\n          return this.onSessionEventRequest(s, t);\n        default:\n          return this.client.logger.info(`Unsupported request method ${i}`);\n      }\n    }, this.onRelayEventResponse = async e => {\n      const {\n          topic: s,\n          payload: t\n        } = e,\n        i = (await this.client.core.history.get(s, t.id)).request.method;\n      switch (i) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeResponse(s, t);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleResponse(s, t);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateResponse(s, t);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendResponse(s, t);\n        case \"wc_sessionPing\":\n          return this.onSessionPingResponse(s, t);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequestResponse(s, t);\n        default:\n          return this.client.logger.info(`Unsupported response method ${i}`);\n      }\n    }, this.onRelayEventUnknownPayload = e => {\n      const {\n          topic: s\n        } = e,\n        {\n          message: t\n        } = l(\"MISSING_OR_INVALID\", `Decoded payload on topic ${s} is not identifiable as a JSON-RPC request or a response.`);\n      throw new Error(t);\n    }, this.onSessionProposeRequest = async (e, s) => {\n      const {\n        params: t,\n        id: i\n      } = s;\n      try {\n        this.isValidConnect(g({}, s.params));\n        const n = _(y),\n          o = g({\n            id: i,\n            pairingTopic: e,\n            expiry: n\n          }, t);\n        await this.setProposal(i, o);\n        const a = Y(JSON.stringify(s)),\n          c = await this.getVerifyContext(a, o.proposer.metadata);\n        this.client.events.emit(\"session_proposal\", {\n          id: i,\n          params: o,\n          verifyContext: c\n        });\n      } catch (n) {\n        await this.sendError(i, e, n), this.client.logger.error(n);\n      }\n    }, this.onSessionProposeResponse = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      if (q(s)) {\n        const {\n          result: i\n        } = s;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          result: i\n        });\n        const n = this.client.proposal.get(t);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          proposal: n\n        });\n        const o = n.proposer.publicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          selfPublicKey: o\n        });\n        const a = i.responderPublicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          peerPublicKey: a\n        });\n        const c = await this.client.core.crypto.generateSharedKey(o, a);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          sessionTopic: c\n        });\n        const p = await this.client.core.relayer.subscribe(c);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          subscriptionId: p\n        }), await this.client.core.pairing.activate({\n          topic: e\n        });\n      } else f(s) && (await this.client.proposal.delete(t, N(\"USER_DISCONNECTED\")), this.events.emit(u(\"session_connect\"), {\n        error: s.error\n      }));\n    }, this.onSessionSettleRequest = async (e, s) => {\n      const {\n        id: t,\n        params: i\n      } = s;\n      try {\n        this.isValidSessionSettleRequest(i);\n        const {\n            relay: n,\n            controller: o,\n            expiry: a,\n            namespaces: c,\n            requiredNamespaces: p,\n            optionalNamespaces: d,\n            sessionProperties: h,\n            pairingTopic: R\n          } = s.params,\n          w = g({\n            topic: e,\n            relay: n,\n            expiry: a,\n            namespaces: c,\n            acknowledged: !0,\n            pairingTopic: R,\n            requiredNamespaces: p,\n            optionalNamespaces: d,\n            controller: o.publicKey,\n            self: {\n              publicKey: \"\",\n              metadata: this.client.metadata\n            },\n            peer: {\n              publicKey: o.publicKey,\n              metadata: o.metadata\n            }\n          }, h && {\n            sessionProperties: h\n          });\n        await this.sendResult({\n          id: s.id,\n          topic: e,\n          result: !0\n        }), this.events.emit(u(\"session_connect\"), {\n          session: w\n        }), this.cleanupDuplicatePairings(w);\n      } catch (n) {\n        await this.sendError(t, e, n), this.client.logger.error(n);\n      }\n    }, this.onSessionSettleResponse = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      q(s) ? (await this.client.session.update(e, {\n        acknowledged: !0\n      }), this.events.emit(u(\"session_approve\", t), {})) : f(s) && (await this.client.session.delete(e, N(\"USER_DISCONNECTED\")), this.events.emit(u(\"session_approve\", t), {\n        error: s.error\n      }));\n    }, this.onSessionUpdateRequest = async (e, s) => {\n      const {\n        params: t,\n        id: i\n      } = s;\n      try {\n        const n = `${e}_session_update`,\n          o = $.get(n);\n        if (o && this.isRequestOutOfSync(o, i)) {\n          this.client.logger.info(`Discarding out of sync request - ${i}`);\n          return;\n        }\n        this.isValidUpdate(g({\n          topic: e\n        }, t)), await this.client.session.update(e, {\n          namespaces: t.namespaces\n        }), await this.sendResult({\n          id: i,\n          topic: e,\n          result: !0\n        }), this.client.events.emit(\"session_update\", {\n          id: i,\n          topic: e,\n          params: t\n        }), $.set(n, i);\n      } catch (n) {\n        await this.sendError(i, e, n), this.client.logger.error(n);\n      }\n    }, this.isRequestOutOfSync = (e, s) => parseInt(s.toString().slice(0, -3)) <= parseInt(e.toString().slice(0, -3)), this.onSessionUpdateResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      q(s) ? this.events.emit(u(\"session_update\", t), {}) : f(s) && this.events.emit(u(\"session_update\", t), {\n        error: s.error\n      });\n    }, this.onSessionExtendRequest = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      try {\n        this.isValidExtend({\n          topic: e\n        }), await this.setExpiry(e, _(A)), await this.sendResult({\n          id: t,\n          topic: e,\n          result: !0\n        }), this.client.events.emit(\"session_extend\", {\n          id: t,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError(t, e, i), this.client.logger.error(i);\n      }\n    }, this.onSessionExtendResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      q(s) ? this.events.emit(u(\"session_extend\", t), {}) : f(s) && this.events.emit(u(\"session_extend\", t), {\n        error: s.error\n      });\n    }, this.onSessionPingRequest = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      try {\n        this.isValidPing({\n          topic: e\n        }), await this.sendResult({\n          id: t,\n          topic: e,\n          result: !0\n        }), this.client.events.emit(\"session_ping\", {\n          id: t,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError(t, e, i), this.client.logger.error(i);\n      }\n    }, this.onSessionPingResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      setTimeout(() => {\n        q(s) ? this.events.emit(u(\"session_ping\", t), {}) : f(s) && this.events.emit(u(\"session_ping\", t), {\n          error: s.error\n        });\n      }, 500);\n    }, this.onSessionDeleteRequest = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      try {\n        this.isValidDisconnect({\n          topic: e,\n          reason: s.params\n        }), await Promise.all([new Promise(i => {\n          this.client.core.relayer.once(Z.publish, async () => {\n            i(await this.deleteSession(e));\n          });\n        }), this.sendResult({\n          id: t,\n          topic: e,\n          result: !0\n        })]), this.client.events.emit(\"session_delete\", {\n          id: t,\n          topic: e\n        });\n      } catch (i) {\n        this.client.logger.error(i);\n      }\n    }, this.onSessionRequest = async (e, s) => {\n      const {\n        id: t,\n        params: i\n      } = s;\n      try {\n        this.isValidRequest(g({\n          topic: e\n        }, i));\n        const n = Y(JSON.stringify(J(\"wc_sessionRequest\", i, t))),\n          o = this.client.session.get(e),\n          a = await this.getVerifyContext(n, o.peer.metadata),\n          c = {\n            id: t,\n            topic: e,\n            params: i,\n            verifyContext: a\n          };\n        await this.setPendingSessionRequest(c), this.addSessionRequestToSessionRequestQueue(c), this.processSessionRequestQueue();\n      } catch (n) {\n        await this.sendError(t, e, n), this.client.logger.error(n);\n      }\n    }, this.onSessionRequestResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      q(s) ? this.events.emit(u(\"session_request\", t), {\n        result: s.result\n      }) : f(s) && this.events.emit(u(\"session_request\", t), {\n        error: s.error\n      });\n    }, this.onSessionEventRequest = async (e, s) => {\n      const {\n        id: t,\n        params: i\n      } = s;\n      try {\n        const n = `${e}_session_event_${i.event.name}`,\n          o = $.get(n);\n        if (o && this.isRequestOutOfSync(o, t)) {\n          this.client.logger.info(`Discarding out of sync request - ${t}`);\n          return;\n        }\n        this.isValidEmit(g({\n          topic: e\n        }, i)), this.client.events.emit(\"session_event\", {\n          id: t,\n          topic: e,\n          params: i\n        }), $.set(n, t);\n      } catch (n) {\n        await this.sendError(t, e, n), this.client.logger.error(n);\n      }\n    }, this.addSessionRequestToSessionRequestQueue = e => {\n      this.sessionRequestQueue.queue.push(e);\n    }, this.cleanupAfterResponse = e => {\n      this.deletePendingSessionRequest(e.response.id, {\n        message: \"fulfilled\",\n        code: 0\n      }), setTimeout(() => {\n        this.sessionRequestQueue.state = I.idle, this.processSessionRequestQueue();\n      }, re(this.requestQueueDelay));\n    }, this.processSessionRequestQueue = () => {\n      if (this.sessionRequestQueue.state === I.active) {\n        this.client.logger.info(\"session request queue is already active.\");\n        return;\n      }\n      const e = this.sessionRequestQueue.queue[0];\n      if (!e) {\n        this.client.logger.info(\"session request queue is empty.\");\n        return;\n      }\n      try {\n        this.sessionRequestQueue.state = I.active, this.client.events.emit(\"session_request\", e);\n      } catch (s) {\n        this.client.logger.error(s);\n      }\n    }, this.onPairingCreated = e => {\n      if (e.active) return;\n      const s = this.client.proposal.getAll().find(t => t.pairingTopic === e.topic);\n      s && this.onSessionProposeRequest(e.topic, J(\"wc_sessionPropose\", {\n        requiredNamespaces: s.requiredNamespaces,\n        optionalNamespaces: s.optionalNamespaces,\n        relays: s.relays,\n        proposer: s.proposer\n      }, s.id));\n    }, this.isValidConnect = async e => {\n      if (!E(e)) {\n        const {\n          message: a\n        } = l(\"MISSING_OR_INVALID\", `connect() params: ${JSON.stringify(e)}`);\n        throw new Error(a);\n      }\n      const {\n        pairingTopic: s,\n        requiredNamespaces: t,\n        optionalNamespaces: i,\n        sessionProperties: n,\n        relays: o\n      } = e;\n      if (D(s) || (await this.isValidPairingTopic(s)), !Te(o, !0)) {\n        const {\n          message: a\n        } = l(\"MISSING_OR_INVALID\", `connect() relays: ${o}`);\n        throw new Error(a);\n      }\n      !D(t) && z(t) !== 0 && this.validateNamespaces(t, \"requiredNamespaces\"), !D(i) && z(i) !== 0 && this.validateNamespaces(i, \"optionalNamespaces\"), D(n) || this.validateSessionProps(n, \"sessionProperties\");\n    }, this.validateNamespaces = (e, s) => {\n      const t = xe(e, \"connect()\", s);\n      if (t) throw new Error(t.message);\n    }, this.isValidApprove = async e => {\n      if (!E(e)) throw new Error(l(\"MISSING_OR_INVALID\", `approve() params: ${e}`).message);\n      const {\n        id: s,\n        namespaces: t,\n        relayProtocol: i,\n        sessionProperties: n\n      } = e;\n      await this.isValidProposalId(s);\n      const o = this.client.proposal.get(s),\n        a = j(t, \"approve()\");\n      if (a) throw new Error(a.message);\n      const c = ee(o.requiredNamespaces, t, \"approve()\");\n      if (c) throw new Error(c.message);\n      if (!C(i, !0)) {\n        const {\n          message: p\n        } = l(\"MISSING_OR_INVALID\", `approve() relayProtocol: ${i}`);\n        throw new Error(p);\n      }\n      D(n) || this.validateSessionProps(n, \"sessionProperties\");\n    }, this.isValidReject = async e => {\n      if (!E(e)) {\n        const {\n          message: i\n        } = l(\"MISSING_OR_INVALID\", `reject() params: ${e}`);\n        throw new Error(i);\n      }\n      const {\n        id: s,\n        reason: t\n      } = e;\n      if (await this.isValidProposalId(s), !De(t)) {\n        const {\n          message: i\n        } = l(\"MISSING_OR_INVALID\", `reject() reason: ${JSON.stringify(t)}`);\n        throw new Error(i);\n      }\n    }, this.isValidSessionSettleRequest = e => {\n      if (!E(e)) {\n        const {\n          message: c\n        } = l(\"MISSING_OR_INVALID\", `onSessionSettleRequest() params: ${e}`);\n        throw new Error(c);\n      }\n      const {\n        relay: s,\n        controller: t,\n        namespaces: i,\n        expiry: n\n      } = e;\n      if (!Ce(s)) {\n        const {\n          message: c\n        } = l(\"MISSING_OR_INVALID\", \"onSessionSettleRequest() relay protocol should be a string\");\n        throw new Error(c);\n      }\n      const o = Ae(t, \"onSessionSettleRequest()\");\n      if (o) throw new Error(o.message);\n      const a = j(i, \"onSessionSettleRequest()\");\n      if (a) throw new Error(a.message);\n      if (P(n)) {\n        const {\n          message: c\n        } = l(\"EXPIRED\", \"onSessionSettleRequest()\");\n        throw new Error(c);\n      }\n    }, this.isValidUpdate = async e => {\n      if (!E(e)) {\n        const {\n          message: a\n        } = l(\"MISSING_OR_INVALID\", `update() params: ${e}`);\n        throw new Error(a);\n      }\n      const {\n        topic: s,\n        namespaces: t\n      } = e;\n      await this.isValidSessionTopic(s);\n      const i = this.client.session.get(s),\n        n = j(t, \"update()\");\n      if (n) throw new Error(n.message);\n      const o = ee(i.requiredNamespaces, t, \"update()\");\n      if (o) throw new Error(o.message);\n    }, this.isValidExtend = async e => {\n      if (!E(e)) {\n        const {\n          message: t\n        } = l(\"MISSING_OR_INVALID\", `extend() params: ${e}`);\n        throw new Error(t);\n      }\n      const {\n        topic: s\n      } = e;\n      await this.isValidSessionTopic(s);\n    }, this.isValidRequest = async e => {\n      if (!E(e)) {\n        const {\n          message: a\n        } = l(\"MISSING_OR_INVALID\", `request() params: ${e}`);\n        throw new Error(a);\n      }\n      const {\n        topic: s,\n        request: t,\n        chainId: i,\n        expiry: n\n      } = e;\n      await this.isValidSessionTopic(s);\n      const {\n        namespaces: o\n      } = this.client.session.get(s);\n      if (!se(o, i)) {\n        const {\n          message: a\n        } = l(\"MISSING_OR_INVALID\", `request() chainId: ${i}`);\n        throw new Error(a);\n      }\n      if (!be(t)) {\n        const {\n          message: a\n        } = l(\"MISSING_OR_INVALID\", `request() ${JSON.stringify(t)}`);\n        throw new Error(a);\n      }\n      if (!Le(o, i, t.method)) {\n        const {\n          message: a\n        } = l(\"MISSING_OR_INVALID\", `request() method: ${t.method}`);\n        throw new Error(a);\n      }\n      if (n && !$e(n, U)) {\n        const {\n          message: a\n        } = l(\"MISSING_OR_INVALID\", `request() expiry: ${n}. Expiry must be a number (in seconds) between ${U.min} and ${U.max}`);\n        throw new Error(a);\n      }\n    }, this.isValidRespond = async e => {\n      if (!E(e)) {\n        const {\n          message: i\n        } = l(\"MISSING_OR_INVALID\", `respond() params: ${e}`);\n        throw new Error(i);\n      }\n      const {\n        topic: s,\n        response: t\n      } = e;\n      if (await this.isValidSessionTopic(s), !Ge(t)) {\n        const {\n          message: i\n        } = l(\"MISSING_OR_INVALID\", `respond() response: ${JSON.stringify(t)}`);\n        throw new Error(i);\n      }\n    }, this.isValidPing = async e => {\n      if (!E(e)) {\n        const {\n          message: t\n        } = l(\"MISSING_OR_INVALID\", `ping() params: ${e}`);\n        throw new Error(t);\n      }\n      const {\n        topic: s\n      } = e;\n      await this.isValidSessionOrPairingTopic(s);\n    }, this.isValidEmit = async e => {\n      if (!E(e)) {\n        const {\n          message: o\n        } = l(\"MISSING_OR_INVALID\", `emit() params: ${e}`);\n        throw new Error(o);\n      }\n      const {\n        topic: s,\n        event: t,\n        chainId: i\n      } = e;\n      await this.isValidSessionTopic(s);\n      const {\n        namespaces: n\n      } = this.client.session.get(s);\n      if (!se(n, i)) {\n        const {\n          message: o\n        } = l(\"MISSING_OR_INVALID\", `emit() chainId: ${i}`);\n        throw new Error(o);\n      }\n      if (!Me(t)) {\n        const {\n          message: o\n        } = l(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(t)}`);\n        throw new Error(o);\n      }\n      if (!Ue(n, i, t.name)) {\n        const {\n          message: o\n        } = l(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(t)}`);\n        throw new Error(o);\n      }\n    }, this.isValidDisconnect = async e => {\n      if (!E(e)) {\n        const {\n          message: t\n        } = l(\"MISSING_OR_INVALID\", `disconnect() params: ${e}`);\n        throw new Error(t);\n      }\n      const {\n        topic: s\n      } = e;\n      await this.isValidSessionOrPairingTopic(s);\n    }, this.getVerifyContext = async (e, s) => {\n      const t = {\n        verified: {\n          verifyUrl: s.verifyUrl || me,\n          validation: \"UNKNOWN\",\n          origin: s.url || \"\"\n        }\n      };\n      try {\n        const i = await this.client.core.verify.resolve({\n          attestationId: e,\n          verifyUrl: s.verifyUrl\n        });\n        i && (t.verified.origin = i.origin, t.verified.isScam = i.isScam, t.verified.validation = i.origin === new URL(s.url).origin ? \"VALID\" : \"INVALID\");\n      } catch (i) {\n        this.client.logger.info(i);\n      }\n      return this.client.logger.info(`Verify context: ${JSON.stringify(t)}`), t;\n    }, this.validateSessionProps = (e, s) => {\n      Object.values(e).forEach(t => {\n        if (!C(t, !1)) {\n          const {\n            message: i\n          } = l(\"MISSING_OR_INVALID\", `${s} must be in Record<string, string> format. Received: ${JSON.stringify(t)}`);\n          throw new Error(i);\n        }\n      });\n    };\n  }\n  async isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: r\n      } = l(\"NOT_INITIALIZED\", this.name);\n      throw new Error(r);\n    }\n    await this.client.core.relayer.confirmOnlineStateOrThrow();\n  }\n  registerRelayerEvents() {\n    this.client.core.relayer.on(Z.message, async r => {\n      const {\n        topic: e,\n        message: s\n      } = r;\n      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s))) return;\n      const t = await this.client.core.crypto.decode(e, s);\n      try {\n        We(t) ? (this.client.core.history.set(e, t), this.onRelayEventRequest({\n          topic: e,\n          payload: t\n        })) : Be(t) ? (await this.client.core.history.resolve(t), await this.onRelayEventResponse({\n          topic: e,\n          payload: t\n        }), this.client.core.history.delete(e, t.id)) : this.onRelayEventUnknownPayload({\n          topic: e,\n          payload: t\n        });\n      } catch (i) {\n        this.client.logger.error(i);\n      }\n    });\n  }\n  registerExpirerEvents() {\n    this.client.core.expirer.on(we.expired, async r => {\n      const {\n        topic: e,\n        id: s\n      } = Qe(r.target);\n      if (s && this.client.pendingRequest.keys.includes(s)) return await this.deletePendingSessionRequest(s, l(\"EXPIRED\"), !0);\n      e ? this.client.session.keys.includes(e) && (await this.deleteSession(e, !0), this.client.events.emit(\"session_expire\", {\n        topic: e\n      })) : s && (await this.deleteProposal(s, !0), this.client.events.emit(\"proposal_expire\", {\n        id: s\n      }));\n    });\n  }\n  registerPairingEvents() {\n    this.client.core.pairing.events.on(ye.create, r => this.onPairingCreated(r));\n  }\n  isValidPairingTopic(r) {\n    if (!C(r, !1)) {\n      const {\n        message: e\n      } = l(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${r}`);\n      throw new Error(e);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(r)) {\n      const {\n        message: e\n      } = l(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${r}`);\n      throw new Error(e);\n    }\n    if (P(this.client.core.pairing.pairings.get(r).expiry)) {\n      const {\n        message: e\n      } = l(\"EXPIRED\", `pairing topic: ${r}`);\n      throw new Error(e);\n    }\n  }\n  async isValidSessionTopic(r) {\n    if (!C(r, !1)) {\n      const {\n        message: e\n      } = l(\"MISSING_OR_INVALID\", `session topic should be a string: ${r}`);\n      throw new Error(e);\n    }\n    if (!this.client.session.keys.includes(r)) {\n      const {\n        message: e\n      } = l(\"NO_MATCHING_KEY\", `session topic doesn't exist: ${r}`);\n      throw new Error(e);\n    }\n    if (P(this.client.session.get(r).expiry)) {\n      await this.deleteSession(r);\n      const {\n        message: e\n      } = l(\"EXPIRED\", `session topic: ${r}`);\n      throw new Error(e);\n    }\n  }\n  async isValidSessionOrPairingTopic(r) {\n    if (this.client.session.keys.includes(r)) await this.isValidSessionTopic(r);else if (this.client.core.pairing.pairings.keys.includes(r)) this.isValidPairingTopic(r);else if (C(r, !1)) {\n      const {\n        message: e\n      } = l(\"NO_MATCHING_KEY\", `session or pairing topic doesn't exist: ${r}`);\n      throw new Error(e);\n    } else {\n      const {\n        message: e\n      } = l(\"MISSING_OR_INVALID\", `session or pairing topic should be a string: ${r}`);\n      throw new Error(e);\n    }\n  }\n  async isValidProposalId(r) {\n    if (!Ke(r)) {\n      const {\n        message: e\n      } = l(\"MISSING_OR_INVALID\", `proposal id should be a number: ${r}`);\n      throw new Error(e);\n    }\n    if (!this.client.proposal.keys.includes(r)) {\n      const {\n        message: e\n      } = l(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${r}`);\n      throw new Error(e);\n    }\n    if (P(this.client.proposal.get(r).expiry)) {\n      await this.deleteProposal(r);\n      const {\n        message: e\n      } = l(\"EXPIRED\", `proposal id: ${r}`);\n      throw new Error(e);\n    }\n  }\n}\nclass hs extends k {\n  constructor(r, e) {\n    super(r, e, ne, G), this.core = r, this.logger = e;\n  }\n}\nclass ds extends k {\n  constructor(r, e) {\n    super(r, e, ae, G), this.core = r, this.logger = e;\n  }\n}\nclass us extends k {\n  constructor(r, e) {\n    super(r, e, le, G, s => s.id), this.core = r, this.logger = e;\n  }\n}\nclass Q extends qe {\n  constructor(r) {\n    super(r), this.protocol = X, this.version = F, this.name = M.name, this.events = new Ye(), this.on = (s, t) => this.events.on(s, t), this.once = (s, t) => this.events.once(s, t), this.off = (s, t) => this.events.off(s, t), this.removeListener = (s, t) => this.events.removeListener(s, t), this.removeAllListeners = s => this.events.removeAllListeners(s), this.connect = async s => {\n      try {\n        return await this.engine.connect(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.pair = async s => {\n      try {\n        return await this.engine.pair(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.approve = async s => {\n      try {\n        return await this.engine.approve(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.reject = async s => {\n      try {\n        return await this.engine.reject(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.update = async s => {\n      try {\n        return await this.engine.update(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.extend = async s => {\n      try {\n        return await this.engine.extend(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.request = async s => {\n      try {\n        return await this.engine.request(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.respond = async s => {\n      try {\n        return await this.engine.respond(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.ping = async s => {\n      try {\n        return await this.engine.ping(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.emit = async s => {\n      try {\n        return await this.engine.emit(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.disconnect = async s => {\n      try {\n        return await this.engine.disconnect(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.find = s => {\n      try {\n        return this.engine.find(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.getPendingSessionRequests = () => {\n      try {\n        return this.engine.getPendingSessionRequests();\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.name = r?.name || M.name, this.metadata = r?.metadata || ke();\n    const e = typeof r?.logger < \"u\" && typeof r?.logger != \"string\" ? r.logger : Ee(Re({\n      level: r?.logger || M.logger\n    }));\n    this.core = r?.core || new Se(r), this.logger = Ie(e, this.name), this.session = new ds(this.core, this.logger), this.proposal = new hs(this.core, this.logger), this.pendingRequest = new us(this.core, this.logger), this.engine = new ps(this);\n  }\n  static async init(r) {\n    const e = new Q(r);\n    return await e.initialize(), e;\n  }\n  get context() {\n    return _e(this.logger);\n  }\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({\n        verifyUrl: this.metadata.verifyUrl\n      }), this.logger.info(\"SignClient Initialization Success\");\n    } catch (r) {\n      throw this.logger.info(\"SignClient Initialization Failure\"), this.logger.error(r.message), r;\n    }\n  }\n}\nconst gs = Q;\nexport { ce as ENGINE_CONTEXT, I as ENGINE_QUEUE_STATES, V as ENGINE_RPC_OPTS, ts as HISTORY_CONTEXT, ss as HISTORY_EVENTS, is as HISTORY_STORAGE_VERSION, pe as METHODS_TO_VERIFY, ne as PROPOSAL_CONTEXT, rs as PROPOSAL_EXPIRY, oe as PROPOSAL_EXPIRY_MESSAGE, le as REQUEST_CONTEXT, ae as SESSION_CONTEXT, A as SESSION_EXPIRY, U as SESSION_REQUEST_EXPIRY_BOUNDARIES, H as SIGN_CLIENT_CONTEXT, M as SIGN_CLIENT_DEFAULT, Ze as SIGN_CLIENT_EVENTS, X as SIGN_CLIENT_PROTOCOL, es as SIGN_CLIENT_STORAGE_OPTIONS, G as SIGN_CLIENT_STORAGE_PREFIX, F as SIGN_CLIENT_VERSION, gs as SignClient, W as WALLETCONNECT_DEEPLINK_CHOICE, Q as default };\n//# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}