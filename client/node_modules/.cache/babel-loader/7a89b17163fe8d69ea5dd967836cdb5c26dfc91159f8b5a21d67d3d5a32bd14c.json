{"ast":null,"code":"import i, { Fragment as x, createContext as A, useContext as H, useMemo as E, useRef as F, useState as M, useEffect as _ } from \"react\";\nimport { forwardRefWithAs as U, render as P, compact as K } from '../../utils/render.js';\nimport { useId as B } from '../../hooks/use-id.js';\nimport { Keys as g } from '../keyboard.js';\nimport { isDisabledReactIssue7711 as I } from '../../utils/bugs.js';\nimport { Label as O, useLabels as W } from '../label/label.js';\nimport { Description as N, useDescriptions as J } from '../description/description.js';\nimport { useResolveButtonType as X } from '../../hooks/use-resolve-button-type.js';\nimport { useSyncRefs as j } from '../../hooks/use-sync-refs.js';\nimport { Hidden as $, Features as q } from '../../internal/hidden.js';\nimport { attemptSubmit as z } from '../../utils/form.js';\nimport { useEvent as m } from '../../hooks/use-event.js';\nimport { useControllable as Q } from '../../hooks/use-controllable.js';\nimport { useDisposables as V } from '../../hooks/use-disposables.js';\nlet y = A(null);\ny.displayName = \"GroupContext\";\nlet Y = x;\nfunction Z(s) {\n  var d;\n  let [n, p] = M(null),\n    [c, f] = W(),\n    [r, h] = J(),\n    l = E(() => ({\n      switch: n,\n      setSwitch: p,\n      labelledby: c,\n      describedby: r\n    }), [n, p, c, r]),\n    T = {},\n    b = s;\n  return i.createElement(h, {\n    name: \"Switch.Description\"\n  }, i.createElement(f, {\n    name: \"Switch.Label\",\n    props: {\n      htmlFor: (d = l.switch) == null ? void 0 : d.id,\n      onClick(t) {\n        n && (t.currentTarget.tagName === \"LABEL\" && t.preventDefault(), n.click(), n.focus({\n          preventScroll: !0\n        }));\n      }\n    }\n  }, i.createElement(y.Provider, {\n    value: l\n  }, P({\n    ourProps: T,\n    theirProps: b,\n    defaultTag: Y,\n    name: \"Switch.Group\"\n  }))));\n}\nlet ee = \"button\";\nfunction te(s, n) {\n  let p = B(),\n    {\n      id: c = `headlessui-switch-${p}`,\n      checked: f,\n      defaultChecked: r = !1,\n      onChange: h,\n      name: l,\n      value: T,\n      form: b,\n      ...d\n    } = s,\n    t = H(y),\n    u = F(null),\n    D = j(u, n, t === null ? null : t.setSwitch),\n    [o, a] = Q(f, h, r),\n    S = m(() => a == null ? void 0 : a(!o)),\n    C = m(e => {\n      if (I(e.currentTarget)) return e.preventDefault();\n      e.preventDefault(), S();\n    }),\n    L = m(e => {\n      e.key === g.Space ? (e.preventDefault(), S()) : e.key === g.Enter && z(e.currentTarget);\n    }),\n    v = m(e => e.preventDefault()),\n    G = E(() => ({\n      checked: o\n    }), [o]),\n    R = {\n      id: c,\n      ref: D,\n      role: \"switch\",\n      type: X(s, u),\n      tabIndex: 0,\n      \"aria-checked\": o,\n      \"aria-labelledby\": t == null ? void 0 : t.labelledby,\n      \"aria-describedby\": t == null ? void 0 : t.describedby,\n      onClick: C,\n      onKeyUp: L,\n      onKeyPress: v\n    },\n    k = V();\n  return _(() => {\n    var w;\n    let e = (w = u.current) == null ? void 0 : w.closest(\"form\");\n    e && r !== void 0 && k.addEventListener(e, \"reset\", () => {\n      a(r);\n    });\n  }, [u, a]), i.createElement(i.Fragment, null, l != null && o && i.createElement($, {\n    features: q.Hidden,\n    ...K({\n      as: \"input\",\n      type: \"checkbox\",\n      hidden: !0,\n      readOnly: !0,\n      form: b,\n      checked: o,\n      name: l,\n      value: T\n    })\n  }), P({\n    ourProps: R,\n    theirProps: d,\n    slot: G,\n    defaultTag: ee,\n    name: \"Switch\"\n  }));\n}\nlet ne = U(te),\n  re = Z,\n  Ge = Object.assign(ne, {\n    Group: re,\n    Label: O,\n    Description: N\n  });\nexport { Ge as Switch };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}