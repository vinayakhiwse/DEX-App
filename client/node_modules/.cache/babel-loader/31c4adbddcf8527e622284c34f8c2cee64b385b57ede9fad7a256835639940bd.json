{"ast":null,"code":"import { proxy as g, subscribe as h, snapshot as H } from \"valtio/vanilla\";\nconst o = g({\n    history: [\"ConnectWallet\"],\n    view: \"ConnectWallet\",\n    data: void 0\n  }),\n  W = {\n    state: o,\n    subscribe(e) {\n      return h(o, () => e(o));\n    },\n    push(e, t) {\n      e !== o.view && (o.view = e, t && (o.data = t), o.history.push(e));\n    },\n    reset(e) {\n      o.view = e, o.history = [e];\n    },\n    replace(e) {\n      o.history.length > 1 && (o.history[o.history.length - 1] = e, o.view = e);\n    },\n    goBack() {\n      if (o.history.length > 1) {\n        o.history.pop();\n        const [e] = o.history.slice(-1);\n        o.view = e;\n      }\n    },\n    setData(e) {\n      o.data = e;\n    }\n  },\n  i = {\n    WALLETCONNECT_DEEPLINK_CHOICE: \"WALLETCONNECT_DEEPLINK_CHOICE\",\n    W3M_VERSION: \"W3M_VERSION\",\n    W3M_PREFER_INJECTED_URL_FLAG: \"w3mPreferInjected\",\n    RECOMMENDED_WALLET_AMOUNT: 9,\n    isMobile() {\n      return typeof window < \"u\" ? Boolean(window.matchMedia(\"(pointer:coarse)\").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)) : !1;\n    },\n    isAndroid() {\n      return i.isMobile() && navigator.userAgent.toLowerCase().includes(\"android\");\n    },\n    isIos() {\n      const e = navigator.userAgent.toLowerCase();\n      return i.isMobile() && (e.includes(\"iphone\") || e.includes(\"ipad\"));\n    },\n    isHttpUrl(e) {\n      return e.startsWith(\"http://\") || e.startsWith(\"https://\");\n    },\n    isArray(e) {\n      return Array.isArray(e) && e.length > 0;\n    },\n    formatNativeUrl(e, t, n) {\n      if (i.isHttpUrl(e)) return this.formatUniversalUrl(e, t, n);\n      let s = e;\n      s.includes(\"://\") || (s = e.replaceAll(\"/\", \"\").replaceAll(\":\", \"\"), s = `${s}://`), s.endsWith(\"/\") || (s = `${s}/`), this.setWalletConnectDeepLink(s, n);\n      const a = encodeURIComponent(t);\n      return `${s}wc?uri=${a}`;\n    },\n    formatUniversalUrl(e, t, n) {\n      if (!i.isHttpUrl(e)) return this.formatNativeUrl(e, t, n);\n      let s = e;\n      s.endsWith(\"/\") || (s = `${s}/`), this.setWalletConnectDeepLink(s, n);\n      const a = encodeURIComponent(t);\n      return `${s}wc?uri=${a}`;\n    },\n    async wait(e) {\n      return new Promise(t => {\n        setTimeout(t, e);\n      });\n    },\n    openHref(e, t) {\n      window.open(e, t, \"noreferrer noopener\");\n    },\n    setWalletConnectDeepLink(e, t) {\n      try {\n        localStorage.setItem(i.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({\n          href: e,\n          name: t\n        }));\n      } catch {\n        console.info(\"Unable to set WalletConnect deep link\");\n      }\n    },\n    setWalletConnectAndroidDeepLink(e) {\n      try {\n        const [t] = e.split(\"?\");\n        localStorage.setItem(i.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({\n          href: t,\n          name: \"Android\"\n        }));\n      } catch {\n        console.info(\"Unable to set WalletConnect android deep link\");\n      }\n    },\n    removeWalletConnectDeepLink() {\n      try {\n        localStorage.removeItem(i.WALLETCONNECT_DEEPLINK_CHOICE);\n      } catch {\n        console.info(\"Unable to remove WalletConnect deep link\");\n      }\n    },\n    setWeb3ModalVersionInStorage() {\n      try {\n        typeof localStorage < \"u\" && localStorage.setItem(i.W3M_VERSION, \"2.7.1\");\n      } catch {\n        console.info(\"Unable to set Web3Modal version in storage\");\n      }\n    },\n    getWalletRouterData() {\n      var e;\n      const t = (e = W.state.data) == null ? void 0 : e.Wallet;\n      if (!t) throw new Error('Missing \"Wallet\" view data');\n      return t;\n    },\n    getSwitchNetworkRouterData() {\n      var e;\n      const t = (e = W.state.data) == null ? void 0 : e.SwitchNetwork;\n      if (!t) throw new Error('Missing \"SwitchNetwork\" view data');\n      return t;\n    },\n    isPreferInjectedFlag() {\n      return typeof location < \"u\" ? new URLSearchParams(location.search).has(i.W3M_PREFER_INJECTED_URL_FLAG) : !1;\n    }\n  };\nlet k;\nconst f = {\n    ethereumClient: void 0,\n    setEthereumClient(e) {\n      k = e;\n    },\n    client() {\n      if (k) return k;\n      throw new Error(\"ClientCtrl has no client set\");\n    }\n  },\n  K = typeof location < \"u\" && (location.hostname.includes(\"localhost\") || location.protocol.includes(\"https\")),\n  l = g({\n    enabled: K,\n    userSessionId: \"\",\n    events: [],\n    connectedWalletId: void 0\n  }),\n  F = {\n    state: l,\n    subscribe(e) {\n      return h(l.events, () => e(H(l.events[l.events.length - 1])));\n    },\n    initialize() {\n      l.enabled && typeof (crypto == null ? void 0 : crypto.randomUUID) < \"u\" && (l.userSessionId = crypto.randomUUID());\n    },\n    setConnectedWalletId(e) {\n      l.connectedWalletId = e;\n    },\n    click(e) {\n      if (l.enabled) {\n        const t = {\n          type: \"CLICK\",\n          name: e.name,\n          userSessionId: l.userSessionId,\n          timestamp: Date.now(),\n          data: e\n        };\n        l.events.push(t);\n      }\n    },\n    track(e) {\n      if (l.enabled) {\n        const t = {\n          type: \"TRACK\",\n          name: e.name,\n          userSessionId: l.userSessionId,\n          timestamp: Date.now(),\n          data: e\n        };\n        l.events.push(t);\n      }\n    },\n    view(e) {\n      if (l.enabled) {\n        const t = {\n          type: \"VIEW\",\n          name: e.name,\n          userSessionId: l.userSessionId,\n          timestamp: Date.now(),\n          data: e\n        };\n        l.events.push(t);\n      }\n    }\n  },\n  p = g({\n    selectedChain: void 0,\n    chains: void 0,\n    isCustomDesktop: !1,\n    isCustomMobile: !1,\n    isDataLoaded: !1,\n    isUiLoaded: !1,\n    isPreferInjected: !1\n  }),\n  b = {\n    state: p,\n    subscribe(e) {\n      return h(p, () => e(p));\n    },\n    setChains(e) {\n      p.chains = e;\n    },\n    getSelectedChain() {\n      const e = f.client().getNetwork().chain;\n      return e && (p.selectedChain = e), p.selectedChain;\n    },\n    setSelectedChain(e) {\n      p.selectedChain = e;\n    },\n    setIsCustomDesktop(e) {\n      p.isCustomDesktop = e;\n    },\n    setIsCustomMobile(e) {\n      p.isCustomMobile = e;\n    },\n    setIsDataLoaded(e) {\n      p.isDataLoaded = e;\n    },\n    setIsUiLoaded(e) {\n      p.isUiLoaded = e;\n    },\n    setIsPreferInjected(e) {\n      p.isPreferInjected = e;\n    }\n  },\n  O = g({\n    projectId: \"\",\n    mobileWallets: void 0,\n    desktopWallets: void 0,\n    walletImages: void 0,\n    chainImages: void 0,\n    tokenImages: void 0,\n    tokenContracts: void 0,\n    enableNetworkView: !1,\n    enableAccountView: !0,\n    enableExplorer: !0,\n    defaultChain: void 0,\n    explorerExcludedWalletIds: void 0,\n    explorerRecommendedWalletIds: void 0,\n    termsOfServiceUrl: void 0,\n    privacyPolicyUrl: void 0\n  }),\n  C = {\n    state: O,\n    subscribe(e) {\n      return h(O, () => e(O));\n    },\n    setConfig(e) {\n      var t, n;\n      F.initialize(), b.setIsCustomMobile(Boolean((t = e.mobileWallets) == null ? void 0 : t.length)), b.setIsCustomDesktop(Boolean((n = e.desktopWallets) == null ? void 0 : n.length)), b.setChains(f.client().chains), b.setIsPreferInjected(f.client().isInjectedProviderInstalled() && i.isPreferInjectedFlag()), e.defaultChain && b.setSelectedChain(e.defaultChain), i.setWeb3ModalVersionInStorage(), Object.assign(O, e);\n    }\n  },\n  J = \"eip155\",\n  z = \"https://rpc.walletconnect.com\",\n  G = {\n    async getIdentity(e, t) {\n      const {\n          projectId: n\n        } = C.state,\n        s = `${J}:${t}`,\n        a = `${z}/v1/identity/${e}?chainId=${s}&projectId=${n}`;\n      return (await fetch(a)).json();\n    }\n  },\n  r = g({\n    address: void 0,\n    profileName: void 0,\n    profileAvatar: void 0,\n    profileLoading: !1,\n    balanceLoading: !1,\n    balance: void 0,\n    isConnected: !1\n  }),\n  q = {\n    state: r,\n    subscribe(e) {\n      return h(r, () => e(r));\n    },\n    getAccount() {\n      const e = f.client().getAccount();\n      r.address = e.address, r.isConnected = e.isConnected;\n    },\n    async fetchProfile(e, t) {\n      var n;\n      try {\n        r.profileLoading = !0, r.profileName = null, r.profileAvatar = null;\n        const s = t ?? r.address,\n          a = 1,\n          c = (n = b.state.chains) == null ? void 0 : n.find(d => d.id === a);\n        if (s && c) {\n          try {\n            const d = await G.getIdentity(s, a);\n            r.profileName = d.name, r.profileAvatar = d.avatar;\n          } catch {\n            const m = await f.client().fetchEnsName({\n              address: s,\n              chainId: a\n            });\n            if (r.profileName = m, m) {\n              const v = await f.client().fetchEnsAvatar({\n                name: m,\n                chainId: a\n              });\n              r.profileAvatar = v;\n            }\n          }\n          r.profileAvatar && (await e(r.profileAvatar));\n        }\n      } finally {\n        r.profileLoading = !1;\n      }\n    },\n    async fetchBalance(e) {\n      try {\n        const {\n            chain: t\n          } = f.client().getNetwork(),\n          {\n            tokenContracts: n\n          } = C.state;\n        let s;\n        t && n && (s = n[t.id]), r.balanceLoading = !0;\n        const a = e ?? r.address;\n        if (a) {\n          const c = await f.client().fetchBalance({\n            address: a,\n            token: s\n          });\n          r.balance = {\n            amount: c.formatted,\n            symbol: c.symbol\n          };\n        }\n      } finally {\n        r.balanceLoading = !1;\n      }\n    },\n    setAddress(e) {\n      r.address = e;\n    },\n    setIsConnected(e) {\n      r.isConnected = e;\n    },\n    resetBalance() {\n      r.balance = void 0;\n    },\n    resetAccount() {\n      r.address = void 0, r.isConnected = !1, r.profileName = void 0, r.profileAvatar = void 0, r.balance = void 0;\n    }\n  };\nvar Q = Object.defineProperty,\n  S = Object.getOwnPropertySymbols,\n  X = Object.prototype.hasOwnProperty,\n  Y = Object.prototype.propertyIsEnumerable,\n  T = (e, t, n) => t in e ? Q(e, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: n\n  }) : e[t] = n,\n  Z = (e, t) => {\n    for (var n in t || (t = {})) X.call(t, n) && T(e, n, t[n]);\n    if (S) for (var n of S(t)) Y.call(t, n) && T(e, n, t[n]);\n    return e;\n  };\nconst D = \"https://explorer-api.walletconnect.com\",\n  M = \"w3m\",\n  $ = \"js-2.7.1\";\nasync function U(e, t) {\n  const n = Z({\n      sdkType: M,\n      sdkVersion: $\n    }, t),\n    s = new URL(e, D);\n  return s.searchParams.append(\"projectId\", C.state.projectId), Object.entries(n).forEach(([a, c]) => {\n    c && s.searchParams.append(a, String(c));\n  }), (await fetch(s)).json();\n}\nconst I = {\n  async getDesktopListings(e) {\n    return U(\"/w3m/v1/getDesktopListings\", e);\n  },\n  async getMobileListings(e) {\n    return U(\"/w3m/v1/getMobileListings\", e);\n  },\n  async getInjectedListings(e) {\n    return U(\"/w3m/v1/getInjectedListings\", e);\n  },\n  async getAllListings(e) {\n    return U(\"/w3m/v1/getAllListings\", e);\n  },\n  getWalletImageUrl(e) {\n    return `${D}/w3m/v1/getWalletImage/${e}?projectId=${C.state.projectId}&sdkType=${M}&sdkVersion=${$}`;\n  },\n  getAssetImageUrl(e) {\n    return `${D}/w3m/v1/getAssetImage/${e}?projectId=${C.state.projectId}&sdkType=${M}&sdkVersion=${$}`;\n  }\n};\nvar ee = Object.defineProperty,\n  _ = Object.getOwnPropertySymbols,\n  te = Object.prototype.hasOwnProperty,\n  ne = Object.prototype.propertyIsEnumerable,\n  x = (e, t, n) => t in e ? ee(e, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: n\n  }) : e[t] = n,\n  se = (e, t) => {\n    for (var n in t || (t = {})) te.call(t, n) && x(e, n, t[n]);\n    if (_) for (var n of _(t)) ne.call(t, n) && x(e, n, t[n]);\n    return e;\n  };\nconst R = i.isMobile(),\n  u = g({\n    wallets: {\n      listings: [],\n      total: 0,\n      page: 1\n    },\n    injectedWallets: [],\n    search: {\n      listings: [],\n      total: 0,\n      page: 1\n    },\n    recomendedWallets: []\n  }),\n  de = {\n    state: u,\n    async getRecomendedWallets() {\n      const {\n        explorerRecommendedWalletIds: e,\n        explorerExcludedWalletIds: t\n      } = C.state;\n      if (e === \"NONE\" || t === \"ALL\" && !e) return u.recomendedWallets;\n      if (i.isArray(e)) {\n        const n = {\n            recommendedIds: e.join(\",\")\n          },\n          {\n            listings: s\n          } = await I.getAllListings(n),\n          a = Object.values(s);\n        a.sort((c, d) => {\n          const m = e.indexOf(c.id),\n            v = e.indexOf(d.id);\n          return m - v;\n        }), u.recomendedWallets = a;\n      } else {\n        const n = i.isArray(t),\n          s = {\n            page: 1,\n            entries: i.RECOMMENDED_WALLET_AMOUNT,\n            version: 2,\n            excludedIds: n ? t.join(\",\") : void 0\n          },\n          {\n            listings: a\n          } = R ? await I.getMobileListings(s) : await I.getDesktopListings(s);\n        u.recomendedWallets = Object.values(a);\n      }\n      return u.recomendedWallets;\n    },\n    async getWallets(e) {\n      const t = se({}, e),\n        {\n          explorerRecommendedWalletIds: n,\n          explorerExcludedWalletIds: s\n        } = C.state,\n        {\n          recomendedWallets: a\n        } = u;\n      if (s === \"ALL\") return u.wallets;\n      a.length ? t.excludedIds = a.map(N => N.id).join(\",\") : i.isArray(n) && (t.excludedIds = n.join(\",\")), i.isArray(s) && (t.excludedIds = [t.excludedIds, s].filter(Boolean).join(\",\"));\n      const {\n          page: c,\n          search: d\n        } = e,\n        {\n          listings: m,\n          total: v\n        } = R ? await I.getMobileListings(t) : await I.getDesktopListings(t),\n        w = Object.values(m),\n        A = d ? \"search\" : \"wallets\";\n      return u[A] = {\n        listings: [...u[A].listings, ...w],\n        total: v,\n        page: c ?? 1\n      }, {\n        listings: w,\n        total: v\n      };\n    },\n    async getInjectedWallets() {\n      const {\n          listings: e\n        } = await I.getInjectedListings({}),\n        t = Object.values(e);\n      return u.injectedWallets = t, u.injectedWallets;\n    },\n    getWalletImageUrl(e) {\n      return I.getWalletImageUrl(e);\n    },\n    getAssetImageUrl(e) {\n      return I.getAssetImageUrl(e);\n    },\n    resetSearch() {\n      u.search = {\n        listings: [],\n        total: 0,\n        page: 1\n      };\n    }\n  },\n  E = g({\n    pairingEnabled: !1,\n    pairingUri: \"\",\n    pairingError: !1\n  }),\n  P = {\n    state: E,\n    subscribe(e) {\n      return h(E, () => e(E));\n    },\n    setPairingUri(e) {\n      E.pairingUri = e;\n    },\n    setPairingError(e) {\n      E.pairingError = e;\n    },\n    setPairingEnabled(e) {\n      E.pairingEnabled = e;\n    }\n  },\n  L = g({\n    open: !1\n  }),\n  pe = {\n    state: L,\n    subscribe(e) {\n      return h(L, () => e(L));\n    },\n    async open(e) {\n      return new Promise(t => {\n        const {\n            isUiLoaded: n,\n            isDataLoaded: s,\n            isPreferInjected: a,\n            selectedChain: c\n          } = b.state,\n          {\n            isConnected: d\n          } = q.state,\n          {\n            enableNetworkView: m\n          } = C.state;\n        if (P.setPairingEnabled(!0), d || i.removeWalletConnectDeepLink(), e != null && e.route) W.reset(e.route);else if (d) W.reset(\"Account\");else if (m) W.reset(\"SelectNetwork\");else if (a) {\n          f.client().connectConnector(\"injected\", c?.id).catch(w => console.error(w)), t();\n          return;\n        } else W.reset(\"ConnectWallet\");\n        const {\n          pairingUri: v\n        } = P.state;\n        if (n && s && (v || d)) L.open = !0, t();else {\n          const w = setInterval(() => {\n            const A = b.state,\n              N = P.state;\n            A.isUiLoaded && A.isDataLoaded && (N.pairingUri || d) && (clearInterval(w), L.open = !0, t());\n          }, 200);\n        }\n      });\n    },\n    close() {\n      L.open = !1;\n    }\n  };\nvar re = Object.defineProperty,\n  V = Object.getOwnPropertySymbols,\n  ae = Object.prototype.hasOwnProperty,\n  oe = Object.prototype.propertyIsEnumerable,\n  B = (e, t, n) => t in e ? re(e, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: n\n  }) : e[t] = n,\n  ie = (e, t) => {\n    for (var n in t || (t = {})) ae.call(t, n) && B(e, n, t[n]);\n    if (V) for (var n of V(t)) oe.call(t, n) && B(e, n, t[n]);\n    return e;\n  };\nfunction le() {\n  return typeof matchMedia < \"u\" && matchMedia(\"(prefers-color-scheme: dark)\").matches;\n}\nconst j = g({\n    themeMode: le() ? \"dark\" : \"light\"\n  }),\n  ue = {\n    state: j,\n    subscribe(e) {\n      return h(j, () => e(j));\n    },\n    setThemeConfig(e) {\n      const {\n        themeMode: t,\n        themeVariables: n\n      } = e;\n      t && (j.themeMode = t), n && (j.themeVariables = ie({}, n));\n    }\n  },\n  y = g({\n    open: !1,\n    message: \"\",\n    variant: \"success\"\n  }),\n  ge = {\n    state: y,\n    subscribe(e) {\n      return h(y, () => e(y));\n    },\n    openToast(e, t) {\n      y.open = !0, y.message = e, y.variant = t;\n    },\n    closeToast() {\n      y.open = !1;\n    }\n  };\nexport { q as AccountCtrl, f as ClientCtrl, C as ConfigCtrl, i as CoreUtil, F as EventsCtrl, de as ExplorerCtrl, pe as ModalCtrl, b as OptionsCtrl, W as RouterCtrl, ue as ThemeCtrl, ge as ToastCtrl, P as WcConnectionCtrl };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}