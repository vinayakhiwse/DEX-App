{"ast":null,"code":"import G, { Fragment as N, createContext as X, createRef as H, useContext as $, useEffect as q, useMemo as x, useReducer as z, useRef as K } from \"react\";\nimport { match as j } from '../../utils/match.js';\nimport { forwardRefWithAs as h, render as D, Features as Q } from '../../utils/render.js';\nimport { disposables as _ } from '../../utils/disposables.js';\nimport { useDisposables as W } from '../../hooks/use-disposables.js';\nimport { useIsoMorphicEffect as L } from '../../hooks/use-iso-morphic-effect.js';\nimport { useSyncRefs as F } from '../../hooks/use-sync-refs.js';\nimport { useId as k } from '../../hooks/use-id.js';\nimport { Keys as c } from '../keyboard.js';\nimport { Focus as y, calculateActiveIndex as Y } from '../../utils/calculate-active-index.js';\nimport { isDisabledReactIssue7711 as Z } from '../../utils/bugs.js';\nimport { isFocusableElement as ee, FocusableMode as te, sortByDomNode as ne, Focus as V, focusFrom as re, restoreFocusIfNecessary as J } from '../../utils/focus-management.js';\nimport { useOutsideClick as oe } from '../../hooks/use-outside-click.js';\nimport { useTreeWalker as ae } from '../../hooks/use-tree-walker.js';\nimport { useOpenClosed as se, State as C, OpenClosedProvider as ie } from '../../internal/open-closed.js';\nimport { useResolveButtonType as ue } from '../../hooks/use-resolve-button-type.js';\nimport { useOwnerDocument as le } from '../../hooks/use-owner.js';\nimport { useEvent as d } from '../../hooks/use-event.js';\nimport { useTrackedPointer as pe } from '../../hooks/use-tracked-pointer.js';\nimport { useTextValue as ce } from '../../hooks/use-text-value.js';\nvar me = (r => (r[r.Open = 0] = \"Open\", r[r.Closed = 1] = \"Closed\", r))(me || {}),\n  de = (r => (r[r.Pointer = 0] = \"Pointer\", r[r.Other = 1] = \"Other\", r))(de || {}),\n  fe = (a => (a[a.OpenMenu = 0] = \"OpenMenu\", a[a.CloseMenu = 1] = \"CloseMenu\", a[a.GoToItem = 2] = \"GoToItem\", a[a.Search = 3] = \"Search\", a[a.ClearSearch = 4] = \"ClearSearch\", a[a.RegisterItem = 5] = \"RegisterItem\", a[a.UnregisterItem = 6] = \"UnregisterItem\", a))(fe || {});\nfunction w(e, u = r => r) {\n  let r = e.activeItemIndex !== null ? e.items[e.activeItemIndex] : null,\n    i = ne(u(e.items.slice()), t => t.dataRef.current.domRef.current),\n    s = r ? i.indexOf(r) : null;\n  return s === -1 && (s = null), {\n    items: i,\n    activeItemIndex: s\n  };\n}\nlet Te = {\n    [1](e) {\n      return e.menuState === 1 ? e : {\n        ...e,\n        activeItemIndex: null,\n        menuState: 1\n      };\n    },\n    [0](e) {\n      return e.menuState === 0 ? e : {\n        ...e,\n        __demoMode: !1,\n        menuState: 0\n      };\n    },\n    [2]: (e, u) => {\n      var s;\n      let r = w(e),\n        i = Y(u, {\n          resolveItems: () => r.items,\n          resolveActiveIndex: () => r.activeItemIndex,\n          resolveId: t => t.id,\n          resolveDisabled: t => t.dataRef.current.disabled\n        });\n      return {\n        ...e,\n        ...r,\n        searchQuery: \"\",\n        activeItemIndex: i,\n        activationTrigger: (s = u.trigger) != null ? s : 1\n      };\n    },\n    [3]: (e, u) => {\n      let i = e.searchQuery !== \"\" ? 0 : 1,\n        s = e.searchQuery + u.value.toLowerCase(),\n        o = (e.activeItemIndex !== null ? e.items.slice(e.activeItemIndex + i).concat(e.items.slice(0, e.activeItemIndex + i)) : e.items).find(l => {\n          var m;\n          return ((m = l.dataRef.current.textValue) == null ? void 0 : m.startsWith(s)) && !l.dataRef.current.disabled;\n        }),\n        a = o ? e.items.indexOf(o) : -1;\n      return a === -1 || a === e.activeItemIndex ? {\n        ...e,\n        searchQuery: s\n      } : {\n        ...e,\n        searchQuery: s,\n        activeItemIndex: a,\n        activationTrigger: 1\n      };\n    },\n    [4](e) {\n      return e.searchQuery === \"\" ? e : {\n        ...e,\n        searchQuery: \"\",\n        searchActiveItemIndex: null\n      };\n    },\n    [5]: (e, u) => {\n      let r = w(e, i => [...i, {\n        id: u.id,\n        dataRef: u.dataRef\n      }]);\n      return {\n        ...e,\n        ...r\n      };\n    },\n    [6]: (e, u) => {\n      let r = w(e, i => {\n        let s = i.findIndex(t => t.id === u.id);\n        return s !== -1 && i.splice(s, 1), i;\n      });\n      return {\n        ...e,\n        ...r,\n        activationTrigger: 1\n      };\n    }\n  },\n  U = X(null);\nU.displayName = \"MenuContext\";\nfunction O(e) {\n  let u = $(U);\n  if (u === null) {\n    let r = new Error(`<${e} /> is missing a parent <Menu /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(r, O), r;\n  }\n  return u;\n}\nfunction ye(e, u) {\n  return j(u.type, Te, e, u);\n}\nlet Ie = N;\nfunction Me(e, u) {\n  let {\n      __demoMode: r = !1,\n      ...i\n    } = e,\n    s = z(ye, {\n      __demoMode: r,\n      menuState: r ? 0 : 1,\n      buttonRef: H(),\n      itemsRef: H(),\n      items: [],\n      searchQuery: \"\",\n      activeItemIndex: null,\n      activationTrigger: 1\n    }),\n    [{\n      menuState: t,\n      itemsRef: o,\n      buttonRef: a\n    }, l] = s,\n    m = F(u);\n  oe([a, o], (g, R) => {\n    var p;\n    l({\n      type: 1\n    }), ee(R, te.Loose) || (g.preventDefault(), (p = a.current) == null || p.focus());\n  }, t === 0);\n  let I = d(() => {\n      l({\n        type: 1\n      });\n    }),\n    A = x(() => ({\n      open: t === 0,\n      close: I\n    }), [t, I]),\n    f = {\n      ref: m\n    };\n  return G.createElement(U.Provider, {\n    value: s\n  }, G.createElement(ie, {\n    value: j(t, {\n      [0]: C.Open,\n      [1]: C.Closed\n    })\n  }, D({\n    ourProps: f,\n    theirProps: i,\n    slot: A,\n    defaultTag: Ie,\n    name: \"Menu\"\n  })));\n}\nlet ge = \"button\";\nfunction Re(e, u) {\n  var R;\n  let r = k(),\n    {\n      id: i = `headlessui-menu-button-${r}`,\n      ...s\n    } = e,\n    [t, o] = O(\"Menu.Button\"),\n    a = F(t.buttonRef, u),\n    l = W(),\n    m = d(p => {\n      switch (p.key) {\n        case c.Space:\n        case c.Enter:\n        case c.ArrowDown:\n          p.preventDefault(), p.stopPropagation(), o({\n            type: 0\n          }), l.nextFrame(() => o({\n            type: 2,\n            focus: y.First\n          }));\n          break;\n        case c.ArrowUp:\n          p.preventDefault(), p.stopPropagation(), o({\n            type: 0\n          }), l.nextFrame(() => o({\n            type: 2,\n            focus: y.Last\n          }));\n          break;\n      }\n    }),\n    I = d(p => {\n      switch (p.key) {\n        case c.Space:\n          p.preventDefault();\n          break;\n      }\n    }),\n    A = d(p => {\n      if (Z(p.currentTarget)) return p.preventDefault();\n      e.disabled || (t.menuState === 0 ? (o({\n        type: 1\n      }), l.nextFrame(() => {\n        var M;\n        return (M = t.buttonRef.current) == null ? void 0 : M.focus({\n          preventScroll: !0\n        });\n      })) : (p.preventDefault(), o({\n        type: 0\n      })));\n    }),\n    f = x(() => ({\n      open: t.menuState === 0\n    }), [t]),\n    g = {\n      ref: a,\n      id: i,\n      type: ue(e, t.buttonRef),\n      \"aria-haspopup\": \"menu\",\n      \"aria-controls\": (R = t.itemsRef.current) == null ? void 0 : R.id,\n      \"aria-expanded\": t.menuState === 0,\n      onKeyDown: m,\n      onKeyUp: I,\n      onClick: A\n    };\n  return D({\n    ourProps: g,\n    theirProps: s,\n    slot: f,\n    defaultTag: ge,\n    name: \"Menu.Button\"\n  });\n}\nlet Ae = \"div\",\n  be = Q.RenderStrategy | Q.Static;\nfunction Ee(e, u) {\n  var M, b;\n  let r = k(),\n    {\n      id: i = `headlessui-menu-items-${r}`,\n      ...s\n    } = e,\n    [t, o] = O(\"Menu.Items\"),\n    a = F(t.itemsRef, u),\n    l = le(t.itemsRef),\n    m = W(),\n    I = se(),\n    A = (() => I !== null ? (I & C.Open) === C.Open : t.menuState === 0)();\n  q(() => {\n    let n = t.itemsRef.current;\n    n && t.menuState === 0 && n !== (l == null ? void 0 : l.activeElement) && n.focus({\n      preventScroll: !0\n    });\n  }, [t.menuState, t.itemsRef, l]), ae({\n    container: t.itemsRef.current,\n    enabled: t.menuState === 0,\n    accept(n) {\n      return n.getAttribute(\"role\") === \"menuitem\" ? NodeFilter.FILTER_REJECT : n.hasAttribute(\"role\") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;\n    },\n    walk(n) {\n      n.setAttribute(\"role\", \"none\");\n    }\n  });\n  let f = d(n => {\n      var E, P;\n      switch (m.dispose(), n.key) {\n        case c.Space:\n          if (t.searchQuery !== \"\") return n.preventDefault(), n.stopPropagation(), o({\n            type: 3,\n            value: n.key\n          });\n        case c.Enter:\n          if (n.preventDefault(), n.stopPropagation(), o({\n            type: 1\n          }), t.activeItemIndex !== null) {\n            let {\n              dataRef: S\n            } = t.items[t.activeItemIndex];\n            (P = (E = S.current) == null ? void 0 : E.domRef.current) == null || P.click();\n          }\n          J(t.buttonRef.current);\n          break;\n        case c.ArrowDown:\n          return n.preventDefault(), n.stopPropagation(), o({\n            type: 2,\n            focus: y.Next\n          });\n        case c.ArrowUp:\n          return n.preventDefault(), n.stopPropagation(), o({\n            type: 2,\n            focus: y.Previous\n          });\n        case c.Home:\n        case c.PageUp:\n          return n.preventDefault(), n.stopPropagation(), o({\n            type: 2,\n            focus: y.First\n          });\n        case c.End:\n        case c.PageDown:\n          return n.preventDefault(), n.stopPropagation(), o({\n            type: 2,\n            focus: y.Last\n          });\n        case c.Escape:\n          n.preventDefault(), n.stopPropagation(), o({\n            type: 1\n          }), _().nextFrame(() => {\n            var S;\n            return (S = t.buttonRef.current) == null ? void 0 : S.focus({\n              preventScroll: !0\n            });\n          });\n          break;\n        case c.Tab:\n          n.preventDefault(), n.stopPropagation(), o({\n            type: 1\n          }), _().nextFrame(() => {\n            re(t.buttonRef.current, n.shiftKey ? V.Previous : V.Next);\n          });\n          break;\n        default:\n          n.key.length === 1 && (o({\n            type: 3,\n            value: n.key\n          }), m.setTimeout(() => o({\n            type: 4\n          }), 350));\n          break;\n      }\n    }),\n    g = d(n => {\n      switch (n.key) {\n        case c.Space:\n          n.preventDefault();\n          break;\n      }\n    }),\n    R = x(() => ({\n      open: t.menuState === 0\n    }), [t]),\n    p = {\n      \"aria-activedescendant\": t.activeItemIndex === null || (M = t.items[t.activeItemIndex]) == null ? void 0 : M.id,\n      \"aria-labelledby\": (b = t.buttonRef.current) == null ? void 0 : b.id,\n      id: i,\n      onKeyDown: f,\n      onKeyUp: g,\n      role: \"menu\",\n      tabIndex: 0,\n      ref: a\n    };\n  return D({\n    ourProps: p,\n    theirProps: s,\n    slot: R,\n    defaultTag: Ae,\n    features: be,\n    visible: A,\n    name: \"Menu.Items\"\n  });\n}\nlet Se = N;\nfunction Pe(e, u) {\n  let r = k(),\n    {\n      id: i = `headlessui-menu-item-${r}`,\n      disabled: s = !1,\n      ...t\n    } = e,\n    [o, a] = O(\"Menu.Item\"),\n    l = o.activeItemIndex !== null ? o.items[o.activeItemIndex].id === i : !1,\n    m = K(null),\n    I = F(u, m);\n  L(() => {\n    if (o.__demoMode || o.menuState !== 0 || !l || o.activationTrigger === 0) return;\n    let T = _();\n    return T.requestAnimationFrame(() => {\n      var v, B;\n      (B = (v = m.current) == null ? void 0 : v.scrollIntoView) == null || B.call(v, {\n        block: \"nearest\"\n      });\n    }), T.dispose;\n  }, [o.__demoMode, m, l, o.menuState, o.activationTrigger, o.activeItemIndex]);\n  let A = ce(m),\n    f = K({\n      disabled: s,\n      domRef: m,\n      get textValue() {\n        return A();\n      }\n    });\n  L(() => {\n    f.current.disabled = s;\n  }, [f, s]), L(() => (a({\n    type: 5,\n    id: i,\n    dataRef: f\n  }), () => a({\n    type: 6,\n    id: i\n  })), [f, i]);\n  let g = d(() => {\n      a({\n        type: 1\n      });\n    }),\n    R = d(T => {\n      if (s) return T.preventDefault();\n      a({\n        type: 1\n      }), J(o.buttonRef.current);\n    }),\n    p = d(() => {\n      if (s) return a({\n        type: 2,\n        focus: y.Nothing\n      });\n      a({\n        type: 2,\n        focus: y.Specific,\n        id: i\n      });\n    }),\n    M = pe(),\n    b = d(T => M.update(T)),\n    n = d(T => {\n      M.wasMoved(T) && (s || l || a({\n        type: 2,\n        focus: y.Specific,\n        id: i,\n        trigger: 0\n      }));\n    }),\n    E = d(T => {\n      M.wasMoved(T) && (s || l && a({\n        type: 2,\n        focus: y.Nothing\n      }));\n    }),\n    P = x(() => ({\n      active: l,\n      disabled: s,\n      close: g\n    }), [l, s, g]);\n  return D({\n    ourProps: {\n      id: i,\n      ref: I,\n      role: \"menuitem\",\n      tabIndex: s === !0 ? void 0 : -1,\n      \"aria-disabled\": s === !0 ? !0 : void 0,\n      disabled: void 0,\n      onClick: R,\n      onFocus: p,\n      onPointerEnter: b,\n      onMouseEnter: b,\n      onPointerMove: n,\n      onMouseMove: n,\n      onPointerLeave: E,\n      onMouseLeave: E\n    },\n    theirProps: t,\n    slot: P,\n    defaultTag: Se,\n    name: \"Menu.Item\"\n  });\n}\nlet ve = h(Me),\n  xe = h(Re),\n  he = h(Ee),\n  De = h(Pe),\n  it = Object.assign(ve, {\n    Button: xe,\n    Items: he,\n    Item: De\n  });\nexport { it as Menu };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}