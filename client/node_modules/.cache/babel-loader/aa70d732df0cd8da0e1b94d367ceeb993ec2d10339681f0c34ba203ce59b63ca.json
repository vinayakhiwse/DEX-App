{"ast":null,"code":"import { useControlledState as $fQ2SF$useControlledState } from \"@react-stately/utils\";\nimport { useMemo as $fQ2SF$useMemo, useState as $fQ2SF$useState } from \"react\";\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\nvar $a54cdc5c1942b639$exports = {};\n$parcel$export($a54cdc5c1942b639$exports, \"useRadioGroupState\", () => $a54cdc5c1942b639$export$bca9d026f8e704eb);\nlet $a54cdc5c1942b639$var$instance = Math.round(Math.random() * 10000000000);\nlet $a54cdc5c1942b639$var$i = 0;\nfunction $a54cdc5c1942b639$export$bca9d026f8e704eb(props) {\n  // Preserved here for backward compatibility. React Aria now generates the name instead of stately.\n  let name = $fQ2SF$useMemo(() => props.name || `radio-group-${$a54cdc5c1942b639$var$instance}-${++$a54cdc5c1942b639$var$i}`, [props.name]);\n  let [selectedValue, setSelected] = $fQ2SF$useControlledState(props.value, props.defaultValue, props.onChange);\n  let [lastFocusedValue, setLastFocusedValue] = $fQ2SF$useState(null);\n  let setSelectedValue = value => {\n    if (!props.isReadOnly && !props.isDisabled) setSelected(value);\n  };\n  return {\n    name: name,\n    selectedValue: selectedValue,\n    setSelectedValue: setSelectedValue,\n    lastFocusedValue: lastFocusedValue,\n    setLastFocusedValue: setLastFocusedValue,\n    isDisabled: props.isDisabled || false,\n    isReadOnly: props.isReadOnly || false\n  };\n}\nexport { $a54cdc5c1942b639$export$bca9d026f8e704eb as useRadioGroupState };\n//# sourceMappingURL=module.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}