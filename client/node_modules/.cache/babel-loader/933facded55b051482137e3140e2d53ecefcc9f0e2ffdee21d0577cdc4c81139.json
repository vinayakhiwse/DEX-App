{"ast":null,"code":"import _, { Fragment as ne, createContext as V, useContext as Q, useMemo as F, useReducer as re, useRef as K } from \"react\";\nimport { render as w, Features as Y, forwardRefWithAs as v } from '../../utils/render.js';\nimport { useId as Z } from '../../hooks/use-id.js';\nimport { match as G } from '../../utils/match.js';\nimport { Keys as P } from '../../components/keyboard.js';\nimport { focusIn as h, Focus as x, sortByDomNode as H, FocusResult as k } from '../../utils/focus-management.js';\nimport { useIsoMorphicEffect as O } from '../../hooks/use-iso-morphic-effect.js';\nimport { useSyncRefs as U } from '../../hooks/use-sync-refs.js';\nimport { useResolveButtonType as ae } from '../../hooks/use-resolve-button-type.js';\nimport { useLatestValue as J } from '../../hooks/use-latest-value.js';\nimport { FocusSentinel as le } from '../../internal/focus-sentinel.js';\nimport { useEvent as S } from '../../hooks/use-event.js';\nimport { microTask as oe } from '../../utils/micro-task.js';\nimport { Hidden as se } from '../../internal/hidden.js';\nimport { getOwnerDocument as ie } from '../../utils/owner.js';\nimport { StableCollection as pe, useStableCollectionIndex as ee } from '../../utils/stable-collection.js';\nvar ue = (t => (t[t.Forwards = 0] = \"Forwards\", t[t.Backwards = 1] = \"Backwards\", t))(ue || {}),\n  Te = (o => (o[o.Less = -1] = \"Less\", o[o.Equal = 0] = \"Equal\", o[o.Greater = 1] = \"Greater\", o))(Te || {}),\n  de = (r => (r[r.SetSelectedIndex = 0] = \"SetSelectedIndex\", r[r.RegisterTab = 1] = \"RegisterTab\", r[r.UnregisterTab = 2] = \"UnregisterTab\", r[r.RegisterPanel = 3] = \"RegisterPanel\", r[r.UnregisterPanel = 4] = \"UnregisterPanel\", r))(de || {});\nlet ce = {\n    [0](e, n) {\n      var u;\n      let t = H(e.tabs, T => T.current),\n        o = H(e.panels, T => T.current),\n        s = t.filter(T => {\n          var l;\n          return !((l = T.current) != null && l.hasAttribute(\"disabled\"));\n        }),\n        r = {\n          ...e,\n          tabs: t,\n          panels: o\n        };\n      if (n.index < 0 || n.index > t.length - 1) {\n        let T = G(Math.sign(n.index - e.selectedIndex), {\n          [-1]: () => 1,\n          [0]: () => G(Math.sign(n.index), {\n            [-1]: () => 0,\n            [0]: () => 0,\n            [1]: () => 1\n          }),\n          [1]: () => 0\n        });\n        if (s.length === 0) return r;\n        let l = G(T, {\n          [0]: () => t.indexOf(s[0]),\n          [1]: () => t.indexOf(s[s.length - 1])\n        });\n        return {\n          ...r,\n          selectedIndex: l === -1 ? e.selectedIndex : l\n        };\n      }\n      let i = t.slice(0, n.index),\n        b = [...t.slice(n.index), ...i].find(T => s.includes(T));\n      if (!b) return r;\n      let c = (u = t.indexOf(b)) != null ? u : e.selectedIndex;\n      return c === -1 && (c = e.selectedIndex), {\n        ...r,\n        selectedIndex: c\n      };\n    },\n    [1](e, n) {\n      var r;\n      if (e.tabs.includes(n.tab)) return e;\n      let t = e.tabs[e.selectedIndex],\n        o = H([...e.tabs, n.tab], i => i.current),\n        s = (r = o.indexOf(t)) != null ? r : e.selectedIndex;\n      return s === -1 && (s = e.selectedIndex), {\n        ...e,\n        tabs: o,\n        selectedIndex: s\n      };\n    },\n    [2](e, n) {\n      return {\n        ...e,\n        tabs: e.tabs.filter(t => t !== n.tab)\n      };\n    },\n    [3](e, n) {\n      return e.panels.includes(n.panel) ? e : {\n        ...e,\n        panels: H([...e.panels, n.panel], t => t.current)\n      };\n    },\n    [4](e, n) {\n      return {\n        ...e,\n        panels: e.panels.filter(t => t !== n.panel)\n      };\n    }\n  },\n  X = V(null);\nX.displayName = \"TabsDataContext\";\nfunction M(e) {\n  let n = Q(X);\n  if (n === null) {\n    let t = new Error(`<${e} /> is missing a parent <Tab.Group /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(t, M), t;\n  }\n  return n;\n}\nlet $ = V(null);\n$.displayName = \"TabsActionsContext\";\nfunction q(e) {\n  let n = Q($);\n  if (n === null) {\n    let t = new Error(`<${e} /> is missing a parent <Tab.Group /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(t, q), t;\n  }\n  return n;\n}\nfunction fe(e, n) {\n  return G(n.type, ce, e, n);\n}\nlet be = ne;\nfunction me(e, n) {\n  let {\n    defaultIndex: t = 0,\n    vertical: o = !1,\n    manual: s = !1,\n    onChange: r,\n    selectedIndex: i = null,\n    ...R\n  } = e;\n  const b = o ? \"vertical\" : \"horizontal\",\n    c = s ? \"manual\" : \"auto\";\n  let u = i !== null,\n    T = U(n),\n    [l, d] = re(fe, {\n      selectedIndex: i != null ? i : t,\n      tabs: [],\n      panels: []\n    }),\n    g = F(() => ({\n      selectedIndex: l.selectedIndex\n    }), [l.selectedIndex]),\n    m = J(r || (() => {})),\n    y = J(l.tabs),\n    E = F(() => ({\n      orientation: b,\n      activation: c,\n      ...l\n    }), [b, c, l]),\n    I = S(p => (d({\n      type: 1,\n      tab: p\n    }), () => d({\n      type: 2,\n      tab: p\n    }))),\n    A = S(p => (d({\n      type: 3,\n      panel: p\n    }), () => d({\n      type: 4,\n      panel: p\n    }))),\n    L = S(p => {\n      C.current !== p && m.current(p), u || d({\n        type: 0,\n        index: p\n      });\n    }),\n    C = J(u ? e.selectedIndex : l.selectedIndex),\n    N = F(() => ({\n      registerTab: I,\n      registerPanel: A,\n      change: L\n    }), []);\n  O(() => {\n    d({\n      type: 0,\n      index: i != null ? i : t\n    });\n  }, [i]), O(() => {\n    if (C.current === void 0 || l.tabs.length <= 0) return;\n    let p = H(l.tabs, a => a.current);\n    p.some((a, f) => l.tabs[f] !== a) && L(p.indexOf(l.tabs[C.current]));\n  });\n  let B = {\n    ref: T\n  };\n  return _.createElement(pe, null, _.createElement($.Provider, {\n    value: N\n  }, _.createElement(X.Provider, {\n    value: E\n  }, E.tabs.length <= 0 && _.createElement(le, {\n    onFocus: () => {\n      var p, D;\n      for (let a of y.current) if (((p = a.current) == null ? void 0 : p.tabIndex) === 0) return (D = a.current) == null || D.focus(), !0;\n      return !1;\n    }\n  }), w({\n    ourProps: B,\n    theirProps: R,\n    slot: g,\n    defaultTag: be,\n    name: \"Tabs\"\n  }))));\n}\nlet Pe = \"div\";\nfunction xe(e, n) {\n  let {\n      orientation: t,\n      selectedIndex: o\n    } = M(\"Tab.List\"),\n    s = U(n);\n  return w({\n    ourProps: {\n      ref: s,\n      role: \"tablist\",\n      \"aria-orientation\": t\n    },\n    theirProps: e,\n    slot: {\n      selectedIndex: o\n    },\n    defaultTag: Pe,\n    name: \"Tabs.List\"\n  });\n}\nlet ge = \"button\";\nfunction ye(e, n) {\n  var p, D;\n  let t = Z(),\n    {\n      id: o = `headlessui-tabs-tab-${t}`,\n      ...s\n    } = e,\n    {\n      orientation: r,\n      activation: i,\n      selectedIndex: R,\n      tabs: b,\n      panels: c\n    } = M(\"Tab\"),\n    u = q(\"Tab\"),\n    T = M(\"Tab\"),\n    l = K(null),\n    d = U(l, n);\n  O(() => u.registerTab(l), [u, l]);\n  let g = ee(\"tabs\"),\n    m = b.indexOf(l);\n  m === -1 && (m = g);\n  let y = m === R,\n    E = S(a => {\n      var j;\n      let f = a();\n      if (f === k.Success && i === \"auto\") {\n        let W = (j = ie(l)) == null ? void 0 : j.activeElement,\n          z = T.tabs.findIndex(te => te.current === W);\n        z !== -1 && u.change(z);\n      }\n      return f;\n    }),\n    I = S(a => {\n      let f = b.map(W => W.current).filter(Boolean);\n      if (a.key === P.Space || a.key === P.Enter) {\n        a.preventDefault(), a.stopPropagation(), u.change(m);\n        return;\n      }\n      switch (a.key) {\n        case P.Home:\n        case P.PageUp:\n          return a.preventDefault(), a.stopPropagation(), E(() => h(f, x.First));\n        case P.End:\n        case P.PageDown:\n          return a.preventDefault(), a.stopPropagation(), E(() => h(f, x.Last));\n      }\n      if (E(() => G(r, {\n        vertical() {\n          return a.key === P.ArrowUp ? h(f, x.Previous | x.WrapAround) : a.key === P.ArrowDown ? h(f, x.Next | x.WrapAround) : k.Error;\n        },\n        horizontal() {\n          return a.key === P.ArrowLeft ? h(f, x.Previous | x.WrapAround) : a.key === P.ArrowRight ? h(f, x.Next | x.WrapAround) : k.Error;\n        }\n      })) === k.Success) return a.preventDefault();\n    }),\n    A = K(!1),\n    L = S(() => {\n      var a;\n      A.current || (A.current = !0, (a = l.current) == null || a.focus({\n        preventScroll: !0\n      }), u.change(m), oe(() => {\n        A.current = !1;\n      }));\n    }),\n    C = S(a => {\n      a.preventDefault();\n    }),\n    N = F(() => ({\n      selected: y\n    }), [y]),\n    B = {\n      ref: d,\n      onKeyDown: I,\n      onMouseDown: C,\n      onClick: L,\n      id: o,\n      role: \"tab\",\n      type: ae(e, l),\n      \"aria-controls\": (D = (p = c[m]) == null ? void 0 : p.current) == null ? void 0 : D.id,\n      \"aria-selected\": y,\n      tabIndex: y ? 0 : -1\n    };\n  return w({\n    ourProps: B,\n    theirProps: s,\n    slot: N,\n    defaultTag: ge,\n    name: \"Tabs.Tab\"\n  });\n}\nlet Ee = \"div\";\nfunction Ae(e, n) {\n  let {\n      selectedIndex: t\n    } = M(\"Tab.Panels\"),\n    o = U(n),\n    s = F(() => ({\n      selectedIndex: t\n    }), [t]);\n  return w({\n    ourProps: {\n      ref: o\n    },\n    theirProps: e,\n    slot: s,\n    defaultTag: Ee,\n    name: \"Tabs.Panels\"\n  });\n}\nlet Re = \"div\",\n  Le = Y.RenderStrategy | Y.Static;\nfunction Se(e, n) {\n  var E, I, A, L;\n  let t = Z(),\n    {\n      id: o = `headlessui-tabs-panel-${t}`,\n      tabIndex: s = 0,\n      ...r\n    } = e,\n    {\n      selectedIndex: i,\n      tabs: R,\n      panels: b\n    } = M(\"Tab.Panel\"),\n    c = q(\"Tab.Panel\"),\n    u = K(null),\n    T = U(u, n);\n  O(() => c.registerPanel(u), [c, u]);\n  let l = ee(\"panels\"),\n    d = b.indexOf(u);\n  d === -1 && (d = l);\n  let g = d === i,\n    m = F(() => ({\n      selected: g\n    }), [g]),\n    y = {\n      ref: T,\n      id: o,\n      role: \"tabpanel\",\n      \"aria-labelledby\": (I = (E = R[d]) == null ? void 0 : E.current) == null ? void 0 : I.id,\n      tabIndex: g ? s : -1\n    };\n  return !g && ((A = r.unmount) == null || A) && !((L = r.static) != null && L) ? _.createElement(se, {\n    as: \"span\",\n    ...y\n  }) : w({\n    ourProps: y,\n    theirProps: r,\n    slot: m,\n    defaultTag: Re,\n    features: Le,\n    visible: g,\n    name: \"Tabs.Panel\"\n  });\n}\nlet Ie = v(ye),\n  De = v(me),\n  Fe = v(xe),\n  he = v(Ae),\n  Me = v(Se),\n  rt = Object.assign(Ie, {\n    Group: De,\n    List: Fe,\n    Panels: he,\n    Panel: Me\n  });\nexport { rt as Tab };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}