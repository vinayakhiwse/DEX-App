{"ast":null,"code":"import { Section as $6555104ff085bef4$re_export$Section, useCollection as $1BfjW$useCollection } from \"@react-stately/collections\";\nimport { useGridState as $1BfjW$useGridState, GridCollection as $1BfjW$GridCollection } from \"@react-stately/grid\";\nimport $1BfjW$react, { useMemo as $1BfjW$useMemo } from \"react\";\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\nvar $4a0dd036d492cee4$exports = {};\n$parcel$export($4a0dd036d492cee4$exports, \"useTableState\", () => $4a0dd036d492cee4$export$907bcc6c48325fd6);\nconst $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY = 'row-header-column-' + Math.random().toString(36).slice(2);\n// const RESIZE_BUFFER_COLUMN_KEY = 'resize-buffer-column' + Math.random().toString(36).slice(2);\nfunction $788781baa30117fa$var$buildHeaderRows(keyMap, columnNodes) {\n  let columns = [];\n  let seen = new Map();\n  for (let column of columnNodes) {\n    let parentKey = column.parentKey;\n    let col = [column];\n    while (parentKey) {\n      let parent = keyMap.get(parentKey);\n      // If we've already seen this parent, than it is shared\n      // with a previous column. If the current column is taller\n      // than the previous column, than we need to shift the parent\n      // in the previous column so it's level with the current column.\n      if (seen.has(parent)) {\n        parent.colspan++;\n        let {\n          column: column,\n          index: index\n        } = seen.get(parent);\n        if (index > col.length) break;\n        for (let i = index; i < col.length; i++) column.splice(i, 0, null);\n        // Adjust shifted indices\n        for (let i1 = col.length; i1 < column.length; i1++) if (column[i1] && seen.has(column[i1])) seen.get(column[i1]).index = i1;\n      } else {\n        parent.colspan = 1;\n        col.push(parent);\n        seen.set(parent, {\n          column: col,\n          index: col.length - 1\n        });\n      }\n      parentKey = parent.parentKey;\n    }\n    columns.push(col);\n    column.index = columns.length - 1;\n  }\n  let maxLength = Math.max(...columns.map(c => c.length));\n  let headerRows = Array(maxLength).fill(0).map(() => []);\n  // Convert columns into rows.\n  let colIndex = 0;\n  for (let column1 of columns) {\n    let i = maxLength - 1;\n    for (let item of column1) {\n      if (item) {\n        // Fill the space up until the current column with a placeholder\n        let row = headerRows[i];\n        let rowLength = row.reduce((p, c) => p + c.colspan, 0);\n        if (rowLength < colIndex) {\n          let placeholder = {\n            type: 'placeholder',\n            key: 'placeholder-' + item.key,\n            colspan: colIndex - rowLength,\n            index: rowLength,\n            value: null,\n            rendered: null,\n            level: i,\n            hasChildNodes: false,\n            childNodes: [],\n            textValue: null\n          };\n          if (row.length > 0) {\n            row[row.length - 1].nextKey = placeholder.key;\n            placeholder.prevKey = row[row.length - 1].key;\n          }\n          row.push(placeholder);\n        }\n        if (row.length > 0) {\n          row[row.length - 1].nextKey = item.key;\n          item.prevKey = row[row.length - 1].key;\n        }\n        item.level = i;\n        item.index = colIndex;\n        row.push(item);\n      }\n      i--;\n    }\n    colIndex++;\n  }\n  // Add placeholders at the end of each row that is shorter than the maximum\n  let i = 0;\n  for (let row1 of headerRows) {\n    let rowLength = row1.reduce((p, c) => p + c.colspan, 0);\n    if (rowLength < columnNodes.length) {\n      let placeholder = {\n        type: 'placeholder',\n        key: 'placeholder-' + row1[row1.length - 1].key,\n        colspan: columnNodes.length - rowLength,\n        index: rowLength,\n        value: null,\n        rendered: null,\n        level: i,\n        hasChildNodes: false,\n        childNodes: [],\n        textValue: null,\n        prevKey: row1[row1.length - 1].key\n      };\n      row1.push(placeholder);\n    }\n    i++;\n  }\n  return headerRows.map((childNodes, index) => {\n    let row = {\n      type: 'headerrow',\n      key: 'headerrow-' + index,\n      index: index,\n      value: null,\n      rendered: null,\n      level: 0,\n      hasChildNodes: true,\n      childNodes: childNodes,\n      textValue: null\n    };\n    return row;\n  });\n}\nvar tmp = Symbol.iterator;\nclass $788781baa30117fa$export$596e1b2e2cf93690 extends $1BfjW$GridCollection {\n  *[tmp]() {\n    yield* this.body.childNodes;\n  }\n  get size() {\n    return [...this.body.childNodes].length;\n  }\n  getKeys() {\n    return this.keyMap.keys();\n  }\n  getKeyBefore(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n  getKeyAfter(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n  getFirstKey() {\n    var ref;\n    return (ref = [...this.body.childNodes][0]) === null || ref === void 0 ? void 0 : ref.key;\n  }\n  getLastKey() {\n    var ref;\n    let rows = [...this.body.childNodes];\n    return (ref = rows[rows.length - 1]) === null || ref === void 0 ? void 0 : ref.key;\n  }\n  getItem(key) {\n    return this.keyMap.get(key);\n  }\n  at(idx) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n  constructor(nodes, prev, opts) {\n    let rowHeaderColumnKeys = new Set();\n    let body;\n    let columns = [];\n    // Add cell for selection checkboxes if needed.\n    if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {\n      let rowHeaderColumn = {\n        type: 'column',\n        key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY,\n        value: null,\n        textValue: '',\n        level: 0,\n        index: 0,\n        hasChildNodes: false,\n        rendered: null,\n        childNodes: [],\n        props: {\n          isSelectionCell: true\n        }\n      };\n      columns.unshift(rowHeaderColumn);\n    }\n    let rows = [];\n    let columnKeyMap = new Map();\n    let visit = node => {\n      switch (node.type) {\n        case 'body':\n          body = node;\n          break;\n        case 'column':\n          columnKeyMap.set(node.key, node);\n          if (!node.hasChildNodes) {\n            columns.push(node);\n            if (node.props.isRowHeader) rowHeaderColumnKeys.add(node.key);\n          }\n          break;\n        case 'item':\n          rows.push(node);\n          return;\n        // do not go into childNodes\n      }\n\n      for (let child of node.childNodes) visit(child);\n    };\n    for (let node1 of nodes) visit(node1);\n    // if (Array.from(nodes).some(node => node.props?.allowsResizing)) {\n    //   /*\n    //   If the table content width > table width, a horizontal scroll bar is present.\n    //   If a user tries to resize a column, making it smaller while they are scrolled to the\n    //   end of the content horizontally, it shrinks the total table content width, causing\n    //   things to snap around and breaks the resize behavior.\n    //   To fix this, we add a resize buffer column (aka \"spooky column\") to the end of the table.\n    //   The width of this column defaults to 0. If you try and shrink a column and the width of the\n    //   table contents > table width, then the \"spooky column\" will grow to take up the difference\n    //   so that the total table content width remains constant while you are resizing. Once you\n    //   finish resizing, the \"spooky column\" snaps back to 0.\n    //   */\n    //   let resizeBufferColumn: GridNode<T> = {\n    //     type: 'column',\n    //     key: RESIZE_BUFFER_COLUMN_KEY,\n    //     value: null,\n    //     textValue: '',\n    //     level: 0,\n    //     index: columns.length,\n    //     hasChildNodes: false,\n    //     rendered: null,\n    //     childNodes: [],\n    //     props: {\n    //       isResizeBuffer: true,\n    //       defaultWidth: 0\n    //     }\n    //   };\n    //   columns.push(resizeBufferColumn);\n    // }\n    let headerRows = $788781baa30117fa$var$buildHeaderRows(columnKeyMap, columns);\n    headerRows.forEach((row, i) => rows.splice(i, 0, row));\n    super({\n      columnCount: columns.length,\n      items: rows,\n      visitNode: node => {\n        node.column = columns[node.index];\n        return node;\n      }\n    });\n    this.columns = columns;\n    this.rowHeaderColumnKeys = rowHeaderColumnKeys;\n    this.body = body;\n    this.headerRows = headerRows;\n    // Default row header column to the first one.\n    if (this.rowHeaderColumnKeys.size === 0) this.rowHeaderColumnKeys.add(this.columns[(opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) ? 1 : 0].key);\n  }\n}\nconst $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION = {\n  ascending: 'descending',\n  descending: 'ascending'\n};\nfunction $4a0dd036d492cee4$export$907bcc6c48325fd6(props) {\n  let {\n    selectionMode = 'none'\n  } = props;\n  let context = $1BfjW$useMemo(() => ({\n    showSelectionCheckboxes: props.showSelectionCheckboxes && selectionMode !== 'none',\n    selectionMode: selectionMode,\n    columns: []\n  }), [props.children, props.showSelectionCheckboxes, selectionMode]);\n  let collection = $1BfjW$useCollection(props, (nodes, prev) => new $788781baa30117fa$export$596e1b2e2cf93690(nodes, prev, context), context);\n  let {\n    disabledKeys: disabledKeys,\n    selectionManager: selectionManager\n  } = $1BfjW$useGridState({\n    ...props,\n    collection: collection\n  });\n  // const tableColumnResizeState = useTableColumnResizeState({columns: collection.columns, getDefaultWidth: props.getDefaultWidth, onColumnResize: props.onColumnResize, onColumnResizeEnd: props.onColumnResizeEnd});\n  return {\n    collection: collection,\n    disabledKeys: disabledKeys,\n    selectionManager: selectionManager,\n    showSelectionCheckboxes: props.showSelectionCheckboxes || false,\n    sortDescriptor: props.sortDescriptor,\n    sort(columnKey, direction) {\n      var ref;\n      props.onSortChange({\n        column: columnKey,\n        direction: direction !== null && direction !== void 0 ? direction : ((ref = props.sortDescriptor) === null || ref === void 0 ? void 0 : ref.column) === columnKey ? $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION[props.sortDescriptor.direction] : 'ascending'\n      });\n    }\n  };\n}\nvar $312ae3b56a94a86e$exports = {};\n$parcel$export($312ae3b56a94a86e$exports, \"TableHeader\", () => $312ae3b56a94a86e$export$f850895b287ef28e);\nfunction $312ae3b56a94a86e$var$TableHeader(props) {\n  return null;\n}\n$312ae3b56a94a86e$var$TableHeader.getCollectionNode = function* getCollectionNode(props) {\n  let {\n    children: children,\n    columns: columns\n  } = props;\n  if (typeof children === 'function') {\n    if (!columns) throw new Error('props.children was a function but props.columns is missing');\n    for (let column of columns) yield {\n      type: 'column',\n      value: column,\n      renderer: children\n    };\n  } else {\n    let columns = [];\n    $1BfjW$react.Children.forEach(children, column => {\n      columns.push({\n        type: 'column',\n        element: column\n      });\n    });\n    yield* columns;\n  }\n};\n/**\n * A TableHeader is a container for the Column elements in a Table. Columns can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `columns` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $312ae3b56a94a86e$export$f850895b287ef28e = $312ae3b56a94a86e$var$TableHeader;\nvar $4ae5314bf50db1a3$exports = {};\n$parcel$export($4ae5314bf50db1a3$exports, \"TableBody\", () => $4ae5314bf50db1a3$export$76ccd210b9029917);\nfunction $4ae5314bf50db1a3$var$TableBody(props) {\n  return null;\n}\n$4ae5314bf50db1a3$var$TableBody.getCollectionNode = function* getCollectionNode(props) {\n  let {\n    children: children,\n    items: items1\n  } = props;\n  yield {\n    type: 'body',\n    hasChildNodes: true,\n    props: props,\n    *childNodes() {\n      if (typeof children === 'function') {\n        if (!items1) throw new Error('props.children was a function but props.items is missing');\n        for (let item of items1) yield {\n          type: 'item',\n          value: item,\n          renderer: children\n        };\n      } else {\n        let items = [];\n        $1BfjW$react.Children.forEach(children, item => {\n          items.push({\n            type: 'item',\n            element: item\n          });\n        });\n        yield* items;\n      }\n    }\n  };\n};\n/**\n * A TableBody is a container for the Row elements of a Table. Rows can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `items` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $4ae5314bf50db1a3$export$76ccd210b9029917 = $4ae5314bf50db1a3$var$TableBody;\nvar $1cd244557c2f97d5$exports = {};\n$parcel$export($1cd244557c2f97d5$exports, \"Column\", () => $1cd244557c2f97d5$export$816b5d811295e6bc);\nfunction $1cd244557c2f97d5$var$Column(props) {\n  return null;\n}\n$1cd244557c2f97d5$var$Column.getCollectionNode = function* getCollectionNode(props, context1) {\n  let {\n    title: title,\n    children: children,\n    childColumns: childColumns1\n  } = props;\n  let rendered = title || children;\n  let textValue = props.textValue || (typeof rendered === 'string' ? rendered : '') || props['aria-label'];\n  let fullNodes = yield {\n    type: 'column',\n    hasChildNodes: !!childColumns1 || title && $1BfjW$react.Children.count(children) > 0,\n    rendered: rendered,\n    textValue: textValue,\n    props: props,\n    *childNodes() {\n      if (childColumns1) for (let child1 of childColumns1) yield {\n        type: 'column',\n        value: child1\n      };else if (title) {\n        let childColumns = [];\n        $1BfjW$react.Children.forEach(children, child => {\n          childColumns.push({\n            type: 'column',\n            element: child\n          });\n        });\n        yield* childColumns;\n      }\n    },\n    shouldInvalidate(newContext) {\n      // This is a bit of a hack, but it works.\n      // If this method is called, then there's a cached version of this node available.\n      // But, we need to keep the list of columns in the new context up to date.\n      updateContext(newContext);\n      return false;\n    }\n  };\n  let updateContext = context => {\n    // register leaf columns on the context so that <Row> can access them\n    for (let node of fullNodes) if (!node.hasChildNodes) context.columns.push(node);\n  };\n  updateContext(context1);\n};\n/**\n * A Column represents a field of each item within a Table. Columns may also contain nested\n * Column elements to represent column groups. Nested columns can be statically defined as\n * children, or dynamically generated using a function based on the `childColumns` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $1cd244557c2f97d5$export$816b5d811295e6bc = $1cd244557c2f97d5$var$Column;\nvar $70d70eb16ea48428$exports = {};\n$parcel$export($70d70eb16ea48428$exports, \"Row\", () => $70d70eb16ea48428$export$b59bdbef9ce70de2);\nfunction $70d70eb16ea48428$var$Row(props) {\n  return null;\n}\n$70d70eb16ea48428$var$Row.getCollectionNode = function* getCollectionNode(props, context) {\n  let {\n    children: children,\n    textValue: textValue\n  } = props;\n  yield {\n    type: 'item',\n    props: props,\n    textValue: textValue,\n    'aria-label': props['aria-label'],\n    hasChildNodes: true,\n    *childNodes() {\n      // Process cells first\n      if (context.showSelectionCheckboxes && context.selectionMode !== 'none') yield {\n        type: 'cell',\n        key: 'header',\n        props: {\n          isSelectionCell: true\n        }\n      };\n      if (typeof children === 'function') for (let column of context.columns) yield {\n        type: 'cell',\n        element: children(column.key),\n        key: column.key // this is combined with the row key by CollectionBuilder\n      };else {\n        let cells = [];\n        $1BfjW$react.Children.forEach(children, cell => {\n          cells.push({\n            type: 'cell',\n            element: cell\n          });\n        });\n        if (cells.length !== context.columns.length) throw new Error(`Cell count must match column count. Found ${cells.length} cells and ${context.columns.length} columns.`);\n        yield* cells;\n      }\n    },\n    shouldInvalidate(newContext) {\n      // Invalidate all rows if the columns changed.\n      return newContext.columns.length !== context.columns.length || newContext.columns.some((c, i) => c.key !== context.columns[i].key) || newContext.showSelectionCheckboxes !== context.showSelectionCheckboxes || newContext.selectionMode !== context.selectionMode;\n    }\n  };\n};\n/**\n * A Row represents a single item in a Table and contains Cell elements for each column.\n * Cells can be statically defined as children, or generated dynamically using a function\n * based on the columns defined in the TableHeader.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $70d70eb16ea48428$export$b59bdbef9ce70de2 = $70d70eb16ea48428$var$Row;\nvar $941d1d9a6a28982a$exports = {};\n$parcel$export($941d1d9a6a28982a$exports, \"Cell\", () => $941d1d9a6a28982a$export$f6f0c3fe4ec306ea);\nfunction $941d1d9a6a28982a$var$Cell(props) {\n  return null;\n}\n$941d1d9a6a28982a$var$Cell.getCollectionNode = function* getCollectionNode(props) {\n  let {\n    children: children\n  } = props;\n  let textValue = props.textValue || (typeof children === 'string' ? children : '') || props['aria-label'] || '';\n  yield {\n    type: 'cell',\n    props: props,\n    rendered: children,\n    textValue: textValue,\n    'aria-label': props['aria-label'],\n    hasChildNodes: false\n  };\n};\n/**\n * A Cell represents the value of a single Column within a Table Row.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $941d1d9a6a28982a$export$f6f0c3fe4ec306ea = $941d1d9a6a28982a$var$Cell;\nexport { $6555104ff085bef4$re_export$Section as Section, $4a0dd036d492cee4$export$907bcc6c48325fd6 as useTableState, $312ae3b56a94a86e$export$f850895b287ef28e as TableHeader, $4ae5314bf50db1a3$export$76ccd210b9029917 as TableBody, $1cd244557c2f97d5$export$816b5d811295e6bc as Column, $70d70eb16ea48428$export$b59bdbef9ce70de2 as Row, $941d1d9a6a28982a$export$f6f0c3fe4ec306ea as Cell };\n//# sourceMappingURL=module.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}