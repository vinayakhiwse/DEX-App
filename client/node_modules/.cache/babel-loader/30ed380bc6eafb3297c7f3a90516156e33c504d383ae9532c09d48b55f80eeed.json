{"ast":null,"code":"import E, { useRef as L } from \"react\";\nimport { forwardRefWithAs as U, render as N } from '../../utils/render.js';\nimport { useServerHandoffComplete as I } from '../../hooks/use-server-handoff-complete.js';\nimport { useSyncRefs as x } from '../../hooks/use-sync-refs.js';\nimport { Features as R, Hidden as g } from '../../internal/hidden.js';\nimport { focusElement as f, focusIn as M, Focus as p, FocusResult as w } from '../../utils/focus-management.js';\nimport { match as k } from '../../utils/match.js';\nimport { useEvent as A } from '../../hooks/use-event.js';\nimport { useTabDirection as G, Direction as H } from '../../hooks/use-tab-direction.js';\nimport { useIsMounted as C } from '../../hooks/use-is-mounted.js';\nimport { useOwnerDocument as K } from '../../hooks/use-owner.js';\nimport { useEventListener as W } from '../../hooks/use-event-listener.js';\nimport { microTask as O } from '../../utils/micro-task.js';\nimport { useWatch as F } from '../../hooks/use-watch.js';\nimport { useDisposables as V } from '../../hooks/use-disposables.js';\nimport { onDocumentReady as q } from '../../utils/document-ready.js';\nimport { useOnUnmount as D } from '../../hooks/use-on-unmount.js';\nfunction P(t) {\n  if (!t) return new Set();\n  if (typeof t == \"function\") return new Set(t());\n  let r = new Set();\n  for (let e of t.current) e.current instanceof HTMLElement && r.add(e.current);\n  return r;\n}\nlet J = \"div\";\nvar h = (n => (n[n.None = 1] = \"None\", n[n.InitialFocus = 2] = \"InitialFocus\", n[n.TabLock = 4] = \"TabLock\", n[n.FocusLock = 8] = \"FocusLock\", n[n.RestoreFocus = 16] = \"RestoreFocus\", n[n.All = 30] = \"All\", n))(h || {});\nfunction X(t, r) {\n  let e = L(null),\n    o = x(e, r),\n    {\n      initialFocus: u,\n      containers: i,\n      features: n = 30,\n      ...l\n    } = t;\n  I() || (n = 1);\n  let m = K(e);\n  Y({\n    ownerDocument: m\n  }, Boolean(n & 16));\n  let c = Z({\n    ownerDocument: m,\n    container: e,\n    initialFocus: u\n  }, Boolean(n & 2));\n  $({\n    ownerDocument: m,\n    container: e,\n    containers: i,\n    previousActiveElement: c\n  }, Boolean(n & 8));\n  let v = G(),\n    y = A(s => {\n      let T = e.current;\n      if (!T) return;\n      (B => B())(() => {\n        k(v.current, {\n          [H.Forwards]: () => {\n            M(T, p.First, {\n              skipElements: [s.relatedTarget]\n            });\n          },\n          [H.Backwards]: () => {\n            M(T, p.Last, {\n              skipElements: [s.relatedTarget]\n            });\n          }\n        });\n      });\n    }),\n    _ = V(),\n    b = L(!1),\n    j = {\n      ref: o,\n      onKeyDown(s) {\n        s.key == \"Tab\" && (b.current = !0, _.requestAnimationFrame(() => {\n          b.current = !1;\n        }));\n      },\n      onBlur(s) {\n        let T = P(i);\n        e.current instanceof HTMLElement && T.add(e.current);\n        let d = s.relatedTarget;\n        d instanceof HTMLElement && d.dataset.headlessuiFocusGuard !== \"true\" && (S(T, d) || (b.current ? M(e.current, k(v.current, {\n          [H.Forwards]: () => p.Next,\n          [H.Backwards]: () => p.Previous\n        }) | p.WrapAround, {\n          relativeTo: s.target\n        }) : s.target instanceof HTMLElement && f(s.target)));\n      }\n    };\n  return E.createElement(E.Fragment, null, Boolean(n & 4) && E.createElement(g, {\n    as: \"button\",\n    type: \"button\",\n    \"data-headlessui-focus-guard\": !0,\n    onFocus: y,\n    features: R.Focusable\n  }), N({\n    ourProps: j,\n    theirProps: l,\n    defaultTag: J,\n    name: \"FocusTrap\"\n  }), Boolean(n & 4) && E.createElement(g, {\n    as: \"button\",\n    type: \"button\",\n    \"data-headlessui-focus-guard\": !0,\n    onFocus: y,\n    features: R.Focusable\n  }));\n}\nlet z = U(X),\n  ge = Object.assign(z, {\n    features: h\n  }),\n  a = [];\nq(() => {\n  function t(r) {\n    r.target instanceof HTMLElement && r.target !== document.body && a[0] !== r.target && (a.unshift(r.target), a = a.filter(e => e != null && e.isConnected), a.splice(10));\n  }\n  window.addEventListener(\"click\", t, {\n    capture: !0\n  }), window.addEventListener(\"mousedown\", t, {\n    capture: !0\n  }), window.addEventListener(\"focus\", t, {\n    capture: !0\n  }), document.body.addEventListener(\"click\", t, {\n    capture: !0\n  }), document.body.addEventListener(\"mousedown\", t, {\n    capture: !0\n  }), document.body.addEventListener(\"focus\", t, {\n    capture: !0\n  });\n});\nfunction Q(t = !0) {\n  let r = L(a.slice());\n  return F(([e], [o]) => {\n    o === !0 && e === !1 && O(() => {\n      r.current.splice(0);\n    }), o === !1 && e === !0 && (r.current = a.slice());\n  }, [t, a, r]), A(() => {\n    var e;\n    return (e = r.current.find(o => o != null && o.isConnected)) != null ? e : null;\n  });\n}\nfunction Y({\n  ownerDocument: t\n}, r) {\n  let e = Q(r);\n  F(() => {\n    r || (t == null ? void 0 : t.activeElement) === (t == null ? void 0 : t.body) && f(e());\n  }, [r]), D(() => {\n    r && f(e());\n  });\n}\nfunction Z({\n  ownerDocument: t,\n  container: r,\n  initialFocus: e\n}, o) {\n  let u = L(null),\n    i = C();\n  return F(() => {\n    if (!o) return;\n    let n = r.current;\n    n && O(() => {\n      if (!i.current) return;\n      let l = t == null ? void 0 : t.activeElement;\n      if (e != null && e.current) {\n        if ((e == null ? void 0 : e.current) === l) {\n          u.current = l;\n          return;\n        }\n      } else if (n.contains(l)) {\n        u.current = l;\n        return;\n      }\n      e != null && e.current ? f(e.current) : M(n, p.First) === w.Error && console.warn(\"There are no focusable elements inside the <FocusTrap />\"), u.current = t == null ? void 0 : t.activeElement;\n    });\n  }, [o]), u;\n}\nfunction $({\n  ownerDocument: t,\n  container: r,\n  containers: e,\n  previousActiveElement: o\n}, u) {\n  let i = C();\n  W(t == null ? void 0 : t.defaultView, \"focus\", n => {\n    if (!u || !i.current) return;\n    let l = P(e);\n    r.current instanceof HTMLElement && l.add(r.current);\n    let m = o.current;\n    if (!m) return;\n    let c = n.target;\n    c && c instanceof HTMLElement ? S(l, c) ? (o.current = c, f(c)) : (n.preventDefault(), n.stopPropagation(), f(m)) : f(o.current);\n  }, !0);\n}\nfunction S(t, r) {\n  for (let e of t) if (e.contains(r)) return !0;\n  return !1;\n}\nexport { ge as FocusTrap };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}