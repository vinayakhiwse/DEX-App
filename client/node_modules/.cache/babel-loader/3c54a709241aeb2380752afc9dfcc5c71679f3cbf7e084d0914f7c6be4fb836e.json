{"ast":null,"code":"import { Connector, __privateAdd, __privateGet, __privateMethod, __privateSet } from \"./chunk-W65LBPLT.js\";\n\n// src/walletConnect.ts\nimport { normalizeNamespaces } from \"@walletconnect/utils\";\nimport { SwitchChainError, UserRejectedRequestError, createWalletClient, custom, getAddress, numberToHex } from \"viem\";\nvar NAMESPACE = \"eip155\";\nvar STORE_KEY = \"store\";\nvar REQUESTED_CHAINS_KEY = \"requestedChains\";\nvar ADD_ETH_CHAIN_METHOD = \"wallet_addEthereumChain\";\nvar _provider, _initProviderPromise, _createProvider, createProvider_fn, _initProvider, initProvider_fn, _isChainsStale, isChainsStale_fn, _setupListeners, setupListeners_fn, _removeListeners, removeListeners_fn, _setRequestedChainsIds, setRequestedChainsIds_fn, _getRequestedChainsIds, getRequestedChainsIds_fn, _getNamespaceChainsIds, getNamespaceChainsIds_fn, _getNamespaceMethods, getNamespaceMethods_fn;\nvar WalletConnectConnector = class extends Connector {\n  constructor(config) {\n    super({\n      ...config,\n      options: {\n        isNewChainsStale: true,\n        ...config.options\n      }\n    });\n    __privateAdd(this, _createProvider);\n    __privateAdd(this, _initProvider);\n    __privateAdd(this, _isChainsStale);\n    __privateAdd(this, _setupListeners);\n    __privateAdd(this, _removeListeners);\n    __privateAdd(this, _setRequestedChainsIds);\n    __privateAdd(this, _getRequestedChainsIds);\n    __privateAdd(this, _getNamespaceChainsIds);\n    __privateAdd(this, _getNamespaceMethods);\n    this.id = \"walletConnect\";\n    this.name = \"WalletConnect\";\n    this.ready = true;\n    __privateAdd(this, _provider, void 0);\n    __privateAdd(this, _initProviderPromise, void 0);\n    this.onAccountsChanged = accounts => {\n      if (accounts.length === 0) this.emit(\"disconnect\");else this.emit(\"change\", {\n        account: getAddress(accounts[0])\n      });\n    };\n    this.onChainChanged = chainId => {\n      const id = Number(chainId);\n      const unsupported = this.isChainUnsupported(id);\n      this.emit(\"change\", {\n        chain: {\n          id,\n          unsupported\n        }\n      });\n    };\n    this.onDisconnect = () => {\n      __privateMethod(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, []);\n      this.emit(\"disconnect\");\n    };\n    this.onDisplayUri = uri => {\n      this.emit(\"message\", {\n        type: \"display_uri\",\n        data: uri\n      });\n    };\n    this.onConnect = () => {\n      this.emit(\"connect\", {});\n    };\n    __privateMethod(this, _createProvider, createProvider_fn).call(this);\n  }\n  async connect({\n    chainId,\n    pairingTopic\n  } = {}) {\n    try {\n      let targetChainId = chainId;\n      if (!targetChainId) {\n        const store = this.storage?.getItem(STORE_KEY);\n        const lastUsedChainId = store?.state?.data?.chain?.id;\n        if (lastUsedChainId && !this.isChainUnsupported(lastUsedChainId)) targetChainId = lastUsedChainId;else targetChainId = this.chains[0]?.id;\n      }\n      if (!targetChainId) throw new Error(\"No chains found on connector.\");\n      const provider = await this.getProvider();\n      __privateMethod(this, _setupListeners, setupListeners_fn).call(this);\n      const isChainsStale = __privateMethod(this, _isChainsStale, isChainsStale_fn).call(this);\n      if (provider.session && isChainsStale) await provider.disconnect();\n      if (!provider.session || isChainsStale) {\n        const optionalChains = this.chains.filter(chain => chain.id !== targetChainId).map(optionalChain => optionalChain.id);\n        this.emit(\"message\", {\n          type: \"connecting\"\n        });\n        await provider.connect({\n          pairingTopic,\n          chains: [targetChainId],\n          optionalChains: optionalChains.length ? optionalChains : void 0\n        });\n        __privateMethod(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, this.chains.map(({\n          id: id2\n        }) => id2));\n      }\n      const accounts = await provider.enable();\n      const account = getAddress(accounts[0]);\n      const id = await this.getChainId();\n      const unsupported = this.isChainUnsupported(id);\n      return {\n        account,\n        chain: {\n          id,\n          unsupported\n        }\n      };\n    } catch (error) {\n      if (/user rejected/i.test(error?.message)) {\n        throw new UserRejectedRequestError(error);\n      }\n      throw error;\n    }\n  }\n  async disconnect() {\n    const provider = await this.getProvider();\n    try {\n      await provider.disconnect();\n    } catch (error) {\n      if (!/No matching key/i.test(error.message)) throw error;\n    } finally {\n      __privateMethod(this, _removeListeners, removeListeners_fn).call(this);\n      __privateMethod(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, []);\n    }\n  }\n  async getAccount() {\n    const {\n      accounts\n    } = await this.getProvider();\n    return getAddress(accounts[0]);\n  }\n  async getChainId() {\n    const {\n      chainId\n    } = await this.getProvider();\n    return chainId;\n  }\n  async getProvider({\n    chainId\n  } = {}) {\n    if (!__privateGet(this, _provider)) await __privateMethod(this, _createProvider, createProvider_fn).call(this);\n    if (chainId) await this.switchChain(chainId);\n    return __privateGet(this, _provider);\n  }\n  async getWalletClient({\n    chainId\n  } = {}) {\n    const [provider, account] = await Promise.all([this.getProvider({\n      chainId\n    }), this.getAccount()]);\n    const chain = this.chains.find(x => x.id === chainId);\n    if (!provider) throw new Error(\"provider is required.\");\n    return createWalletClient({\n      account,\n      chain,\n      transport: custom(provider)\n    });\n  }\n  async isAuthorized() {\n    try {\n      const [account, provider] = await Promise.all([this.getAccount(), this.getProvider()]);\n      const isChainsStale = __privateMethod(this, _isChainsStale, isChainsStale_fn).call(this);\n      if (!account) return false;\n      if (isChainsStale && provider.session) {\n        try {\n          await provider.disconnect();\n        } catch {}\n        return false;\n      }\n      return true;\n    } catch {\n      return false;\n    }\n  }\n  async switchChain(chainId) {\n    const chain = this.chains.find(chain2 => chain2.id === chainId);\n    if (!chain) throw new SwitchChainError(new Error(\"chain not found on connector.\"));\n    try {\n      const provider = await this.getProvider();\n      const namespaceChains = __privateMethod(this, _getNamespaceChainsIds, getNamespaceChainsIds_fn).call(this);\n      const namespaceMethods = __privateMethod(this, _getNamespaceMethods, getNamespaceMethods_fn).call(this);\n      const isChainApproved = namespaceChains.includes(chainId);\n      if (!isChainApproved && namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {\n        await provider.request({\n          method: ADD_ETH_CHAIN_METHOD,\n          params: [{\n            chainId: numberToHex(chain.id),\n            blockExplorerUrls: [chain.blockExplorers?.default?.url],\n            chainName: chain.name,\n            nativeCurrency: chain.nativeCurrency,\n            rpcUrls: [...chain.rpcUrls.default.http]\n          }]\n        });\n        const requestedChains = __privateMethod(this, _getRequestedChainsIds, getRequestedChainsIds_fn).call(this);\n        requestedChains.push(chainId);\n        __privateMethod(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, requestedChains);\n      }\n      await provider.request({\n        method: \"wallet_switchEthereumChain\",\n        params: [{\n          chainId: numberToHex(chainId)\n        }]\n      });\n      return chain;\n    } catch (error) {\n      const message = typeof error === \"string\" ? error : error?.message;\n      if (/user rejected request/i.test(message)) {\n        throw new UserRejectedRequestError(error);\n      }\n      throw new SwitchChainError(error);\n    }\n  }\n};\n_provider = new WeakMap();\n_initProviderPromise = new WeakMap();\n_createProvider = new WeakSet();\ncreateProvider_fn = async function () {\n  if (!__privateGet(this, _initProviderPromise) && typeof window !== \"undefined\") {\n    __privateSet(this, _initProviderPromise, __privateMethod(this, _initProvider, initProvider_fn).call(this));\n  }\n  return __privateGet(this, _initProviderPromise);\n};\n_initProvider = new WeakSet();\ninitProvider_fn = async function () {\n  const {\n    EthereumProvider,\n    OPTIONAL_EVENTS,\n    OPTIONAL_METHODS\n  } = await import(\"@walletconnect/ethereum-provider\");\n  const [defaultChain, ...optionalChains] = this.chains.map(({\n    id\n  }) => id);\n  if (defaultChain) {\n    const {\n      projectId,\n      showQrModal = true,\n      qrModalOptions,\n      metadata,\n      relayUrl\n    } = this.options;\n    __privateSet(this, _provider, await EthereumProvider.init({\n      showQrModal,\n      qrModalOptions,\n      projectId,\n      optionalMethods: OPTIONAL_METHODS,\n      optionalEvents: OPTIONAL_EVENTS,\n      chains: [defaultChain],\n      optionalChains: optionalChains.length ? optionalChains : void 0,\n      rpcMap: Object.fromEntries(this.chains.map(chain => [chain.id, chain.rpcUrls.default.http[0]])),\n      metadata,\n      relayUrl\n    }));\n  }\n};\n_isChainsStale = new WeakSet();\nisChainsStale_fn = function () {\n  const namespaceMethods = __privateMethod(this, _getNamespaceMethods, getNamespaceMethods_fn).call(this);\n  if (namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) return false;\n  if (!this.options.isNewChainsStale) return false;\n  const requestedChains = __privateMethod(this, _getRequestedChainsIds, getRequestedChainsIds_fn).call(this);\n  const connectorChains = this.chains.map(({\n    id\n  }) => id);\n  const namespaceChains = __privateMethod(this, _getNamespaceChainsIds, getNamespaceChainsIds_fn).call(this);\n  if (namespaceChains.length && !namespaceChains.some(id => connectorChains.includes(id))) return false;\n  return !connectorChains.every(id => requestedChains.includes(id));\n};\n_setupListeners = new WeakSet();\nsetupListeners_fn = function () {\n  if (!__privateGet(this, _provider)) return;\n  __privateMethod(this, _removeListeners, removeListeners_fn).call(this);\n  __privateGet(this, _provider).on(\"accountsChanged\", this.onAccountsChanged);\n  __privateGet(this, _provider).on(\"chainChanged\", this.onChainChanged);\n  __privateGet(this, _provider).on(\"disconnect\", this.onDisconnect);\n  __privateGet(this, _provider).on(\"session_delete\", this.onDisconnect);\n  __privateGet(this, _provider).on(\"display_uri\", this.onDisplayUri);\n  __privateGet(this, _provider).on(\"connect\", this.onConnect);\n};\n_removeListeners = new WeakSet();\nremoveListeners_fn = function () {\n  if (!__privateGet(this, _provider)) return;\n  __privateGet(this, _provider).removeListener(\"accountsChanged\", this.onAccountsChanged);\n  __privateGet(this, _provider).removeListener(\"chainChanged\", this.onChainChanged);\n  __privateGet(this, _provider).removeListener(\"disconnect\", this.onDisconnect);\n  __privateGet(this, _provider).removeListener(\"session_delete\", this.onDisconnect);\n  __privateGet(this, _provider).removeListener(\"display_uri\", this.onDisplayUri);\n  __privateGet(this, _provider).removeListener(\"connect\", this.onConnect);\n};\n_setRequestedChainsIds = new WeakSet();\nsetRequestedChainsIds_fn = function (chains) {\n  this.storage?.setItem(REQUESTED_CHAINS_KEY, chains);\n};\n_getRequestedChainsIds = new WeakSet();\ngetRequestedChainsIds_fn = function () {\n  return this.storage?.getItem(REQUESTED_CHAINS_KEY) ?? [];\n};\n_getNamespaceChainsIds = new WeakSet();\ngetNamespaceChainsIds_fn = function () {\n  if (!__privateGet(this, _provider)) return [];\n  const namespaces = __privateGet(this, _provider).session?.namespaces;\n  if (!namespaces) return [];\n  const normalizedNamespaces = normalizeNamespaces(namespaces);\n  const chainIds = normalizedNamespaces[NAMESPACE]?.chains?.map(chain => parseInt(chain.split(\":\")[1] || \"\"));\n  return chainIds ?? [];\n};\n_getNamespaceMethods = new WeakSet();\ngetNamespaceMethods_fn = function () {\n  if (!__privateGet(this, _provider)) return [];\n  const namespaces = __privateGet(this, _provider).session?.namespaces;\n  if (!namespaces) return [];\n  const normalizedNamespaces = normalizeNamespaces(namespaces);\n  const methods = normalizedNamespaces[NAMESPACE]?.methods;\n  return methods ?? [];\n};\nexport { WalletConnectConnector };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}