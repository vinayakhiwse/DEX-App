{"ast":null,"code":"import e, { useEffect as t, useImperativeHandle as a, useMemo as r, useRef as l, useState as n } from \"react\";\nimport { useLabel as i } from \"@react-aria/label\";\nimport { defaultProps as o } from \"./input-props\";\nimport d from \"../use-theme\";\nimport s from \"../use-warning\";\nimport { StyledInput as c, StyledInputMainContainer as u, StyledInputContainer as p, StyledHelperTextContainer as m, StyledHelperText as h, StyledInputWrapper as f, StyledInputPlaceholder as b, StyledInputClearButton as $, StyledInputBlockLabel as g, StyledInputLabel as y, StyledInputContent as C } from \"./input.styles\";\nimport x from \"../utils/clear-icon\";\nimport w from \"../utils/clsx\";\nimport { __DEV__ as N } from \"../utils/assertion\";\nimport { jsx as v } from \"react/jsx-runtime\";\nimport { jsxs as k } from \"react/jsx-runtime\";\nconst S = \"nextui-input\",\n  R = e.forwardRef(({\n    as: e = \"input\",\n    label: o,\n    labelPlaceholder: R,\n    labelLeft: I,\n    labelRight: L,\n    size: P,\n    helperText: D,\n    color: T,\n    helperColor: B,\n    status: j,\n    contentLeft: F,\n    contentRight: O,\n    contentClickable: V,\n    contentLeftStyling: q,\n    contentRightStyling: U,\n    onContentClick: W,\n    initialValue: z,\n    onChange: E,\n    readOnly: A,\n    value: G,\n    onClearClick: H,\n    clearable: J,\n    shadow: K,\n    animated: M,\n    required: Q,\n    width: X,\n    className: Y,\n    onBlur: Z,\n    onFocus: _,\n    autoComplete: ee,\n    placeholder: te,\n    fullWidth: ae,\n    borderWeight: re,\n    disabled: le,\n    bordered: ne,\n    underlined: ie,\n    rounded: oe,\n    css: de,\n    ...se\n  }, ce) => {\n    const ue = l(null);\n    a(ce, () => ue.current);\n    const [pe, me] = n(z),\n      [he, fe] = n(!1),\n      {\n        isDark: be\n      } = d(),\n      $e = r(() => void 0 !== G, [G]),\n      ge = r(() => o || R, [o, R]),\n      ye = r(() => R ? \"\" : te, [te, R]),\n      Ce = r(() => ae ? \"100%\" : X || \"initial\", [ae, X]);\n    ie && N && (ne && s(\"Using underlined and bordered at the same time will have no effect.\"), oe && s(\"Using underlined and rounded at the same time will have no effect.\"));\n    const xe = (e, t) => {\n      le || W && W(e, t);\n    };\n    t(() => {\n      $e && me(G);\n    });\n    const we = r(() => \"textarea\" === e, [e]),\n      Ne = {\n        ...se,\n        ...($e ? {\n          value: pe\n        } : {\n          defaultValue: z\n        })\n      },\n      {\n        labelProps: ve,\n        fieldProps: ke\n      } = i({\n        ...Ne,\n        label: ge\n      }),\n      Se = r(() => he ? \"hover\" : le ? \"disabled\" : A ? \"read-only\" : pe ? \"with-value\" : \"normal\", [he, le, A, pe]);\n    return k(u, {\n      color: T,\n      \"data-state\": Se,\n      helperColor: B,\n      borderWeight: re,\n      status: j,\n      size: P,\n      rounded: oe,\n      disabled: le,\n      css: {\n        width: Ce,\n        ...de\n      },\n      className: w(`${S}-main-container`, `${S}-main-container--${Se}`),\n      children: [ge && v(g, {\n        id: ve.id,\n        className: `${S}-block-label`,\n        htmlFor: ve.htmlFor,\n        isTextarea: we,\n        underlined: ie,\n        animated: M,\n        bordered: ne,\n        rounded: oe,\n        hasContentLeft: !!F,\n        withValue: !!pe,\n        asPlaceholder: !!R,\n        focused: he,\n        children: ge\n      }), v(p, {\n        animated: M,\n        isTextarea: we,\n        underlined: ie,\n        isReadOnly: A,\n        focused: he,\n        className: w(`${S}-container`, `${S}-container--${Se}`, {\n          [`${S}-container--input`]: !we,\n          [`${S}-container--textarea`]: we,\n          [`${S}-container--read-only`]: A\n        }, Y),\n        children: k(f, {\n          as: ge ? \"div\" : \"label\",\n          animated: M,\n          bordered: ne,\n          shadow: K,\n          disabled: le,\n          focused: he,\n          isReadOnly: A,\n          underlined: ie,\n          isTextarea: we,\n          className: w(`${S}-wrapper`, `${S}-wrapper--${Se}`, {\n            [`${S}-wrapper--bordered`]: ne,\n            [`${S}-wrapper--underlined`]: ie,\n            [`${S}-wrapper--shadow`]: K\n          }),\n          children: [!ge && te && v(b, {\n            className: `${S}-placeholder`,\n            children: te\n          }), I && v(y, {\n            className: `${S}-label--left`,\n            isDefaultStatus: \"default\" === j,\n            underlined: ie,\n            bordered: ne,\n            isDark: be,\n            children: I\n          }), F && v(C, {\n            className: w(`${S}-content`, `${S}-content--left`),\n            applyStyles: q,\n            clickable: V,\n            onClick: e => xe(\"left\", e),\n            children: F\n          }), v(c, {\n            type: \"text\",\n            as: e,\n            ref: ue,\n            className: w({\n              [`${S}`]: !we,\n              [`${S}-textarea`]: we,\n              [`${S}-disabled`]: le,\n              [`${S}-rounded`]: oe,\n              [`${S}-${S}-right-content`]: O,\n              [`${S}-left-content`]: F\n            }),\n            isTextarea: we,\n            focused: he,\n            bordered: ne,\n            placeholder: ye,\n            disabled: le,\n            readOnly: A,\n            required: Q,\n            onFocus: e => {\n              fe(!0), _ && _(e);\n            },\n            onBlur: e => {\n              fe(!1), Z && Z(e);\n            },\n            onChange: e => {\n              le || A || (me(e.target.value), E && E(e));\n            },\n            autoComplete: ee,\n            hasLeftContent: !!F,\n            hasRightContent: !!O,\n            \"data-state\": Se,\n            \"aria-placeholder\": ye,\n            \"aria-readonly\": A,\n            \"aria-required\": Q,\n            \"aria-multiline\": we,\n            ...Ne,\n            ...ke\n          }), J && v($, {\n            type: \"button\",\n            className: `${S}-clear-button`,\n            animated: M,\n            underlined: ie,\n            visible: Boolean(pe),\n            hasContentRight: !!O,\n            disabled: le || A,\n            onClick: e => {\n              if (e.preventDefault(), e.stopPropagation(), e.nativeEvent.stopImmediatePropagation(), me(\"\"), H && H(e), !ue.current) return;\n              const t = ((e, t) => ({\n                ...t,\n                target: e,\n                currentTarget: e\n              }))(ue.current, e);\n              t.target.value = \"\", E && E(t), ue.current.focus();\n            },\n            children: v(x, {\n              fill: \"currentColor\"\n            })\n          }), O && v(C, {\n            className: w(`${S}-content`, `${S}-content--right`),\n            applyStyles: U,\n            clickable: V,\n            onClick: e => xe(\"right\", e),\n            children: O\n          }), L && v(y, {\n            className: `${S}-label--right`,\n            isDefaultStatus: \"default\" === j,\n            underlined: ie,\n            bordered: ne,\n            isRight: !0,\n            isDark: be,\n            children: L\n          })]\n        })\n      }), v(m, {\n        className: `${S}-helper-text-container`,\n        withValue: !!D,\n        children: D && v(h, {\n          className: `${S}-helper-text`,\n          children: D\n        })\n      })]\n    });\n  });\nR.displayName = \"NextUI.Input\", R.defaultProps = o, R.toString = () => \".nextui-input\";\nexport default R;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}