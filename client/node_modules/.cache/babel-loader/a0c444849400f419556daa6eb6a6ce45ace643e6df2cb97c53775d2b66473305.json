{"ast":null,"code":"import { isHex } from '../../utils/data/isHex.js';\nimport { getEventSelector } from '../../utils/hash/getEventSelector.js';\nimport { getFunctionSelector } from '../../utils/hash/getFunctionSelector.js';\nimport { isAddress } from '../address/isAddress.js';\nexport function getAbiItem({\n  abi,\n  args = [],\n  name\n}) {\n  const isSelector = isHex(name, {\n    strict: false\n  });\n  const abiItems = abi.filter(abiItem => {\n    if (isSelector) {\n      if (abiItem.type === 'function') return getFunctionSelector(abiItem) === name;\n      if (abiItem.type === 'event') return getEventSelector(abiItem) === name;\n      return false;\n    }\n    return 'name' in abiItem && abiItem.name === name;\n  });\n  if (abiItems.length === 0) return undefined;\n  if (abiItems.length === 1) return abiItems[0];\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue;\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0) return abiItem;\n      continue;\n    }\n    if (!abiItem.inputs) continue;\n    if (abiItem.inputs.length === 0) continue;\n    if (abiItem.inputs.length !== args.length) continue;\n    const matched = args.every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];\n      if (!abiParameter) return false;\n      return isArgOfType(arg, abiParameter);\n    });\n    if (matched) return abiItem;\n  }\n  return abiItems[0];\n}\nexport function isArgOfType(arg, abiParameter) {\n  const argType = typeof arg;\n  const abiParameterType = abiParameter.type;\n  switch (abiParameterType) {\n    case 'address':\n      return isAddress(arg);\n    case 'bool':\n      return argType === 'boolean';\n    case 'function':\n      return argType === 'string';\n    case 'string':\n      return argType === 'string';\n    default:\n      {\n        if (abiParameterType === 'tuple' && 'components' in abiParameter) return Object.values(abiParameter.components).every((component, index) => {\n          return isArgOfType(Object.values(arg)[index], component);\n        });\n        // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n        // https://regexr.com/6v8hp\n        if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType)) return argType === 'number' || argType === 'bigint';\n        // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n        // https://regexr.com/6va55\n        if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType)) return argType === 'string' || arg instanceof Uint8Array;\n        // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n        // https://regexr.com/6va6i\n        if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n          return Array.isArray(arg) && arg.every(x => isArgOfType(x, {\n            ...abiParameter,\n            // Pop off `[]` or `[M]` from end of type\n            type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, '')\n          }));\n        }\n        return false;\n      }\n  }\n}\n//# sourceMappingURL=getAbiItem.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}