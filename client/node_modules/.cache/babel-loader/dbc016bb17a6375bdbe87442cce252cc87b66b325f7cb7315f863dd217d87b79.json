{"ast":null,"code":"import { getNthItem as $cVkRF$getNthItem, getChildNodes as $cVkRF$getChildNodes, getLastItem as $cVkRF$getLastItem, getFirstItem as $cVkRF$getFirstItem } from \"@react-stately/collections\";\nimport { Rect as $cVkRF$Rect } from \"@react-stately/virtualizer\";\nimport { useId as $cVkRF$useId, filterDOMProps as $cVkRF$filterDOMProps, mergeProps as $cVkRF$mergeProps, useUpdateEffect as $cVkRF$useUpdateEffect, useDescription as $cVkRF$useDescription, scrollIntoViewport as $cVkRF$scrollIntoViewport, getScrollParent as $cVkRF$getScrollParent } from \"@react-aria/utils\";\nimport { useMemo as $cVkRF$useMemo, useCallback as $cVkRF$useCallback, useRef as $cVkRF$useRef } from \"react\";\nimport { useCollator as $cVkRF$useCollator, useLocale as $cVkRF$useLocale, useLocalizedStringFormatter as $cVkRF$useLocalizedStringFormatter } from \"@react-aria/i18n\";\nimport { useHasTabbableChild as $cVkRF$useHasTabbableChild, getFocusableTreeWalker as $cVkRF$getFocusableTreeWalker, focusSafely as $cVkRF$focusSafely } from \"@react-aria/focus\";\nimport { useSelectableCollection as $cVkRF$useSelectableCollection, useSelectableItem as $cVkRF$useSelectableItem } from \"@react-aria/selection\";\nimport { announce as $cVkRF$announce } from \"@react-aria/live-announcer\";\nimport { useInteractionModality as $cVkRF$useInteractionModality, isFocusVisible as $cVkRF$isFocusVisible } from \"@react-aria/interactions\";\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n    * Copyright 2020 Adobe. All rights reserved.\n    * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License. You may obtain a copy\n    * of the License at http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software distributed under\n    * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n    * OF ANY KIND, either express or implied. See the License for the specific language\n    * governing permissions and limitations under the License.\n    */\n\nclass $d1c300d9c497e402$export$de9feff04fda126e {\n  isCell(node) {\n    return node.type === \"cell\";\n  }\n  isRow(node) {\n    return node.type === \"row\" || node.type === \"item\";\n  }\n  findPreviousKey(fromKey, pred) {\n    let key = fromKey != null ? this.collection.getKeyBefore(fromKey) : this.collection.getLastKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (!this.disabledKeys.has(key) && (!pred || pred(item))) return key;\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n  findNextKey(fromKey, pred) {\n    let key = fromKey != null ? this.collection.getKeyAfter(fromKey) : this.collection.getFirstKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (!this.disabledKeys.has(key) && (!pred || pred(item))) return key;\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n  getKeyBelow(key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) return;\n    // If focus was on a cell, start searching from the parent row\n    if (this.isCell(startItem)) key = startItem.parentKey;\n    // Find the next item\n    key = this.findNextKey(key);\n    if (key != null) {\n      // If focus was on a cell, focus the cell with the same index in the next row.\n      if (this.isCell(startItem)) {\n        let item = this.collection.getItem(key);\n        return (0, $cVkRF$getNthItem)((0, $cVkRF$getChildNodes)(item, this.collection), startItem.index).key;\n      }\n      // Otherwise, focus the next row\n      if (this.focusMode === \"row\") return key;\n    }\n  }\n  getKeyAbove(key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) return;\n    // If focus is on a cell, start searching from the parent row\n    if (this.isCell(startItem)) key = startItem.parentKey;\n    // Find the previous item\n    key = this.findPreviousKey(key);\n    if (key != null) {\n      // If focus was on a cell, focus the cell with the same index in the previous row.\n      if (this.isCell(startItem)) {\n        let item = this.collection.getItem(key);\n        return (0, $cVkRF$getNthItem)((0, $cVkRF$getChildNodes)(item, this.collection), startItem.index).key;\n      }\n      // Otherwise, focus the previous row\n      if (this.focusMode === \"row\") return key;\n    }\n  }\n  getKeyRightOf(key) {\n    let item = this.collection.getItem(key);\n    if (!item) return;\n    // If focus is on a row, focus the first child cell.\n    if (this.isRow(item)) {\n      let children = (0, $cVkRF$getChildNodes)(item, this.collection);\n      return this.direction === \"rtl\" ? (0, $cVkRF$getLastItem)(children).key : (0, $cVkRF$getFirstItem)(children).key;\n    }\n    // If focus is on a cell, focus the next cell if any,\n    // otherwise focus the parent row.\n    if (this.isCell(item)) {\n      let parent = this.collection.getItem(item.parentKey);\n      let children = (0, $cVkRF$getChildNodes)(parent, this.collection);\n      let next = this.direction === \"rtl\" ? (0, $cVkRF$getNthItem)(children, item.index - 1) : (0, $cVkRF$getNthItem)(children, item.index + 1);\n      if (next) return next.key;\n      // focus row only if focusMode is set to row\n      if (this.focusMode === \"row\") return item.parentKey;\n      return this.direction === \"rtl\" ? this.getFirstKey(key) : this.getLastKey(key);\n    }\n  }\n  getKeyLeftOf(key) {\n    let item = this.collection.getItem(key);\n    if (!item) return;\n    // If focus is on a row, focus the last child cell.\n    if (this.isRow(item)) {\n      let children = (0, $cVkRF$getChildNodes)(item, this.collection);\n      return this.direction === \"rtl\" ? (0, $cVkRF$getFirstItem)(children).key : (0, $cVkRF$getLastItem)(children).key;\n    }\n    // If focus is on a cell, focus the previous cell if any,\n    // otherwise focus the parent row.\n    if (this.isCell(item)) {\n      let parent = this.collection.getItem(item.parentKey);\n      let children = (0, $cVkRF$getChildNodes)(parent, this.collection);\n      let prev = this.direction === \"rtl\" ? (0, $cVkRF$getNthItem)(children, item.index + 1) : (0, $cVkRF$getNthItem)(children, item.index - 1);\n      if (prev) return prev.key;\n      // focus row only if focusMode is set to row\n      if (this.focusMode === \"row\") return item.parentKey;\n      return this.direction === \"rtl\" ? this.getLastKey(key) : this.getFirstKey(key);\n    }\n  }\n  getFirstKey(key, global) {\n    let item;\n    if (key != null) {\n      item = this.collection.getItem(key);\n      if (!item) return;\n      // If global flag is not set, and a cell is currently focused,\n      // move focus to the first cell in the parent row.\n      if (this.isCell(item) && !global) {\n        let parent = this.collection.getItem(item.parentKey);\n        return (0, $cVkRF$getFirstItem)((0, $cVkRF$getChildNodes)(parent, this.collection)).key;\n      }\n    }\n    // Find the first row\n    key = this.findNextKey();\n    // If global flag is set (or if focus mode is cell), focus the first cell in the first row.\n    if (key != null && item && this.isCell(item) && global || this.focusMode === \"cell\") {\n      let item = this.collection.getItem(key);\n      key = (0, $cVkRF$getFirstItem)((0, $cVkRF$getChildNodes)(item, this.collection)).key;\n    }\n    // Otherwise, focus the row itself.\n    return key;\n  }\n  getLastKey(key, global) {\n    let item;\n    if (key != null) {\n      item = this.collection.getItem(key);\n      if (!item) return;\n      // If global flag is not set, and a cell is currently focused,\n      // move focus to the last cell in the parent row.\n      if (this.isCell(item) && !global) {\n        let parent = this.collection.getItem(item.parentKey);\n        let children = (0, $cVkRF$getChildNodes)(parent, this.collection);\n        return (0, $cVkRF$getLastItem)(children).key;\n      }\n    }\n    // Find the last row\n    key = this.findPreviousKey();\n    // If global flag is set (or if focus mode is cell), focus the last cell in the last row.\n    if (key != null && item && this.isCell(item) && global || this.focusMode === \"cell\") {\n      let item = this.collection.getItem(key);\n      let children = (0, $cVkRF$getChildNodes)(item, this.collection);\n      key = (0, $cVkRF$getLastItem)(children).key;\n    }\n    // Otherwise, focus the row itself.\n    return key;\n  }\n  getItem(key) {\n    return this.ref.current.querySelector(`[data-key=\"${key}\"]`);\n  }\n  getItemRect(key) {\n    var _this_layout_getLayoutInfo;\n    if (this.layout) return (_this_layout_getLayoutInfo = this.layout.getLayoutInfo(key)) === null || _this_layout_getLayoutInfo === void 0 ? void 0 : _this_layout_getLayoutInfo.rect;\n    let item = this.getItem(key);\n    if (item) return new (0, $cVkRF$Rect)(item.offsetLeft, item.offsetTop, item.offsetWidth, item.offsetHeight);\n  }\n  getPageHeight() {\n    var _this_layout_virtualizer, _this_ref, _this_ref_current;\n    if (this.layout) return (_this_layout_virtualizer = this.layout.virtualizer) === null || _this_layout_virtualizer === void 0 ? void 0 : _this_layout_virtualizer.visibleRect.height;\n    return (_this_ref = this.ref) === null || _this_ref === void 0 ? void 0 : (_this_ref_current = _this_ref.current) === null || _this_ref_current === void 0 ? void 0 : _this_ref_current.offsetHeight;\n  }\n  getContentHeight() {\n    var _this_ref, _this_ref_current;\n    if (this.layout) return this.layout.getContentSize().height;\n    return (_this_ref = this.ref) === null || _this_ref === void 0 ? void 0 : (_this_ref_current = _this_ref.current) === null || _this_ref_current === void 0 ? void 0 : _this_ref_current.scrollHeight;\n  }\n  getKeyPageAbove(key) {\n    let itemRect = this.getItemRect(key);\n    if (!itemRect) return null;\n    let pageY = Math.max(0, itemRect.maxY - this.getPageHeight());\n    while (itemRect && itemRect.y > pageY) {\n      key = this.getKeyAbove(key);\n      itemRect = this.getItemRect(key);\n    }\n    return key;\n  }\n  getKeyPageBelow(key) {\n    let itemRect = this.getItemRect(key);\n    if (!itemRect) return null;\n    let pageHeight = this.getPageHeight();\n    let pageY = Math.min(this.getContentHeight(), itemRect.y + pageHeight);\n    while (itemRect && itemRect.maxY < pageY) {\n      let nextKey = this.getKeyBelow(key);\n      itemRect = this.getItemRect(nextKey);\n      // Guard against case where maxY of the last key is barely less than pageY due to rounding\n      // and thus it attempts to set key to null\n      if (nextKey != null) key = nextKey;\n    }\n    return key;\n  }\n  getKeyForSearch(search, fromKey) {\n    if (!this.collator) return null;\n    let collection = this.collection;\n    let key = fromKey !== null && fromKey !== void 0 ? fromKey : this.getFirstKey();\n    // If the starting key is a cell, search from its parent row.\n    let startItem = collection.getItem(key);\n    if (startItem.type === \"cell\") key = startItem.parentKey;\n    let hasWrapped = false;\n    while (key != null) {\n      let item = collection.getItem(key);\n      // check row text value for match\n      if (item.textValue) {\n        let substring = item.textValue.slice(0, search.length);\n        if (this.collator.compare(substring, search) === 0) {\n          if (this.isRow(item) && this.focusMode === \"cell\") return (0, $cVkRF$getFirstItem)((0, $cVkRF$getChildNodes)(item, this.collection)).key;\n          return item.key;\n        }\n      }\n      key = this.findNextKey(key);\n      // Wrap around when reaching the end of the collection\n      if (key == null && !hasWrapped) {\n        key = this.getFirstKey();\n        hasWrapped = true;\n      }\n    }\n    return null;\n  }\n  constructor(options) {\n    this.collection = options.collection;\n    this.disabledKeys = options.disabledKeys;\n    this.ref = options.ref;\n    this.direction = options.direction;\n    this.collator = options.collator;\n    this.layout = options.layout;\n    this.focusMode = options.focusMode || \"row\";\n  }\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nconst $1af922eb41e03c8f$export$e6235c0d09b995d0 = new WeakMap();\n\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nvar $835c96616a7cb4f9$exports = {};\nvar $682989befd4f478d$exports = {};\n$682989befd4f478d$exports = {\n  \"deselectedItem\": args => `${args.item} غير المحدد`,\n  \"longPressToSelect\": `اضغط مطولًا للدخول إلى وضع التحديد.`,\n  \"select\": `تحديد`,\n  \"selectedAll\": `جميع العناصر المحددة.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `لم يتم تحديد عناصر`,\n    one: () => `${formatter.number(args.count)} عنصر محدد`,\n    other: () => `${formatter.number(args.count)} عنصر محدد`\n  })}.`,\n  \"selectedItem\": args => `${args.item} المحدد`\n};\nvar $f7fca02019afd941$exports = {};\n$f7fca02019afd941$exports = {\n  \"deselectedItem\": args => `${args.item} не е избран.`,\n  \"longPressToSelect\": `Натиснете и задръжте за да влезете в избирателен режим.`,\n  \"select\": `Изберете`,\n  \"selectedAll\": `Всички елементи са избрани.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Няма избрани елементи`,\n    one: () => `${formatter.number(args.count)} избран елемент`,\n    other: () => `${formatter.number(args.count)} избрани елементи`\n  })}.`,\n  \"selectedItem\": args => `${args.item} избран.`\n};\nvar $8f86f40be75387f1$exports = {};\n$8f86f40be75387f1$exports = {\n  \"deselectedItem\": args => `Položka ${args.item} není vybrána.`,\n  \"longPressToSelect\": `Dlouhým stisknutím přejdete do režimu výběru.`,\n  \"select\": `Vybrat`,\n  \"selectedAll\": `Vybrány všechny položky.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Nevybrány žádné položky`,\n    one: () => `Vybrána ${formatter.number(args.count)} položka`,\n    other: () => `Vybráno ${formatter.number(args.count)} položek`\n  })}.`,\n  \"selectedItem\": args => `Vybrána položka ${args.item}.`\n};\nvar $db24ba43c8d652ee$exports = {};\n$db24ba43c8d652ee$exports = {\n  \"deselectedItem\": args => `${args.item} ikke valgt.`,\n  \"longPressToSelect\": `Lav et langt tryk for at aktivere valgtilstand.`,\n  \"select\": `Vælg`,\n  \"selectedAll\": `Alle elementer valgt.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Ingen elementer valgt`,\n    one: () => `${formatter.number(args.count)} element valgt`,\n    other: () => `${formatter.number(args.count)} elementer valgt`\n  })}.`,\n  \"selectedItem\": args => `${args.item} valgt.`\n};\nvar $f8f1e72c8b5447d6$exports = {};\n$f8f1e72c8b5447d6$exports = {\n  \"deselectedItem\": args => `${args.item} nicht ausgewählt.`,\n  \"longPressToSelect\": `Gedrückt halten, um Auswahlmodus zu öffnen.`,\n  \"select\": `Auswählen`,\n  \"selectedAll\": `Alle Elemente ausgewählt.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Keine Elemente ausgewählt`,\n    one: () => `${formatter.number(args.count)} Element ausgewählt`,\n    other: () => `${formatter.number(args.count)} Elemente ausgewählt`\n  })}.`,\n  \"selectedItem\": args => `${args.item} ausgewählt.`\n};\nvar $9a73ed2983c3ab0b$exports = {};\n$9a73ed2983c3ab0b$exports = {\n  \"deselectedItem\": args => `Δεν επιλέχθηκε το στοιχείο ${args.item}.`,\n  \"longPressToSelect\": `Πατήστε παρατεταμένα για να μπείτε σε λειτουργία επιλογής.`,\n  \"select\": `Επιλογή`,\n  \"selectedAll\": `Επιλέχθηκαν όλα τα στοιχεία.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Δεν επιλέχθηκαν στοιχεία`,\n    one: () => `Επιλέχθηκε ${formatter.number(args.count)} στοιχείο`,\n    other: () => `Επιλέχθηκαν ${formatter.number(args.count)} στοιχεία`\n  })}.`,\n  \"selectedItem\": args => `Επιλέχθηκε το στοιχείο ${args.item}.`\n};\nvar $583de0b3587601b9$exports = {};\n$583de0b3587601b9$exports = {\n  \"deselectedItem\": args => `${args.item} not selected.`,\n  \"select\": `Select`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `No items selected`,\n    one: () => `${formatter.number(args.count)} item selected`,\n    other: () => `${formatter.number(args.count)} items selected`\n  })}.`,\n  \"selectedAll\": `All items selected.`,\n  \"selectedItem\": args => `${args.item} selected.`,\n  \"longPressToSelect\": `Long press to enter selection mode.`\n};\nvar $147159c978043442$exports = {};\n$147159c978043442$exports = {\n  \"deselectedItem\": args => `${args.item} no seleccionado.`,\n  \"longPressToSelect\": `Mantenga pulsado para abrir el modo de selección.`,\n  \"select\": `Seleccionar`,\n  \"selectedAll\": `Todos los elementos seleccionados.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Ningún elemento seleccionado`,\n    one: () => `${formatter.number(args.count)} elemento seleccionado`,\n    other: () => `${formatter.number(args.count)} elementos seleccionados`\n  })}.`,\n  \"selectedItem\": args => `${args.item} seleccionado.`\n};\nvar $5cbb62c8a19173ac$exports = {};\n$5cbb62c8a19173ac$exports = {\n  \"deselectedItem\": args => `${args.item} pole valitud.`,\n  \"longPressToSelect\": `Valikurežiimi sisenemiseks vajutage pikalt.`,\n  \"select\": `Vali`,\n  \"selectedAll\": `Kõik üksused valitud.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Üksusi pole valitud`,\n    one: () => `${formatter.number(args.count)} üksus valitud`,\n    other: () => `${formatter.number(args.count)} üksust valitud`\n  })}.`,\n  \"selectedItem\": args => `${args.item} valitud.`\n};\nvar $a33d71dc804cc59e$exports = {};\n$a33d71dc804cc59e$exports = {\n  \"deselectedItem\": args => `Kohdetta ${args.item} ei valittu.`,\n  \"longPressToSelect\": `Siirry valintatilaan painamalla pitkään.`,\n  \"select\": `Valitse`,\n  \"selectedAll\": `Kaikki kohteet valittu.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Ei yhtään kohdetta valittu`,\n    one: () => `${formatter.number(args.count)} kohde valittu`,\n    other: () => `${formatter.number(args.count)} kohdetta valittu`\n  })}.`,\n  \"selectedItem\": args => `${args.item} valittu.`\n};\nvar $92d800447793d084$exports = {};\n$92d800447793d084$exports = {\n  \"deselectedItem\": args => `${args.item} non sélectionné.`,\n  \"longPressToSelect\": `Appuyez de manière prolongée pour passer en mode de sélection.`,\n  \"select\": `Sélectionner`,\n  \"selectedAll\": `Tous les éléments sélectionnés.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Aucun élément sélectionné`,\n    one: () => `${formatter.number(args.count)} élément sélectionné`,\n    other: () => `${formatter.number(args.count)} éléments sélectionnés`\n  })}.`,\n  \"selectedItem\": args => `${args.item} sélectionné.`\n};\nvar $fe732cdb32124ea8$exports = {};\n$fe732cdb32124ea8$exports = {\n  \"deselectedItem\": args => `${args.item} לא נבחר.`,\n  \"longPressToSelect\": `הקשה ארוכה לכניסה למצב בחירה.`,\n  \"select\": `בחר`,\n  \"selectedAll\": `כל הפריטים נבחרו.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `לא נבחרו פריטים`,\n    one: () => `פריט ${formatter.number(args.count)} נבחר`,\n    other: () => `${formatter.number(args.count)} פריטים נבחרו`\n  })}.`,\n  \"selectedItem\": args => `${args.item} נבחר.`\n};\nvar $e41234e934efb4f5$exports = {};\n$e41234e934efb4f5$exports = {\n  \"deselectedItem\": args => `Stavka ${args.item} nije odabrana.`,\n  \"longPressToSelect\": `Dugo pritisnite za ulazak u način odabira.`,\n  \"select\": `Odaberite`,\n  \"selectedAll\": `Odabrane su sve stavke.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Nije odabrana nijedna stavka`,\n    one: () => `Odabrana je ${formatter.number(args.count)} stavka`,\n    other: () => `Odabrano je ${formatter.number(args.count)} stavki`\n  })}.`,\n  \"selectedItem\": args => `Stavka ${args.item} je odabrana.`\n};\nvar $1b0393182473bf9e$exports = {};\n$1b0393182473bf9e$exports = {\n  \"deselectedItem\": args => `${args.item} nincs kijelölve.`,\n  \"longPressToSelect\": `Nyomja hosszan a kijelöléshez.`,\n  \"select\": `Kijelölés`,\n  \"selectedAll\": `Az összes elem kijelölve.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Egy elem sincs kijelölve`,\n    one: () => `${formatter.number(args.count)} elem kijelölve`,\n    other: () => `${formatter.number(args.count)} elem kijelölve`\n  })}.`,\n  \"selectedItem\": args => `${args.item} kijelölve.`\n};\nvar $2eed782c1c110ce7$exports = {};\n$2eed782c1c110ce7$exports = {\n  \"deselectedItem\": args => `${args.item} non selezionato.`,\n  \"longPressToSelect\": `Premi a lungo per passare alla modalità di selezione.`,\n  \"select\": `Seleziona`,\n  \"selectedAll\": `Tutti gli elementi selezionati.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Nessun elemento selezionato`,\n    one: () => `${formatter.number(args.count)} elemento selezionato`,\n    other: () => `${formatter.number(args.count)} elementi selezionati`\n  })}.`,\n  \"selectedItem\": args => `${args.item} selezionato.`\n};\nvar $8b5d459f86e9b23c$exports = {};\n$8b5d459f86e9b23c$exports = {\n  \"deselectedItem\": args => `${args.item} が選択されていません。`,\n  \"longPressToSelect\": `長押しして選択モードを開きます。`,\n  \"select\": `選択`,\n  \"selectedAll\": `すべての項目を選択しました。`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `項目が選択されていません`,\n    one: () => `${formatter.number(args.count)} 項目を選択しました`,\n    other: () => `${formatter.number(args.count)} 項目を選択しました`\n  })}。`,\n  \"selectedItem\": args => `${args.item} を選択しました。`\n};\nvar $1949c3ad17295fd4$exports = {};\n$1949c3ad17295fd4$exports = {\n  \"deselectedItem\": args => `${args.item}이(가) 선택되지 않았습니다.`,\n  \"longPressToSelect\": `선택 모드로 들어가려면 길게 누르십시오.`,\n  \"select\": `선택`,\n  \"selectedAll\": `모든 항목이 선택되었습니다.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `선택된 항목이 없습니다`,\n    one: () => `${formatter.number(args.count)}개 항목이 선택되었습니다`,\n    other: () => `${formatter.number(args.count)}개 항목이 선택되었습니다`\n  })}.`,\n  \"selectedItem\": args => `${args.item}이(가) 선택되었습니다.`\n};\nvar $f5e3df4dc8aa7b54$exports = {};\n$f5e3df4dc8aa7b54$exports = {\n  \"deselectedItem\": args => `${args.item} nepasirinkta.`,\n  \"longPressToSelect\": `Norėdami įjungti pasirinkimo režimą, paspauskite ir palaikykite.`,\n  \"select\": `Pasirinkti`,\n  \"selectedAll\": `Pasirinkti visi elementai.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Nepasirinktas nė vienas elementas`,\n    one: () => `Pasirinktas ${formatter.number(args.count)} elementas`,\n    other: () => `Pasirinkta elementų: ${formatter.number(args.count)}`\n  })}.`,\n  \"selectedItem\": args => `Pasirinkta: ${args.item}.`\n};\nvar $9dd86690a5c2b2c5$exports = {};\n$9dd86690a5c2b2c5$exports = {\n  \"deselectedItem\": args => `Vienums ${args.item} nav atlasīts.`,\n  \"longPressToSelect\": `Ilgi turiet nospiestu. lai ieslēgtu atlases režīmu.`,\n  \"select\": `Atlasīt`,\n  \"selectedAll\": `Atlasīti visi vienumi.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Nav atlasīts neviens vienums`,\n    one: () => `Atlasīto vienumu skaits: ${formatter.number(args.count)}`,\n    other: () => `Atlasīto vienumu skaits: ${formatter.number(args.count)}`\n  })}.`,\n  \"selectedItem\": args => `Atlasīts vienums ${args.item}.`\n};\nvar $843964c3bf9a7d24$exports = {};\n$843964c3bf9a7d24$exports = {\n  \"deselectedItem\": args => `${args.item} er ikke valgt.`,\n  \"longPressToSelect\": `Bruk et langt trykk for å gå inn i valgmodus.`,\n  \"select\": `Velg`,\n  \"selectedAll\": `Alle elementer er valgt.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Ingen elementer er valgt`,\n    one: () => `${formatter.number(args.count)} element er valgt`,\n    other: () => `${formatter.number(args.count)} elementer er valgt`\n  })}.`,\n  \"selectedItem\": args => `${args.item} er valgt.`\n};\nvar $73f50e845f9ef3b4$exports = {};\n$73f50e845f9ef3b4$exports = {\n  \"deselectedItem\": args => `${args.item} niet geselecteerd.`,\n  \"longPressToSelect\": `Druk lang om de selectiemodus te openen.`,\n  \"select\": `Selecteren`,\n  \"selectedAll\": `Alle items geselecteerd.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Geen items geselecteerd`,\n    one: () => `${formatter.number(args.count)} item geselecteerd`,\n    other: () => `${formatter.number(args.count)} items geselecteerd`\n  })}.`,\n  \"selectedItem\": args => `${args.item} geselecteerd.`\n};\nvar $87f92a7e077514b2$exports = {};\n$87f92a7e077514b2$exports = {\n  \"deselectedItem\": args => `Nie zaznaczono ${args.item}.`,\n  \"longPressToSelect\": `Naciśnij i przytrzymaj, aby wejść do trybu wyboru.`,\n  \"select\": `Zaznacz`,\n  \"selectedAll\": `Wszystkie zaznaczone elementy.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Nie zaznaczono żadnych elementów`,\n    one: () => `${formatter.number(args.count)} zaznaczony element`,\n    other: () => `${formatter.number(args.count)} zaznaczonych elementów`\n  })}.`,\n  \"selectedItem\": args => `Zaznaczono ${args.item}.`\n};\nvar $c28c98d58ee9ff6f$exports = {};\n$c28c98d58ee9ff6f$exports = {\n  \"deselectedItem\": args => `${args.item} não selecionado.`,\n  \"longPressToSelect\": `Mantenha pressionado para entrar no modo de seleção.`,\n  \"select\": `Selecionar`,\n  \"selectedAll\": `Todos os itens selecionados.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Nenhum item selecionado`,\n    one: () => `${formatter.number(args.count)} item selecionado`,\n    other: () => `${formatter.number(args.count)} itens selecionados`\n  })}.`,\n  \"selectedItem\": args => `${args.item} selecionado.`\n};\nvar $b6b1503b17b2254d$exports = {};\n$b6b1503b17b2254d$exports = {\n  \"deselectedItem\": args => `${args.item} não selecionado.`,\n  \"longPressToSelect\": `Prima continuamente para entrar no modo de seleção.`,\n  \"select\": `Selecionar`,\n  \"selectedAll\": `Todos os itens selecionados.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Nenhum item selecionado`,\n    one: () => `${formatter.number(args.count)} item selecionado`,\n    other: () => `${formatter.number(args.count)} itens selecionados`\n  })}.`,\n  \"selectedItem\": args => `${args.item} selecionado.`\n};\nvar $8bdaeb71e50c3e1a$exports = {};\n$8bdaeb71e50c3e1a$exports = {\n  \"deselectedItem\": args => `${args.item} neselectat.`,\n  \"longPressToSelect\": `Apăsați lung pentru a intra în modul de selectare.`,\n  \"select\": `Selectare`,\n  \"selectedAll\": `Toate elementele selectate.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Niciun element selectat`,\n    one: () => `${formatter.number(args.count)} element selectat`,\n    other: () => `${formatter.number(args.count)} elemente selectate`\n  })}.`,\n  \"selectedItem\": args => `${args.item} selectat.`\n};\nvar $ec2b852dd7c3d1f2$exports = {};\n$ec2b852dd7c3d1f2$exports = {\n  \"deselectedItem\": args => `${args.item} не выбрано.`,\n  \"longPressToSelect\": `Нажмите и удерживайте для входа в режим выбора.`,\n  \"select\": `Выбрать`,\n  \"selectedAll\": `Выбраны все элементы.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Нет выбранных элементов`,\n    one: () => `${formatter.number(args.count)} элемент выбран`,\n    other: () => `${formatter.number(args.count)} элементов выбрано`\n  })}.`,\n  \"selectedItem\": args => `${args.item} выбрано.`\n};\nvar $79e6d900d6a4f82d$exports = {};\n$79e6d900d6a4f82d$exports = {\n  \"deselectedItem\": args => `Nevybraté položky: ${args.item}.`,\n  \"longPressToSelect\": `Dlhším stlačením prejdite do režimu výberu.`,\n  \"select\": `Vybrať`,\n  \"selectedAll\": `Všetky vybraté položky.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Žiadne vybraté položky`,\n    one: () => `${formatter.number(args.count)} vybratá položka`,\n    other: () => `Počet vybratých položiek:${formatter.number(args.count)}`\n  })}.`,\n  \"selectedItem\": args => `Vybraté položky: ${args.item}.`\n};\nvar $f4c1f0d5d4d03d80$exports = {};\n$f4c1f0d5d4d03d80$exports = {\n  \"deselectedItem\": args => `Element ${args.item} ni izbran.`,\n  \"longPressToSelect\": `Za izbirni način pritisnite in dlje časa držite.`,\n  \"select\": `Izberite`,\n  \"selectedAll\": `Vsi elementi so izbrani.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Noben element ni izbran`,\n    one: () => `${formatter.number(args.count)} element je izbran`,\n    other: () => `${formatter.number(args.count)} elementov je izbranih`\n  })}.`,\n  \"selectedItem\": args => `Element ${args.item} je izbran.`\n};\nvar $46252cd87269b10b$exports = {};\n$46252cd87269b10b$exports = {\n  \"deselectedItem\": args => `${args.item} nije izabrano.`,\n  \"longPressToSelect\": `Dugo pritisnite za ulazak u režim biranja.`,\n  \"select\": `Izaberite`,\n  \"selectedAll\": `Izabrane su sve stavke.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Nije izabrana nijedna stavka`,\n    one: () => `Izabrana je ${formatter.number(args.count)} stavka`,\n    other: () => `Izabrano je ${formatter.number(args.count)} stavki`\n  })}.`,\n  \"selectedItem\": args => `${args.item} je izabrano.`\n};\nvar $d4d5d8dab362555c$exports = {};\n$d4d5d8dab362555c$exports = {\n  \"deselectedItem\": args => `${args.item} ej markerat.`,\n  \"longPressToSelect\": `Tryck länge när du vill öppna väljarläge.`,\n  \"select\": `Markera`,\n  \"selectedAll\": `Alla markerade objekt.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Inga markerade objekt`,\n    one: () => `${formatter.number(args.count)} markerat objekt`,\n    other: () => `${formatter.number(args.count)} markerade objekt`\n  })}.`,\n  \"selectedItem\": args => `${args.item} markerat.`\n};\nvar $3d55d1f97c377e83$exports = {};\n$3d55d1f97c377e83$exports = {\n  \"deselectedItem\": args => `${args.item} seçilmedi.`,\n  \"longPressToSelect\": `Seçim moduna girmek için uzun basın.`,\n  \"select\": `Seç`,\n  \"selectedAll\": `Tüm ögeler seçildi.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Hiçbir öge seçilmedi`,\n    one: () => `${formatter.number(args.count)} öge seçildi`,\n    other: () => `${formatter.number(args.count)} öge seçildi`\n  })}.`,\n  \"selectedItem\": args => `${args.item} seçildi.`\n};\nvar $5368512f1c703a3f$exports = {};\n$5368512f1c703a3f$exports = {\n  \"deselectedItem\": args => `${args.item} не вибрано.`,\n  \"longPressToSelect\": `Виконайте довге натиснення, щоб перейти в режим вибору.`,\n  \"select\": `Вибрати`,\n  \"selectedAll\": `Усі елементи вибрано.`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `Жодних елементів не вибрано`,\n    one: () => `${formatter.number(args.count)} елемент вибрано`,\n    other: () => `Вибрано елементів: ${formatter.number(args.count)}`\n  })}.`,\n  \"selectedItem\": args => `${args.item} вибрано.`\n};\nvar $f1316b1074463583$exports = {};\n$f1316b1074463583$exports = {\n  \"deselectedItem\": args => `未选择 ${args.item}。`,\n  \"longPressToSelect\": `长按以进入选择模式。`,\n  \"select\": `选择`,\n  \"selectedAll\": `已选择所有项目。`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `未选择项目`,\n    one: () => `已选择 ${formatter.number(args.count)} 个项目`,\n    other: () => `已选择 ${formatter.number(args.count)} 个项目`\n  })}。`,\n  \"selectedItem\": args => `已选择 ${args.item}。`\n};\nvar $7e60654723031b6f$exports = {};\n$7e60654723031b6f$exports = {\n  \"deselectedItem\": args => `未選取「${args.item}」。`,\n  \"longPressToSelect\": `長按以進入選擇模式。`,\n  \"select\": `選取`,\n  \"selectedAll\": `已選取所有項目。`,\n  \"selectedCount\": (args, formatter) => `${formatter.plural(args.count, {\n    \"=0\": `未選取任何項目`,\n    one: () => `已選取 ${formatter.number(args.count)} 個項目`,\n    other: () => `已選取 ${formatter.number(args.count)} 個項目`\n  })}。`,\n  \"selectedItem\": args => `已選取「${args.item}」。`\n};\n$835c96616a7cb4f9$exports = {\n  \"ar-AE\": $682989befd4f478d$exports,\n  \"bg-BG\": $f7fca02019afd941$exports,\n  \"cs-CZ\": $8f86f40be75387f1$exports,\n  \"da-DK\": $db24ba43c8d652ee$exports,\n  \"de-DE\": $f8f1e72c8b5447d6$exports,\n  \"el-GR\": $9a73ed2983c3ab0b$exports,\n  \"en-US\": $583de0b3587601b9$exports,\n  \"es-ES\": $147159c978043442$exports,\n  \"et-EE\": $5cbb62c8a19173ac$exports,\n  \"fi-FI\": $a33d71dc804cc59e$exports,\n  \"fr-FR\": $92d800447793d084$exports,\n  \"he-IL\": $fe732cdb32124ea8$exports,\n  \"hr-HR\": $e41234e934efb4f5$exports,\n  \"hu-HU\": $1b0393182473bf9e$exports,\n  \"it-IT\": $2eed782c1c110ce7$exports,\n  \"ja-JP\": $8b5d459f86e9b23c$exports,\n  \"ko-KR\": $1949c3ad17295fd4$exports,\n  \"lt-LT\": $f5e3df4dc8aa7b54$exports,\n  \"lv-LV\": $9dd86690a5c2b2c5$exports,\n  \"nb-NO\": $843964c3bf9a7d24$exports,\n  \"nl-NL\": $73f50e845f9ef3b4$exports,\n  \"pl-PL\": $87f92a7e077514b2$exports,\n  \"pt-BR\": $c28c98d58ee9ff6f$exports,\n  \"pt-PT\": $b6b1503b17b2254d$exports,\n  \"ro-RO\": $8bdaeb71e50c3e1a$exports,\n  \"ru-RU\": $ec2b852dd7c3d1f2$exports,\n  \"sk-SK\": $79e6d900d6a4f82d$exports,\n  \"sl-SI\": $f4c1f0d5d4d03d80$exports,\n  \"sr-SP\": $46252cd87269b10b$exports,\n  \"sv-SE\": $d4d5d8dab362555c$exports,\n  \"tr-TR\": $3d55d1f97c377e83$exports,\n  \"uk-UA\": $5368512f1c703a3f$exports,\n  \"zh-CN\": $f1316b1074463583$exports,\n  \"zh-TW\": $7e60654723031b6f$exports\n};\nfunction $92599c3fd427b763$export$137e594ef3218a10(props, state) {\n  var _state_collection_getTextValue;\n  let {\n    getRowText = key => {\n      var _state_collection, _state_collection_getTextValue1, _state_collection_getItem;\n      return (_state_collection_getTextValue = (_state_collection_getTextValue1 = (_state_collection = state.collection).getTextValue) === null || _state_collection_getTextValue1 === void 0 ? void 0 : _state_collection_getTextValue1.call(_state_collection, key)) !== null && _state_collection_getTextValue !== void 0 ? _state_collection_getTextValue : (_state_collection_getItem = state.collection.getItem(key)) === null || _state_collection_getItem === void 0 ? void 0 : _state_collection_getItem.textValue;\n    }\n  } = props;\n  let stringFormatter = (0, $cVkRF$useLocalizedStringFormatter)((0, /*@__PURE__*/$parcel$interopDefault($835c96616a7cb4f9$exports)));\n  // Many screen readers do not announce when items in a grid are selected/deselected.\n  // We do this using an ARIA live region.\n  let selection = state.selectionManager.rawSelection;\n  let lastSelection = (0, $cVkRF$useRef)(selection);\n  (0, $cVkRF$useUpdateEffect)(() => {\n    var _lastSelection_current;\n    if (!state.selectionManager.isFocused) {\n      lastSelection.current = selection;\n      return;\n    }\n    let addedKeys = $92599c3fd427b763$var$diffSelection(selection, lastSelection.current);\n    let removedKeys = $92599c3fd427b763$var$diffSelection(lastSelection.current, selection);\n    // If adding or removing a single row from the selection, announce the name of that item.\n    let isReplace = state.selectionManager.selectionBehavior === \"replace\";\n    let messages = [];\n    if (state.selectionManager.selectedKeys.size === 1 && isReplace) {\n      if (state.collection.getItem(state.selectionManager.selectedKeys.keys().next().value)) {\n        let currentSelectionText = getRowText(state.selectionManager.selectedKeys.keys().next().value);\n        if (currentSelectionText) messages.push(stringFormatter.format(\"selectedItem\", {\n          item: currentSelectionText\n        }));\n      }\n    } else if (addedKeys.size === 1 && removedKeys.size === 0) {\n      let addedText = getRowText(addedKeys.keys().next().value);\n      if (addedText) messages.push(stringFormatter.format(\"selectedItem\", {\n        item: addedText\n      }));\n    } else if (removedKeys.size === 1 && addedKeys.size === 0) {\n      if (state.collection.getItem(removedKeys.keys().next().value)) {\n        let removedText = getRowText(removedKeys.keys().next().value);\n        if (removedText) messages.push(stringFormatter.format(\"deselectedItem\", {\n          item: removedText\n        }));\n      }\n    }\n    // Announce how many items are selected, except when selecting the first item.\n    if (state.selectionManager.selectionMode === \"multiple\") {\n      if (messages.length === 0 || selection === \"all\" || selection.size > 1 || lastSelection.current === \"all\" || ((_lastSelection_current = lastSelection.current) === null || _lastSelection_current === void 0 ? void 0 : _lastSelection_current.size) > 1) messages.push(selection === \"all\" ? stringFormatter.format(\"selectedAll\") : stringFormatter.format(\"selectedCount\", {\n        count: selection.size\n      }));\n    }\n    if (messages.length > 0) (0, $cVkRF$announce)(messages.join(\" \"));\n    lastSelection.current = selection;\n  }, [selection]);\n}\nfunction $92599c3fd427b763$var$diffSelection(a, b) {\n  let res = new Set();\n  if (a === \"all\" || b === \"all\") return res;\n  for (let key of a.keys()) if (!b.has(key)) res.add(key);\n  return res;\n}\n\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $5b9b5b5723db6ae1$export$be42ebdab07ae4c2(props) {\n  let stringFormatter = (0, $cVkRF$useLocalizedStringFormatter)((0, /*@__PURE__*/$parcel$interopDefault($835c96616a7cb4f9$exports)));\n  let modality = (0, $cVkRF$useInteractionModality)();\n  // null is the default if the user hasn't interacted with the table at all yet or the rest of the page\n  let shouldLongPress = (modality === \"pointer\" || modality === \"virtual\" || modality == null) && typeof window !== \"undefined\" && \"ontouchstart\" in window;\n  let interactionDescription = (0, $cVkRF$useMemo)(() => {\n    let selectionMode = props.selectionManager.selectionMode;\n    let selectionBehavior = props.selectionManager.selectionBehavior;\n    let message = undefined;\n    if (shouldLongPress) message = stringFormatter.format(\"longPressToSelect\");\n    return selectionBehavior === \"replace\" && selectionMode !== \"none\" && props.hasItemActions ? message : undefined;\n  }, [props.selectionManager.selectionMode, props.selectionManager.selectionBehavior, props.hasItemActions, stringFormatter, shouldLongPress]);\n  let descriptionProps = (0, $cVkRF$useDescription)(interactionDescription);\n  return descriptionProps;\n}\nfunction $83c6e2eafa584c67$export$f6b86a04e5d66d90(props, state, ref) {\n  let {\n    isVirtualized: isVirtualized,\n    keyboardDelegate: keyboardDelegate,\n    focusMode: focusMode,\n    scrollRef: scrollRef,\n    getRowText: getRowText,\n    onRowAction: onRowAction,\n    onCellAction: onCellAction\n  } = props;\n  let {\n    selectionManager: manager\n  } = state;\n  if (!props[\"aria-label\"] && !props[\"aria-labelledby\"]) console.warn(\"An aria-label or aria-labelledby prop is required for accessibility.\");\n  // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n  let collator = (0, $cVkRF$useCollator)({\n    usage: \"search\",\n    sensitivity: \"base\"\n  });\n  let {\n    direction: direction\n  } = (0, $cVkRF$useLocale)();\n  let disabledBehavior = state.selectionManager.disabledBehavior;\n  let delegate = (0, $cVkRF$useMemo)(() => keyboardDelegate || new (0, $d1c300d9c497e402$export$de9feff04fda126e)({\n    collection: state.collection,\n    disabledKeys: disabledBehavior === \"selection\" ? new Set() : state.disabledKeys,\n    ref: ref,\n    direction: direction,\n    collator: collator,\n    focusMode: focusMode\n  }), [keyboardDelegate, state.collection, state.disabledKeys, disabledBehavior, ref, direction, collator, focusMode]);\n  let {\n    collectionProps: collectionProps\n  } = (0, $cVkRF$useSelectableCollection)({\n    ref: ref,\n    selectionManager: manager,\n    keyboardDelegate: delegate,\n    isVirtualized: isVirtualized,\n    scrollRef: scrollRef\n  });\n  let id = (0, $cVkRF$useId)(props.id);\n  (0, $1af922eb41e03c8f$export$e6235c0d09b995d0).set(state, {\n    keyboardDelegate: delegate,\n    actions: {\n      onRowAction: onRowAction,\n      onCellAction: onCellAction\n    }\n  });\n  let descriptionProps = (0, $5b9b5b5723db6ae1$export$be42ebdab07ae4c2)({\n    selectionManager: manager,\n    hasItemActions: !!(onRowAction || onCellAction)\n  });\n  let domProps = (0, $cVkRF$filterDOMProps)(props, {\n    labelable: true\n  });\n  let onFocus = (0, $cVkRF$useCallback)(e => {\n    if (manager.isFocused) {\n      // If a focus event bubbled through a portal, reset focus state.\n      if (!e.currentTarget.contains(e.target)) manager.setFocused(false);\n      return;\n    }\n    // Focus events can bubble through portals. Ignore these events.\n    if (!e.currentTarget.contains(e.target)) return;\n    manager.setFocused(true);\n  }, [manager]);\n  // Continue to track collection focused state even if keyboard navigation is disabled\n  let navDisabledHandlers = (0, $cVkRF$useMemo)(() => ({\n    onBlur: collectionProps.onBlur,\n    onFocus: onFocus\n  }), [onFocus, collectionProps.onBlur]);\n  let hasTabbableChild = (0, $cVkRF$useHasTabbableChild)(ref, {\n    isDisabled: state.collection.size !== 0\n  });\n  let gridProps = (0, $cVkRF$mergeProps)(domProps, {\n    role: \"grid\",\n    id: id,\n    \"aria-multiselectable\": manager.selectionMode === \"multiple\" ? \"true\" : undefined\n  }, state.isKeyboardNavigationDisabled ? navDisabledHandlers : collectionProps,\n  // If collection is empty, make sure the grid is tabbable unless there is a child tabbable element.\n  state.collection.size === 0 && {\n    tabIndex: hasTabbableChild ? -1 : 0\n  }, descriptionProps);\n  if (isVirtualized) {\n    gridProps[\"aria-rowcount\"] = state.collection.size;\n    gridProps[\"aria-colcount\"] = state.collection.columnCount;\n  }\n  (0, $92599c3fd427b763$export$137e594ef3218a10)({\n    getRowText: getRowText\n  }, state);\n  return {\n    gridProps: gridProps\n  };\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nfunction $e45487f8ba1cbdbf$export$d3037f5d3f3e51bf() {\n  return {\n    rowGroupProps: {\n      role: \"rowgroup\"\n    }\n  };\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $4159a7a9cbb0cc18$export$96357d5a73f686fa(props, state, ref) {\n  let {\n    node: node,\n    isVirtualized: isVirtualized,\n    shouldSelectOnPressUp: shouldSelectOnPressUp,\n    onAction: onAction\n  } = props;\n  let {\n    actions: {\n      onRowAction: onRowAction\n    }\n  } = (0, $1af922eb41e03c8f$export$e6235c0d09b995d0).get(state);\n  let {\n    itemProps: itemProps,\n    ...states\n  } = (0, $cVkRF$useSelectableItem)({\n    selectionManager: state.selectionManager,\n    key: node.key,\n    ref: ref,\n    isVirtualized: isVirtualized,\n    shouldSelectOnPressUp: shouldSelectOnPressUp,\n    onAction: onRowAction ? () => onRowAction(node.key) : onAction,\n    isDisabled: state.collection.size === 0\n  });\n  let isSelected = state.selectionManager.isSelected(node.key);\n  let rowProps = {\n    role: \"row\",\n    \"aria-selected\": state.selectionManager.selectionMode !== \"none\" ? isSelected : undefined,\n    \"aria-disabled\": states.isDisabled || undefined,\n    ...itemProps\n  };\n  if (isVirtualized) rowProps[\"aria-rowindex\"] = node.index + 1; // aria-rowindex is 1 based\n  return {\n    rowProps: rowProps,\n    ...states\n  };\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c(props, state, ref) {\n  let {\n    node: node,\n    isVirtualized: isVirtualized,\n    focusMode = \"child\",\n    shouldSelectOnPressUp: shouldSelectOnPressUp,\n    onAction: onAction\n  } = props;\n  let {\n    direction: direction\n  } = (0, $cVkRF$useLocale)();\n  let {\n    keyboardDelegate: keyboardDelegate,\n    actions: {\n      onCellAction: onCellAction\n    }\n  } = (0, $1af922eb41e03c8f$export$e6235c0d09b995d0).get(state);\n  // We need to track the key of the item at the time it was last focused so that we force\n  // focus to go to the item when the DOM node is reused for a different item in a virtualizer.\n  let keyWhenFocused = (0, $cVkRF$useRef)(null);\n  // Handles focusing the cell. If there is a focusable child,\n  // it is focused, otherwise the cell itself is focused.\n  let focus = () => {\n    let treeWalker = (0, $cVkRF$getFocusableTreeWalker)(ref.current);\n    if (focusMode === \"child\") {\n      // If focus is already on a focusable child within the cell, early return so we don't shift focus\n      if (ref.current.contains(document.activeElement) && ref.current !== document.activeElement) return;\n      let focusable = state.selectionManager.childFocusStrategy === \"last\" ? $ab90dcbc1b5466d0$var$last(treeWalker) : treeWalker.firstChild();\n      if (focusable) {\n        (0, $cVkRF$focusSafely)(focusable);\n        return;\n      }\n    }\n    if (keyWhenFocused.current != null && node.key !== keyWhenFocused.current || !ref.current.contains(document.activeElement)) (0, $cVkRF$focusSafely)(ref.current);\n  };\n  let {\n    itemProps: itemProps,\n    isPressed: isPressed\n  } = (0, $cVkRF$useSelectableItem)({\n    selectionManager: state.selectionManager,\n    key: node.key,\n    ref: ref,\n    isVirtualized: isVirtualized,\n    focus: focus,\n    shouldSelectOnPressUp: shouldSelectOnPressUp,\n    onAction: onCellAction ? () => onCellAction(node.key) : onAction,\n    isDisabled: state.collection.size === 0\n  });\n  let onKeyDownCapture = e => {\n    if (!e.currentTarget.contains(e.target) || state.isKeyboardNavigationDisabled) return;\n    let walker = (0, $cVkRF$getFocusableTreeWalker)(ref.current);\n    walker.currentNode = document.activeElement;\n    switch (e.key) {\n      case \"ArrowLeft\":\n        {\n          // Find the next focusable element within the cell.\n          let focusable = direction === \"rtl\" ? walker.nextNode() : walker.previousNode();\n          // Don't focus the cell itself if focusMode is \"child\"\n          if (focusMode === \"child\" && focusable === ref.current) focusable = null;\n          if (focusable) {\n            e.preventDefault();\n            e.stopPropagation();\n            (0, $cVkRF$focusSafely)(focusable);\n            (0, $cVkRF$scrollIntoViewport)(focusable, {\n              containingElement: (0, $cVkRF$getScrollParent)(ref.current)\n            });\n          } else {\n            // If there is no next focusable child, then move to the next cell to the left of this one.\n            // This will be handled by useSelectableCollection. However, if there is no cell to the left\n            // of this one, only one column, and the grid doesn't focus rows, then the next key will be the\n            // same as this one. In that case we need to handle focusing either the cell or the first/last\n            // child, depending on the focus mode.\n            let prev = keyboardDelegate.getKeyLeftOf(node.key);\n            if (prev !== node.key) break;\n            e.preventDefault();\n            e.stopPropagation();\n            if (focusMode === \"cell\" && direction === \"rtl\") {\n              (0, $cVkRF$focusSafely)(ref.current);\n              (0, $cVkRF$scrollIntoViewport)(ref.current, {\n                containingElement: (0, $cVkRF$getScrollParent)(ref.current)\n              });\n            } else {\n              walker.currentNode = ref.current;\n              focusable = direction === \"rtl\" ? walker.firstChild() : $ab90dcbc1b5466d0$var$last(walker);\n              if (focusable) {\n                (0, $cVkRF$focusSafely)(focusable);\n                (0, $cVkRF$scrollIntoViewport)(focusable, {\n                  containingElement: (0, $cVkRF$getScrollParent)(ref.current)\n                });\n              }\n            }\n          }\n          break;\n        }\n      case \"ArrowRight\":\n        {\n          let focusable = direction === \"rtl\" ? walker.previousNode() : walker.nextNode();\n          if (focusMode === \"child\" && focusable === ref.current) focusable = null;\n          if (focusable) {\n            e.preventDefault();\n            e.stopPropagation();\n            (0, $cVkRF$focusSafely)(focusable);\n            (0, $cVkRF$scrollIntoViewport)(focusable, {\n              containingElement: (0, $cVkRF$getScrollParent)(ref.current)\n            });\n          } else {\n            let next = keyboardDelegate.getKeyRightOf(node.key);\n            if (next !== node.key) break;\n            e.preventDefault();\n            e.stopPropagation();\n            if (focusMode === \"cell\" && direction === \"ltr\") {\n              (0, $cVkRF$focusSafely)(ref.current);\n              (0, $cVkRF$scrollIntoViewport)(ref.current, {\n                containingElement: (0, $cVkRF$getScrollParent)(ref.current)\n              });\n            } else {\n              walker.currentNode = ref.current;\n              focusable = direction === \"rtl\" ? $ab90dcbc1b5466d0$var$last(walker) : walker.firstChild();\n              if (focusable) {\n                (0, $cVkRF$focusSafely)(focusable);\n                (0, $cVkRF$scrollIntoViewport)(focusable, {\n                  containingElement: (0, $cVkRF$getScrollParent)(ref.current)\n                });\n              }\n            }\n          }\n          break;\n        }\n      case \"ArrowUp\":\n      case \"ArrowDown\":\n        // Prevent this event from reaching cell children, e.g. menu buttons. We want arrow keys to navigate\n        // to the cell above/below instead. We need to re-dispatch the event from a higher parent so it still\n        // bubbles and gets handled by useSelectableCollection.\n        if (!e.altKey && ref.current.contains(e.target)) {\n          e.stopPropagation();\n          e.preventDefault();\n          ref.current.parentElement.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));\n        }\n        break;\n    }\n  };\n  // Grid cells can have focusable elements inside them. In this case, focus should\n  // be marshalled to that element rather than focusing the cell itself.\n  let onFocus = e => {\n    keyWhenFocused.current = node.key;\n    if (e.target !== ref.current) {\n      // useSelectableItem only handles setting the focused key when\n      // the focused element is the gridcell itself. We also want to\n      // set the focused key when a child element receives focus.\n      // If focus is currently visible (e.g. the user is navigating with the keyboard),\n      // then skip this. We want to restore focus to the previously focused row/cell\n      // in that case since the table should act like a single tab stop.\n      if (!(0, $cVkRF$isFocusVisible)()) state.selectionManager.setFocusedKey(node.key);\n      return;\n    }\n    // If the cell itself is focused, wait a frame so that focus finishes propagatating\n    // up to the tree, and move focus to a focusable child if possible.\n    requestAnimationFrame(() => {\n      if (focusMode === \"child\" && document.activeElement === ref.current) focus();\n    });\n  };\n  let gridCellProps = (0, $cVkRF$mergeProps)(itemProps, {\n    role: \"gridcell\",\n    onKeyDownCapture: onKeyDownCapture,\n    onFocus: onFocus\n  });\n  var _node_colIndex;\n  if (isVirtualized) gridCellProps[\"aria-colindex\"] = ((_node_colIndex = node.colIndex) !== null && _node_colIndex !== void 0 ? _node_colIndex : node.index) + 1; // aria-colindex is 1-based\n  // When pressing with a pointer and cell selection is not enabled, usePress will be applied to the\n  // row rather than the cell. However, when the row is draggable, usePress cannot preventDefault\n  // on pointer down, so the browser will try to focus the cell which has a tabIndex applied.\n  // To avoid this, remove the tabIndex from the cell briefly on pointer down.\n  if (shouldSelectOnPressUp && gridCellProps.tabIndex != null && gridCellProps.onPointerDown == null) gridCellProps.onPointerDown = e => {\n    let el = e.currentTarget;\n    let tabindex = el.getAttribute(\"tabindex\");\n    el.removeAttribute(\"tabindex\");\n    requestAnimationFrame(() => {\n      el.setAttribute(\"tabindex\", tabindex);\n    });\n  };\n  return {\n    gridCellProps: gridCellProps,\n    isPressed: isPressed\n  };\n}\nfunction $ab90dcbc1b5466d0$var$last(walker) {\n  let next;\n  let last;\n  do {\n    last = walker.lastChild();\n    if (last) next = last;\n  } while (last);\n  return next;\n}\nfunction $7cb39d07f245a780$export$70e2eed1a92976ad(props, state) {\n  let {\n    key: key\n  } = props;\n  let manager = state.selectionManager;\n  let checkboxId = (0, $cVkRF$useId)();\n  let isDisabled = !state.selectionManager.canSelectItem(key);\n  let isSelected = state.selectionManager.isSelected(key);\n  let onChange = () => manager.select(key);\n  const stringFormatter = (0, $cVkRF$useLocalizedStringFormatter)((0, /*@__PURE__*/$parcel$interopDefault($835c96616a7cb4f9$exports)));\n  return {\n    checkboxProps: {\n      id: checkboxId,\n      \"aria-label\": stringFormatter.format(\"select\"),\n      isSelected: isSelected,\n      isDisabled: isDisabled,\n      onChange: onChange\n    }\n  };\n}\nexport { $d1c300d9c497e402$export$de9feff04fda126e as GridKeyboardDelegate, $83c6e2eafa584c67$export$f6b86a04e5d66d90 as useGrid, $e45487f8ba1cbdbf$export$d3037f5d3f3e51bf as useGridRowGroup, $4159a7a9cbb0cc18$export$96357d5a73f686fa as useGridRow, $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c as useGridCell, $7cb39d07f245a780$export$70e2eed1a92976ad as useGridSelectionCheckbox, $5b9b5b5723db6ae1$export$be42ebdab07ae4c2 as useHighlightSelectionDescription, $92599c3fd427b763$export$137e594ef3218a10 as useGridSelectionAnnouncement };\n//# sourceMappingURL=module.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}