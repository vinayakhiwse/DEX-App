{"ast":null,"code":"import { InjectedConnector } from \"./chunk-BVC4KGLQ.js\";\nimport { __privateAdd, __privateGet, __privateMethod, __privateSet } from \"./chunk-MQXBDTVK.js\";\n\n// src/utils/configureChains.ts\nimport { createPublicClient, fallback, http, webSocket } from \"viem\";\nfunction configureChains(defaultChains, providers, {\n  batch = {\n    multicall: {\n      wait: 32\n    }\n  },\n  pollingInterval = 4e3,\n  rank,\n  retryCount,\n  retryDelay,\n  stallTimeout\n} = {}) {\n  if (!defaultChains.length) throw new Error(\"must have at least one chain\");\n  let chains = [];\n  const httpUrls = {};\n  const wsUrls = {};\n  for (const chain of defaultChains) {\n    let configExists = false;\n    for (const provider of providers) {\n      const apiConfig = provider(chain);\n      if (!apiConfig) continue;\n      configExists = true;\n      if (!chains.some(({\n        id\n      }) => id === chain.id)) {\n        chains = [...chains, apiConfig.chain];\n      }\n      httpUrls[chain.id] = [...(httpUrls[chain.id] || []), ...apiConfig.rpcUrls.http];\n      if (apiConfig.rpcUrls.webSocket) {\n        wsUrls[chain.id] = [...(wsUrls[chain.id] || []), ...apiConfig.rpcUrls.webSocket];\n      }\n    }\n    if (!configExists) {\n      throw new Error([`Could not find valid provider configuration for chain \"${chain.name}\".\n`, \"You may need to add `jsonRpcProvider` to `configureChains` with the chain's RPC URLs.\", \"Read more: https://wagmi.sh/core/providers/jsonRpc\"].join(\"\\n\"));\n    }\n  }\n  return {\n    chains,\n    publicClient: ({\n      chainId\n    }) => {\n      const activeChain = chains.find(x => x.id === chainId) ?? defaultChains[0];\n      const chainHttpUrls = httpUrls[activeChain.id];\n      if (!chainHttpUrls || !chainHttpUrls[0]) throw new Error(`No providers configured for chain \"${activeChain.id}\"`);\n      const publicClient = createPublicClient({\n        batch,\n        chain: activeChain,\n        transport: fallback(chainHttpUrls.map(url => http(url, {\n          timeout: stallTimeout\n        })), {\n          rank,\n          retryCount,\n          retryDelay\n        }),\n        pollingInterval\n      });\n      return Object.assign(publicClient, {\n        chains\n      });\n    },\n    webSocketPublicClient: ({\n      chainId\n    }) => {\n      const activeChain = chains.find(x => x.id === chainId) ?? defaultChains[0];\n      const chainWsUrls = wsUrls[activeChain.id];\n      if (!chainWsUrls || !chainWsUrls[0]) return void 0;\n      const publicClient = createPublicClient({\n        batch,\n        chain: activeChain,\n        transport: fallback(chainWsUrls.map(url => webSocket(url, {\n          timeout: stallTimeout\n        })), {\n          rank,\n          retryCount,\n          retryDelay\n        }),\n        pollingInterval\n      });\n      return Object.assign(publicClient, {\n        chains\n      });\n    }\n  };\n}\n\n// src/errors.ts\nimport { ConnectorNotFoundError } from \"@wagmi/connectors\";\nvar ChainMismatchError = class extends Error {\n  constructor({\n    activeChain,\n    targetChain\n  }) {\n    super(`Chain mismatch: Expected \"${targetChain}\", received \"${activeChain}\".`);\n    this.name = \"ChainMismatchError\";\n  }\n};\nvar ChainNotConfiguredError = class extends Error {\n  constructor({\n    chainId,\n    connectorId\n  }) {\n    super(`Chain \"${chainId}\" not configured${connectorId ? ` for connector \"${connectorId}\"` : \"\"}.`);\n    this.name = \"ChainNotConfigured\";\n  }\n};\nvar ConnectorAlreadyConnectedError = class extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = \"ConnectorAlreadyConnectedError\";\n    this.message = \"Connector already connected\";\n  }\n};\nvar ConfigChainsNotFound = class extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = \"ConfigChainsNotFound\";\n    this.message = \"No chains were found on the wagmi config. Some functions that require a chain may not work.\";\n  }\n};\nvar SwitchChainNotSupportedError = class extends Error {\n  constructor({\n    connector\n  }) {\n    super(`\"${connector.name}\" does not support programmatic chain switching.`);\n    this.name = \"SwitchChainNotSupportedError\";\n  }\n};\n\n// src/utils/deepEqual.ts\nfunction deepEqual(a, b) {\n  if (a === b) return true;\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    if (a.constructor !== b.constructor) return false;\n    let length;\n    let i;\n    if (Array.isArray(a) && Array.isArray(b)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;) if (!deepEqual(a[i], b[i])) return false;\n      return true;\n    }\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n    const keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n    for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n    for (i = length; i-- !== 0;) {\n      const key = keys[i];\n      if (key && !deepEqual(a[key], b[key])) return false;\n    }\n    return true;\n  }\n  return a !== a && b !== b;\n}\n\n// src/utils/deserialize.ts\nvar findAndReplace = (cacheRef, {\n  find,\n  replace\n}) => {\n  if (cacheRef && find(cacheRef)) {\n    return replace(cacheRef);\n  }\n  if (typeof cacheRef !== \"object\") {\n    return cacheRef;\n  }\n  if (Array.isArray(cacheRef)) {\n    return cacheRef.map(item => findAndReplace(item, {\n      find,\n      replace\n    }));\n  }\n  if (cacheRef instanceof Object) {\n    return Object.entries(cacheRef).reduce((curr, [key, value]) => ({\n      ...curr,\n      [key]: findAndReplace(value, {\n        find,\n        replace\n      })\n    }), {});\n  }\n  return cacheRef;\n};\nfunction deserialize(cachedString) {\n  const cache = JSON.parse(cachedString);\n  const deserializedCacheWithBigInts = findAndReplace(cache, {\n    find: data => typeof data === \"string\" && data.startsWith(\"#bigint.\"),\n    replace: data => BigInt(data.replace(\"#bigint.\", \"\"))\n  });\n  return deserializedCacheWithBigInts;\n}\n\n// src/utils/getParameters.ts\nfunction getCallParameters(args) {\n  return {\n    accessList: args.accessList,\n    account: args.account,\n    blockNumber: args.blockNumber,\n    blockTag: args.blockTag,\n    data: args.data,\n    gas: args.gas,\n    gasPrice: args.gasPrice,\n    maxFeePerGas: args.maxFeePerGas,\n    maxPriorityFeePerGas: args.maxPriorityFeePerGas,\n    nonce: args.nonce,\n    to: args.to,\n    value: args.value\n  };\n}\nfunction getSendTransactionParameters(args) {\n  return {\n    accessList: args.accessList,\n    account: args.account,\n    data: args.data,\n    gas: args.gas,\n    gasPrice: args.gasPrice,\n    maxFeePerGas: args.maxFeePerGas,\n    maxPriorityFeePerGas: args.maxPriorityFeePerGas,\n    nonce: args.nonce,\n    to: args.to,\n    value: args.value\n  };\n}\n\n// src/utils/getUnit.ts\nimport { weiUnits } from \"viem\";\nfunction getUnit(unit) {\n  if (typeof unit === \"number\") return unit;\n  if (unit === \"wei\") return 0;\n  return Math.abs(weiUnits[unit]);\n}\n\n// src/utils/serialize.ts\nfunction getReferenceKey(keys, cutoff) {\n  return keys.slice(0, cutoff).join(\".\") || \".\";\n}\nfunction getCutoff(array, value) {\n  const {\n    length\n  } = array;\n  for (let index = 0; index < length; ++index) {\n    if (array[index] === value) {\n      return index + 1;\n    }\n  }\n  return 0;\n}\nfunction createReplacer(replacer, circularReplacer) {\n  const hasReplacer = typeof replacer === \"function\";\n  const hasCircularReplacer = typeof circularReplacer === \"function\";\n  const cache = [];\n  const keys = [];\n  return function replace(key, value) {\n    if (typeof value === \"object\") {\n      if (cache.length) {\n        const thisCutoff = getCutoff(cache, this);\n        if (thisCutoff === 0) {\n          cache[cache.length] = this;\n        } else {\n          cache.splice(thisCutoff);\n          keys.splice(thisCutoff);\n        }\n        keys[keys.length] = key;\n        const valueCutoff = getCutoff(cache, value);\n        if (valueCutoff !== 0) {\n          return hasCircularReplacer ? circularReplacer.call(this, key, value, getReferenceKey(keys, valueCutoff)) : `[ref=${getReferenceKey(keys, valueCutoff)}]`;\n        }\n      } else {\n        cache[0] = value;\n        keys[0] = key;\n      }\n    }\n    return hasReplacer ? replacer.call(this, key, value) : value;\n  };\n}\nfunction serialize(value, replacer, indent, circularReplacer) {\n  return JSON.stringify(value, createReplacer((key, value_) => {\n    const value2 = typeof value_ === \"bigint\" ? `#bigint.${value_.toString()}` : value_;\n    return replacer?.(key, value2) || value2;\n  }, circularReplacer), indent ?? void 0);\n}\n\n// src/config.ts\nimport { persist, subscribeWithSelector } from \"zustand/middleware\";\nimport { createStore } from \"zustand/vanilla\";\n\n// src/storage.ts\nvar noopStorage = {\n  getItem: _key => \"\",\n  setItem: (_key, _value) => null,\n  removeItem: _key => null\n};\nfunction createStorage({\n  deserialize: deserialize2 = deserialize,\n  key: prefix = \"wagmi\",\n  serialize: serialize2 = serialize,\n  storage\n}) {\n  return {\n    ...storage,\n    getItem: (key, defaultState = null) => {\n      const value = storage.getItem(`${prefix}.${key}`);\n      try {\n        return value ? deserialize2(value) : defaultState;\n      } catch (error) {\n        console.warn(error);\n        return defaultState;\n      }\n    },\n    setItem: (key, value) => {\n      if (value === null) {\n        storage.removeItem(`${prefix}.${key}`);\n      } else {\n        try {\n          storage.setItem(`${prefix}.${key}`, serialize2(value));\n        } catch (err) {\n          console.error(err);\n        }\n      }\n    },\n    removeItem: key => storage.removeItem(`${prefix}.${key}`)\n  };\n}\n\n// src/config.ts\nvar storeKey = \"store\";\nvar _isAutoConnecting, _lastUsedConnector, _addEffects, addEffects_fn;\nvar Config = class {\n  constructor({\n    autoConnect = false,\n    connectors = [new InjectedConnector()],\n    publicClient,\n    storage = createStorage({\n      storage: typeof window !== \"undefined\" ? window.localStorage : noopStorage\n    }),\n    logger = {\n      warn: console.warn\n    },\n    webSocketPublicClient\n  }) {\n    __privateAdd(this, _addEffects);\n    this.publicClients = /* @__PURE__ */new Map();\n    this.webSocketPublicClients = /* @__PURE__ */new Map();\n    __privateAdd(this, _isAutoConnecting, void 0);\n    __privateAdd(this, _lastUsedConnector, void 0);\n    this.args = {\n      autoConnect,\n      connectors,\n      logger,\n      publicClient,\n      storage,\n      webSocketPublicClient\n    };\n    let status = \"disconnected\";\n    let chainId;\n    if (autoConnect) {\n      try {\n        const rawState = storage.getItem(storeKey);\n        const data = rawState?.state?.data;\n        status = data?.account ? \"reconnecting\" : \"connecting\";\n        chainId = data?.chain?.id;\n      } catch (_error) {}\n    }\n    const connectors_ = typeof connectors === \"function\" ? connectors() : connectors;\n    connectors_.forEach(connector => connector.setStorage(storage));\n    this.store = createStore(subscribeWithSelector(persist(() => ({\n      connectors: connectors_,\n      publicClient: this.getPublicClient({\n        chainId\n      }),\n      status,\n      webSocketPublicClient: this.getWebSocketPublicClient({\n        chainId\n      })\n    }), {\n      name: storeKey,\n      storage,\n      partialize: state => ({\n        ...(autoConnect && {\n          data: {\n            account: state?.data?.account,\n            chain: state?.data?.chain\n          }\n        }),\n        chains: state?.chains\n      }),\n      version: 2\n    })));\n    this.storage = storage;\n    __privateSet(this, _lastUsedConnector, storage?.getItem(\"wallet\"));\n    __privateMethod(this, _addEffects, addEffects_fn).call(this);\n    if (autoConnect && typeof window !== \"undefined\") setTimeout(async () => await this.autoConnect(), 0);\n  }\n  get chains() {\n    return this.store.getState().chains;\n  }\n  get connectors() {\n    return this.store.getState().connectors;\n  }\n  get connector() {\n    return this.store.getState().connector;\n  }\n  get data() {\n    return this.store.getState().data;\n  }\n  get error() {\n    return this.store.getState().error;\n  }\n  get lastUsedChainId() {\n    return this.data?.chain?.id;\n  }\n  get publicClient() {\n    return this.store.getState().publicClient;\n  }\n  get status() {\n    return this.store.getState().status;\n  }\n  get subscribe() {\n    return this.store.subscribe;\n  }\n  get webSocketPublicClient() {\n    return this.store.getState().webSocketPublicClient;\n  }\n  setState(updater) {\n    const newState = typeof updater === \"function\" ? updater(this.store.getState()) : updater;\n    this.store.setState(newState, true);\n  }\n  clearState() {\n    this.setState(x => ({\n      ...x,\n      chains: void 0,\n      connector: void 0,\n      data: void 0,\n      error: void 0,\n      status: \"disconnected\"\n    }));\n  }\n  async destroy() {\n    if (this.connector) await this.connector.disconnect?.();\n    __privateSet(this, _isAutoConnecting, false);\n    this.clearState();\n    this.store.destroy();\n  }\n  async autoConnect() {\n    if (__privateGet(this, _isAutoConnecting)) return;\n    __privateSet(this, _isAutoConnecting, true);\n    this.setState(x => ({\n      ...x,\n      status: x.data?.account ? \"reconnecting\" : \"connecting\"\n    }));\n    const sorted = __privateGet(this, _lastUsedConnector) ? [...this.connectors].sort(x => x.id === __privateGet(this, _lastUsedConnector) ? -1 : 1) : this.connectors;\n    let connected = false;\n    for (const connector of sorted) {\n      if (!connector.ready || !connector.isAuthorized) continue;\n      const isAuthorized = await connector.isAuthorized();\n      if (!isAuthorized) continue;\n      const data = await connector.connect();\n      this.setState(x => ({\n        ...x,\n        connector,\n        chains: connector?.chains,\n        data,\n        status: \"connected\"\n      }));\n      connected = true;\n      break;\n    }\n    if (!connected) this.setState(x => ({\n      ...x,\n      data: void 0,\n      status: \"disconnected\"\n    }));\n    __privateSet(this, _isAutoConnecting, false);\n    return this.data;\n  }\n  setConnectors(connectors) {\n    this.args = {\n      ...this.args,\n      connectors\n    };\n    const connectors_ = typeof connectors === \"function\" ? connectors() : connectors;\n    connectors_.forEach(connector => connector.setStorage(this.args.storage));\n    this.setState(x => ({\n      ...x,\n      connectors: connectors_\n    }));\n  }\n  getPublicClient({\n    chainId\n  } = {}) {\n    let publicClient_ = this.publicClients.get(-1);\n    if (publicClient_ && publicClient_?.chain.id === chainId) return publicClient_;\n    publicClient_ = this.publicClients.get(chainId ?? -1);\n    if (publicClient_) return publicClient_;\n    const {\n      publicClient\n    } = this.args;\n    publicClient_ = typeof publicClient === \"function\" ? publicClient({\n      chainId\n    }) : publicClient;\n    this.publicClients.set(chainId ?? -1, publicClient_);\n    return publicClient_;\n  }\n  setPublicClient(publicClient) {\n    const chainId = this.data?.chain?.id;\n    this.args = {\n      ...this.args,\n      publicClient\n    };\n    this.publicClients.clear();\n    this.setState(x => ({\n      ...x,\n      publicClient: this.getPublicClient({\n        chainId\n      })\n    }));\n  }\n  getWebSocketPublicClient({\n    chainId\n  } = {}) {\n    let webSocketPublicClient_ = this.webSocketPublicClients.get(-1);\n    if (webSocketPublicClient_ && webSocketPublicClient_?.chain.id === chainId) return webSocketPublicClient_;\n    webSocketPublicClient_ = this.webSocketPublicClients.get(chainId ?? -1);\n    if (webSocketPublicClient_) return webSocketPublicClient_;\n    const {\n      webSocketPublicClient\n    } = this.args;\n    webSocketPublicClient_ = typeof webSocketPublicClient === \"function\" ? webSocketPublicClient({\n      chainId\n    }) : webSocketPublicClient;\n    if (webSocketPublicClient_) this.webSocketPublicClients.set(chainId ?? -1, webSocketPublicClient_);\n    return webSocketPublicClient_;\n  }\n  setWebSocketPublicClient(webSocketPublicClient) {\n    const chainId = this.data?.chain?.id;\n    this.args = {\n      ...this.args,\n      webSocketPublicClient\n    };\n    this.webSocketPublicClients.clear();\n    this.setState(x => ({\n      ...x,\n      webSocketPublicClient: this.getWebSocketPublicClient({\n        chainId\n      })\n    }));\n  }\n  setLastUsedConnector(lastUsedConnector = null) {\n    this.storage?.setItem(\"wallet\", lastUsedConnector);\n  }\n};\n_isAutoConnecting = new WeakMap();\n_lastUsedConnector = new WeakMap();\n_addEffects = new WeakSet();\naddEffects_fn = function () {\n  const onChange = data => {\n    this.setState(x => ({\n      ...x,\n      data: {\n        ...x.data,\n        ...data\n      }\n    }));\n  };\n  const onDisconnect = () => {\n    this.clearState();\n  };\n  const onError = error => {\n    this.setState(x => ({\n      ...x,\n      error\n    }));\n  };\n  this.store.subscribe(({\n    connector\n  }) => connector, (connector, prevConnector) => {\n    prevConnector?.off?.(\"change\", onChange);\n    prevConnector?.off?.(\"disconnect\", onDisconnect);\n    prevConnector?.off?.(\"error\", onError);\n    if (!connector) return;\n    connector.on?.(\"change\", onChange);\n    connector.on?.(\"disconnect\", onDisconnect);\n    connector.on?.(\"error\", onError);\n  });\n  const {\n    publicClient,\n    webSocketPublicClient\n  } = this.args;\n  const subscribePublicClient = typeof publicClient === \"function\";\n  const subscribeWebSocketPublicClient = typeof webSocketPublicClient === \"function\";\n  if (subscribePublicClient || subscribeWebSocketPublicClient) this.store.subscribe(({\n    data\n  }) => data?.chain?.id, chainId => {\n    this.setState(x => ({\n      ...x,\n      publicClient: this.getPublicClient({\n        chainId\n      }),\n      webSocketPublicClient: this.getWebSocketPublicClient({\n        chainId\n      })\n    }));\n  });\n};\nvar config;\nfunction createConfig(args) {\n  const config_ = new Config(args);\n  config = config_;\n  return config_;\n}\nfunction getConfig() {\n  if (!config) {\n    throw new Error(\"No wagmi config found. Ensure you have set up a config: https://wagmi.sh/react/config\");\n  }\n  return config;\n}\n\n// src/actions/accounts/connect.ts\nasync function connect({\n  chainId,\n  connector\n}) {\n  const config2 = getConfig();\n  const activeConnector = config2.connector;\n  if (activeConnector && connector.id === activeConnector.id) throw new ConnectorAlreadyConnectedError();\n  try {\n    config2.setState(x => ({\n      ...x,\n      status: \"connecting\"\n    }));\n    const data = await connector.connect({\n      chainId\n    });\n    config2.setLastUsedConnector(connector.id);\n    config2.setState(x => ({\n      ...x,\n      connector,\n      chains: connector?.chains,\n      data,\n      status: \"connected\"\n    }));\n    config2.storage.setItem(\"connected\", true);\n    return {\n      ...data,\n      connector\n    };\n  } catch (err) {\n    config2.setState(x => {\n      return {\n        ...x,\n        status: x.connector ? \"connected\" : \"disconnected\"\n      };\n    });\n    throw err;\n  }\n}\n\n// src/actions/accounts/disconnect.ts\nasync function disconnect() {\n  const config2 = getConfig();\n  if (config2.connector) await config2.connector.disconnect();\n  config2.clearState();\n  config2.storage.removeItem(\"connected\");\n}\n\n// src/actions/accounts/fetchBalance.ts\nimport { ContractFunctionExecutionError as ContractFunctionExecutionError3, formatUnits as formatUnits2, hexToString as hexToString2, trim as trim2 } from \"viem\";\n\n// src/constants/abis.ts\nvar erc20ABI = [{\n  type: \"event\",\n  name: \"Approval\",\n  inputs: [{\n    indexed: true,\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    name: \"value\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"event\",\n  name: \"Transfer\",\n  inputs: [{\n    indexed: true,\n    name: \"from\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"to\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    name: \"value\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"allowance\",\n  stateMutability: \"view\",\n  inputs: [{\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    name: \"spender\",\n    type: \"address\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"approve\",\n  stateMutability: \"nonpayable\",\n  inputs: [{\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"bool\"\n  }]\n}, {\n  type: \"function\",\n  name: \"balanceOf\",\n  stateMutability: \"view\",\n  inputs: [{\n    name: \"account\",\n    type: \"address\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"decimals\",\n  stateMutability: \"view\",\n  inputs: [],\n  outputs: [{\n    name: \"\",\n    type: \"uint8\"\n  }]\n}, {\n  type: \"function\",\n  name: \"name\",\n  stateMutability: \"view\",\n  inputs: [],\n  outputs: [{\n    name: \"\",\n    type: \"string\"\n  }]\n}, {\n  type: \"function\",\n  name: \"symbol\",\n  stateMutability: \"view\",\n  inputs: [],\n  outputs: [{\n    name: \"\",\n    type: \"string\"\n  }]\n}, {\n  type: \"function\",\n  name: \"totalSupply\",\n  stateMutability: \"view\",\n  inputs: [],\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"transfer\",\n  stateMutability: \"nonpayable\",\n  inputs: [{\n    name: \"recipient\",\n    type: \"address\"\n  }, {\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"bool\"\n  }]\n}, {\n  type: \"function\",\n  name: \"transferFrom\",\n  stateMutability: \"nonpayable\",\n  inputs: [{\n    name: \"sender\",\n    type: \"address\"\n  }, {\n    name: \"recipient\",\n    type: \"address\"\n  }, {\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"bool\"\n  }]\n}];\nvar erc20ABI_bytes32 = [{\n  type: \"event\",\n  name: \"Approval\",\n  inputs: [{\n    indexed: true,\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    name: \"value\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"event\",\n  name: \"Transfer\",\n  inputs: [{\n    indexed: true,\n    name: \"from\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"to\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    name: \"value\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"allowance\",\n  stateMutability: \"view\",\n  inputs: [{\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    name: \"spender\",\n    type: \"address\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"approve\",\n  stateMutability: \"nonpayable\",\n  inputs: [{\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"bool\"\n  }]\n}, {\n  type: \"function\",\n  name: \"balanceOf\",\n  stateMutability: \"view\",\n  inputs: [{\n    name: \"account\",\n    type: \"address\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"decimals\",\n  stateMutability: \"view\",\n  inputs: [],\n  outputs: [{\n    name: \"\",\n    type: \"uint8\"\n  }]\n}, {\n  type: \"function\",\n  name: \"name\",\n  stateMutability: \"view\",\n  inputs: [],\n  outputs: [{\n    name: \"\",\n    type: \"bytes32\"\n  }]\n}, {\n  type: \"function\",\n  name: \"symbol\",\n  stateMutability: \"view\",\n  inputs: [],\n  outputs: [{\n    name: \"\",\n    type: \"bytes32\"\n  }]\n}, {\n  type: \"function\",\n  name: \"totalSupply\",\n  stateMutability: \"view\",\n  inputs: [],\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"transfer\",\n  stateMutability: \"nonpayable\",\n  inputs: [{\n    name: \"recipient\",\n    type: \"address\"\n  }, {\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"bool\"\n  }]\n}, {\n  type: \"function\",\n  name: \"transferFrom\",\n  stateMutability: \"nonpayable\",\n  inputs: [{\n    name: \"sender\",\n    type: \"address\"\n  }, {\n    name: \"recipient\",\n    type: \"address\"\n  }, {\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"bool\"\n  }]\n}];\nvar erc721ABI = [{\n  type: \"event\",\n  name: \"Approval\",\n  inputs: [{\n    indexed: true,\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"tokenId\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"event\",\n  name: \"ApprovalForAll\",\n  inputs: [{\n    indexed: true,\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"operator\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    name: \"approved\",\n    type: \"bool\"\n  }]\n}, {\n  type: \"event\",\n  name: \"Transfer\",\n  inputs: [{\n    indexed: true,\n    name: \"from\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"to\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"tokenId\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"approve\",\n  stateMutability: \"payable\",\n  inputs: [{\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  outputs: []\n}, {\n  type: \"function\",\n  name: \"balanceOf\",\n  stateMutability: \"view\",\n  inputs: [{\n    name: \"account\",\n    type: \"address\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"getApproved\",\n  stateMutability: \"view\",\n  inputs: [{\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"address\"\n  }]\n}, {\n  type: \"function\",\n  name: \"isApprovedForAll\",\n  stateMutability: \"view\",\n  inputs: [{\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    name: \"operator\",\n    type: \"address\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"bool\"\n  }]\n}, {\n  type: \"function\",\n  name: \"name\",\n  stateMutability: \"view\",\n  inputs: [],\n  outputs: [{\n    name: \"\",\n    type: \"string\"\n  }]\n}, {\n  type: \"function\",\n  name: \"ownerOf\",\n  stateMutability: \"view\",\n  inputs: [{\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  outputs: [{\n    name: \"owner\",\n    type: \"address\"\n  }]\n}, {\n  type: \"function\",\n  name: \"safeTransferFrom\",\n  stateMutability: \"payable\",\n  inputs: [{\n    name: \"from\",\n    type: \"address\"\n  }, {\n    name: \"to\",\n    type: \"address\"\n  }, {\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  outputs: []\n}, {\n  type: \"function\",\n  name: \"safeTransferFrom\",\n  stateMutability: \"nonpayable\",\n  inputs: [{\n    name: \"from\",\n    type: \"address\"\n  }, {\n    name: \"to\",\n    type: \"address\"\n  }, {\n    name: \"id\",\n    type: \"uint256\"\n  }, {\n    name: \"data\",\n    type: \"bytes\"\n  }],\n  outputs: []\n}, {\n  type: \"function\",\n  name: \"setApprovalForAll\",\n  stateMutability: \"nonpayable\",\n  inputs: [{\n    name: \"operator\",\n    type: \"address\"\n  }, {\n    name: \"approved\",\n    type: \"bool\"\n  }],\n  outputs: []\n}, {\n  type: \"function\",\n  name: \"symbol\",\n  stateMutability: \"view\",\n  inputs: [],\n  outputs: [{\n    name: \"\",\n    type: \"string\"\n  }]\n}, {\n  type: \"function\",\n  name: \"tokenByIndex\",\n  stateMutability: \"view\",\n  inputs: [{\n    name: \"index\",\n    type: \"uint256\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"tokenByIndex\",\n  stateMutability: \"view\",\n  inputs: [{\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    name: \"index\",\n    type: \"uint256\"\n  }],\n  outputs: [{\n    name: \"tokenId\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"tokenURI\",\n  stateMutability: \"view\",\n  inputs: [{\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"string\"\n  }]\n}, {\n  type: \"function\",\n  name: \"totalSupply\",\n  stateMutability: \"view\",\n  inputs: [],\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"transferFrom\",\n  stateMutability: \"payable\",\n  inputs: [{\n    name: \"sender\",\n    type: \"address\"\n  }, {\n    name: \"recipient\",\n    type: \"address\"\n  }, {\n    name: \"tokeId\",\n    type: \"uint256\"\n  }],\n  outputs: []\n}];\nvar erc4626ABI = [{\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    name: \"value\",\n    type: \"uint256\"\n  }],\n  name: \"Approval\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    name: \"sender\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"receiver\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    name: \"assets\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    name: \"shares\",\n    type: \"uint256\"\n  }],\n  name: \"Deposit\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    name: \"from\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"to\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    name: \"value\",\n    type: \"uint256\"\n  }],\n  name: \"Transfer\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    name: \"sender\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"receiver\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    name: \"assets\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    name: \"shares\",\n    type: \"uint256\"\n  }],\n  name: \"Withdraw\",\n  type: \"event\"\n}, {\n  inputs: [{\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    name: \"spender\",\n    type: \"address\"\n  }],\n  name: \"allowance\",\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"approve\",\n  outputs: [{\n    name: \"\",\n    type: \"bool\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"asset\",\n  outputs: [{\n    name: \"assetTokenAddress\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"account\",\n    type: \"address\"\n  }],\n  name: \"balanceOf\",\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"shares\",\n    type: \"uint256\"\n  }],\n  name: \"convertToAssets\",\n  outputs: [{\n    name: \"assets\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"assets\",\n    type: \"uint256\"\n  }],\n  name: \"convertToShares\",\n  outputs: [{\n    name: \"shares\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"assets\",\n    type: \"uint256\"\n  }, {\n    name: \"receiver\",\n    type: \"address\"\n  }],\n  name: \"deposit\",\n  outputs: [{\n    name: \"shares\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"caller\",\n    type: \"address\"\n  }],\n  name: \"maxDeposit\",\n  outputs: [{\n    name: \"maxAssets\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"caller\",\n    type: \"address\"\n  }],\n  name: \"maxMint\",\n  outputs: [{\n    name: \"maxShares\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"owner\",\n    type: \"address\"\n  }],\n  name: \"maxRedeem\",\n  outputs: [{\n    name: \"maxShares\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"owner\",\n    type: \"address\"\n  }],\n  name: \"maxWithdraw\",\n  outputs: [{\n    name: \"maxAssets\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"shares\",\n    type: \"uint256\"\n  }, {\n    name: \"receiver\",\n    type: \"address\"\n  }],\n  name: \"mint\",\n  outputs: [{\n    name: \"assets\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"assets\",\n    type: \"uint256\"\n  }],\n  name: \"previewDeposit\",\n  outputs: [{\n    name: \"shares\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"shares\",\n    type: \"uint256\"\n  }],\n  name: \"previewMint\",\n  outputs: [{\n    name: \"assets\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"shares\",\n    type: \"uint256\"\n  }],\n  name: \"previewRedeem\",\n  outputs: [{\n    name: \"assets\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"assets\",\n    type: \"uint256\"\n  }],\n  name: \"previewWithdraw\",\n  outputs: [{\n    name: \"shares\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"shares\",\n    type: \"uint256\"\n  }, {\n    name: \"receiver\",\n    type: \"address\"\n  }, {\n    name: \"owner\",\n    type: \"address\"\n  }],\n  name: \"redeem\",\n  outputs: [{\n    name: \"assets\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"totalAssets\",\n  outputs: [{\n    name: \"totalManagedAssets\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"totalSupply\",\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"to\",\n    type: \"address\"\n  }, {\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"transfer\",\n  outputs: [{\n    name: \"\",\n    type: \"bool\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"from\",\n    type: \"address\"\n  }, {\n    name: \"to\",\n    type: \"address\"\n  }, {\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"transferFrom\",\n  outputs: [{\n    name: \"\",\n    type: \"bool\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"assets\",\n    type: \"uint256\"\n  }, {\n    name: \"receiver\",\n    type: \"address\"\n  }, {\n    name: \"owner\",\n    type: \"address\"\n  }],\n  name: \"withdraw\",\n  outputs: [{\n    name: \"shares\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}];\n\n// src/actions/contracts/fetchToken.ts\nimport { ContractFunctionExecutionError, formatUnits, hexToString, trim } from \"viem\";\nasync function fetchToken({\n  address,\n  chainId,\n  formatUnits: unit = 18\n}) {\n  async function fetchToken_({\n    abi\n  }) {\n    const erc20Config = {\n      address,\n      abi,\n      chainId\n    };\n    const [decimals, name, symbol, totalSupply] = await readContracts({\n      allowFailure: false,\n      contracts: [{\n        ...erc20Config,\n        functionName: \"decimals\"\n      }, {\n        ...erc20Config,\n        functionName: \"name\"\n      }, {\n        ...erc20Config,\n        functionName: \"symbol\"\n      }, {\n        ...erc20Config,\n        functionName: \"totalSupply\"\n      }]\n    });\n    return {\n      address,\n      decimals,\n      name,\n      symbol,\n      totalSupply: {\n        formatted: formatUnits(totalSupply, getUnit(unit)),\n        value: totalSupply\n      }\n    };\n  }\n  try {\n    return await fetchToken_({\n      abi: erc20ABI\n    });\n  } catch (err) {\n    if (err instanceof ContractFunctionExecutionError) {\n      const {\n        name,\n        symbol,\n        ...rest\n      } = await fetchToken_({\n        abi: erc20ABI_bytes32\n      });\n      return {\n        name: hexToString(trim(name, {\n          dir: \"right\"\n        })),\n        symbol: hexToString(trim(symbol, {\n          dir: \"right\"\n        })),\n        ...rest\n      };\n    }\n    throw err;\n  }\n}\n\n// src/actions/viem/getPublicClient.ts\nfunction getPublicClient({\n  chainId\n} = {}) {\n  const config2 = getConfig();\n  if (chainId) return config2.getPublicClient({\n    chainId\n  }) || config2.publicClient;\n  return config2.publicClient;\n}\n\n// src/actions/viem/getWalletClient.ts\nasync function getWalletClient({\n  chainId\n} = {}) {\n  const config2 = getConfig();\n  const walletClient = (await config2.connector?.getWalletClient?.({\n    chainId\n  })) || null;\n  return walletClient;\n}\n\n// src/actions/viem/getWebSocketPublicClient.ts\nfunction getWebSocketPublicClient({\n  chainId\n} = {}) {\n  const config2 = getConfig();\n  if (chainId) return config2.getWebSocketPublicClient({\n    chainId\n  }) || config2.webSocketPublicClient;\n  return config2.webSocketPublicClient;\n}\n\n// src/actions/viem/watchPublicClient.ts\nfunction watchPublicClient(args, callback) {\n  const config2 = getConfig();\n  const handleChange = async () => callback(getPublicClient(args));\n  const unsubscribe = config2.subscribe(({\n    publicClient\n  }) => publicClient, handleChange);\n  return unsubscribe;\n}\n\n// src/actions/viem/watchWalletClient.ts\nimport { shallow } from \"zustand/shallow\";\nfunction watchWalletClient({\n  chainId\n}, callback) {\n  const config2 = getConfig();\n  const handleChange = async ({\n    chainId: chainId_\n  }) => {\n    if (chainId && chainId_ && chainId !== chainId_) return;\n    const walletClient = await getWalletClient({\n      chainId\n    });\n    if (!getConfig().connector) return callback(null);\n    return callback(walletClient);\n  };\n  const unsubscribe = config2.subscribe(({\n    data,\n    connector\n  }) => ({\n    account: data?.account,\n    chainId: data?.chain?.id,\n    connector\n  }), handleChange, {\n    equalityFn: shallow\n  });\n  return unsubscribe;\n}\n\n// src/actions/viem/watchWebSocketPublicClient.ts\nfunction watchWebSocketPublicClient(args, callback) {\n  const config2 = getConfig();\n  const handleChange = async () => callback(getWebSocketPublicClient(args));\n  const unsubscribe = config2.subscribe(({\n    webSocketPublicClient\n  }) => webSocketPublicClient, handleChange);\n  return unsubscribe;\n}\n\n// src/actions/contracts/prepareWriteContract.ts\nasync function prepareWriteContract({\n  abi,\n  address,\n  args,\n  chainId,\n  functionName,\n  walletClient: walletClient_,\n  ...config2\n}) {\n  const publicClient = getPublicClient({\n    chainId\n  });\n  const walletClient = walletClient_ ?? (await getWalletClient({\n    chainId\n  }));\n  if (!walletClient) throw new ConnectorNotFoundError();\n  if (chainId) assertActiveChain({\n    chainId\n  });\n  const {\n    account,\n    accessList,\n    blockNumber,\n    blockTag,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    value\n  } = getCallParameters(config2);\n  const {\n    result,\n    request\n  } = await publicClient.simulateContract({\n    abi,\n    address,\n    functionName,\n    args,\n    account: account || walletClient.account,\n    accessList,\n    blockNumber,\n    blockTag,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    value\n  });\n  const minimizedAbi = abi.filter(abiItem => \"name\" in abiItem && abiItem.name === functionName);\n  return {\n    mode: \"prepared\",\n    request: {\n      ...request,\n      abi: minimizedAbi,\n      chainId\n    },\n    result\n  };\n}\n\n// src/actions/contracts/getContract.ts\nimport { getContract as getContract_ } from \"viem\";\nfunction getContract({\n  address,\n  abi,\n  chainId,\n  walletClient\n}) {\n  const publicClient = getPublicClient({\n    chainId\n  });\n  return getContract_({\n    address,\n    abi,\n    publicClient,\n    walletClient\n  });\n}\n\n// src/actions/contracts/multicall.ts\nasync function multicall({\n  chainId,\n  contracts,\n  blockNumber,\n  blockTag,\n  ...args\n}) {\n  const publicClient = getPublicClient({\n    chainId\n  });\n  if (!publicClient.chains) throw new ConfigChainsNotFound();\n  if (chainId && publicClient.chain.id !== chainId) throw new ChainNotConfiguredError({\n    chainId\n  });\n  return publicClient.multicall({\n    allowFailure: args.allowFailure ?? true,\n    blockNumber,\n    blockTag,\n    contracts\n  });\n}\n\n// src/actions/contracts/readContract.ts\nasync function readContract({\n  address,\n  account,\n  chainId,\n  abi,\n  args,\n  functionName,\n  blockNumber,\n  blockTag\n}) {\n  const publicClient = getPublicClient({\n    chainId\n  });\n  return publicClient.readContract({\n    abi,\n    address,\n    account,\n    functionName,\n    args,\n    blockNumber,\n    blockTag\n  });\n}\n\n// src/actions/contracts/readContracts.ts\nimport { ContractFunctionExecutionError as ContractFunctionExecutionError2 } from \"viem\";\nasync function readContracts({\n  contracts,\n  blockNumber,\n  blockTag,\n  ...args\n}) {\n  const {\n    allowFailure = true\n  } = args;\n  try {\n    const publicClient = getPublicClient();\n    const contractsByChainId = contracts.reduce((contracts2, contract, index) => {\n      const chainId = contract.chainId ?? publicClient.chain.id;\n      return {\n        ...contracts2,\n        [chainId]: [...(contracts2[chainId] || []), {\n          contract,\n          index\n        }]\n      };\n    }, {});\n    const promises = () => Object.entries(contractsByChainId).map(([chainId, contracts2]) => multicall({\n      allowFailure,\n      chainId: parseInt(chainId),\n      contracts: contracts2.map(({\n        contract\n      }) => contract),\n      blockNumber,\n      blockTag\n    }));\n    const multicallResults = (await Promise.all(promises())).flat();\n    const resultIndexes = Object.values(contractsByChainId).flatMap(contracts2 => contracts2.map(({\n      index\n    }) => index));\n    return multicallResults.reduce((results, result, index) => {\n      if (results) results[resultIndexes[index]] = result;\n      return results;\n    }, []);\n  } catch (err) {\n    if (err instanceof ContractFunctionExecutionError2) throw err;\n    const promises = () => contracts.map(contract => readContract({\n      ...contract,\n      blockNumber,\n      blockTag\n    }));\n    if (allowFailure) return (await Promise.allSettled(promises())).map(result => {\n      if (result.status === \"fulfilled\") return {\n        result: result.value,\n        status: \"success\"\n      };\n      return {\n        error: result.reason,\n        result: void 0,\n        status: \"failure\"\n      };\n    });\n    return await Promise.all(promises());\n  }\n}\n\n// src/actions/contracts/watchContractEvent.ts\nimport { shallow as shallow2 } from \"zustand/shallow\";\nfunction watchContractEvent({\n  address,\n  abi,\n  chainId,\n  eventName\n}, callback) {\n  let unwatch;\n  const watchEvent = async () => {\n    if (unwatch) unwatch();\n    const publicClient = getWebSocketPublicClient({\n      chainId\n    }) || getPublicClient({\n      chainId\n    });\n    unwatch = publicClient.watchContractEvent({\n      address,\n      abi,\n      eventName,\n      onLogs: callback\n    });\n  };\n  watchEvent();\n  const config2 = getConfig();\n  const unsubscribe = config2.subscribe(({\n    publicClient,\n    webSocketPublicClient\n  }) => ({\n    publicClient,\n    webSocketPublicClient\n  }), watchEvent, {\n    equalityFn: shallow2\n  });\n  return () => {\n    unwatch?.();\n    unsubscribe();\n  };\n}\n\n// src/actions/network-status/watchBlockNumber.ts\nimport { shallow as shallow3 } from \"zustand/shallow\";\nfunction watchBlockNumber(args, callback) {\n  let unwatch;\n  const createListener = publicClient => {\n    if (unwatch) unwatch();\n    unwatch = publicClient.watchBlockNumber({\n      onBlockNumber: callback,\n      emitOnBegin: true,\n      poll: true\n    });\n  };\n  const publicClient_ = getWebSocketPublicClient({\n    chainId: args.chainId\n  }) ?? getPublicClient({\n    chainId: args.chainId\n  });\n  if (args.listen) createListener(publicClient_);\n  const config2 = getConfig();\n  const unsubscribe = config2.subscribe(({\n    publicClient,\n    webSocketPublicClient\n  }) => ({\n    publicClient,\n    webSocketPublicClient\n  }), async ({\n    publicClient,\n    webSocketPublicClient\n  }) => {\n    const publicClient_2 = webSocketPublicClient ?? publicClient;\n    if (args.listen && !args.chainId && publicClient_2) {\n      createListener(publicClient_2);\n    }\n  }, {\n    equalityFn: shallow3\n  });\n  return () => {\n    unsubscribe();\n    unwatch?.();\n  };\n}\n\n// src/actions/contracts/watchMulticall.ts\nfunction watchMulticall(args, callback) {\n  const config2 = getConfig();\n  const handleChange = async () => callback(await multicall(args));\n  const unwatch = args.listenToBlock ? watchBlockNumber({\n    listen: true\n  }, handleChange) : void 0;\n  const unsubscribe = config2.subscribe(({\n    publicClient\n  }) => publicClient, handleChange);\n  return () => {\n    unsubscribe();\n    unwatch?.();\n  };\n}\n\n// src/actions/contracts/watchReadContract.ts\nfunction watchReadContract(args, callback) {\n  const config2 = getConfig();\n  const handleChange = async () => callback(await readContract(args));\n  const unwatch = args.listenToBlock ? watchBlockNumber({\n    listen: true\n  }, handleChange) : void 0;\n  const unsubscribe = config2.subscribe(({\n    publicClient\n  }) => publicClient, handleChange);\n  return () => {\n    unsubscribe();\n    unwatch?.();\n  };\n}\n\n// src/actions/contracts/watchReadContracts.ts\nfunction watchReadContracts(args, callback) {\n  const config2 = getConfig();\n  const handleChange = async () => callback(await readContracts(args));\n  const unwatch = args.listenToBlock ? watchBlockNumber({\n    listen: true\n  }, handleChange) : void 0;\n  const unsubscribe = config2.subscribe(({\n    publicClient\n  }) => publicClient, handleChange);\n  return () => {\n    unsubscribe();\n    unwatch?.();\n  };\n}\n\n// src/actions/contracts/writeContract.ts\nasync function writeContract(config2) {\n  const walletClient = await getWalletClient({\n    chainId: config2.chainId\n  });\n  if (!walletClient) throw new ConnectorNotFoundError();\n  if (config2.chainId) assertActiveChain({\n    chainId: config2.chainId\n  });\n  let request;\n  if (config2.mode === \"prepared\") {\n    request = config2.request;\n  } else {\n    const {\n      chainId: _,\n      mode: __,\n      ...args\n    } = config2;\n    const res = await prepareWriteContract(args);\n    request = res.request;\n  }\n  const hash = await walletClient.writeContract({\n    ...request,\n    chain: config2.chainId ? {\n      id: config2.chainId\n    } : null\n  });\n  return {\n    hash\n  };\n}\n\n// src/actions/accounts/fetchBalance.ts\nasync function fetchBalance({\n  address,\n  chainId,\n  formatUnits: unit,\n  token\n}) {\n  const config2 = getConfig();\n  const publicClient = getPublicClient({\n    chainId\n  });\n  if (token) {\n    const fetchContractBalance = async ({\n      abi\n    }) => {\n      const erc20Config = {\n        abi,\n        address: token,\n        chainId\n      };\n      const [value2, decimals, symbol] = await readContracts({\n        allowFailure: false,\n        contracts: [{\n          ...erc20Config,\n          functionName: \"balanceOf\",\n          args: [address]\n        }, {\n          ...erc20Config,\n          functionName: \"decimals\"\n        }, {\n          ...erc20Config,\n          functionName: \"symbol\"\n        }]\n      });\n      return {\n        decimals,\n        formatted: formatUnits2(value2 ?? \"0\", getUnit(unit ?? decimals)),\n        symbol,\n        value: value2\n      };\n    };\n    try {\n      return await fetchContractBalance({\n        abi: erc20ABI\n      });\n    } catch (err) {\n      if (err instanceof ContractFunctionExecutionError3) {\n        const {\n          symbol,\n          ...rest\n        } = await fetchContractBalance({\n          abi: erc20ABI_bytes32\n        });\n        return {\n          symbol: hexToString2(trim2(symbol, {\n            dir: \"right\"\n          })),\n          ...rest\n        };\n      }\n      throw err;\n    }\n  }\n  const chains = [...(config2.publicClient.chains || []), ...(config2.chains ?? [])];\n  const value = await publicClient.getBalance({\n    address\n  });\n  const chain = chains.find(x => x.id === publicClient.chain.id);\n  return {\n    decimals: chain?.nativeCurrency.decimals ?? 18,\n    formatted: formatUnits2(value ?? \"0\", getUnit(unit ?? 18)),\n    symbol: chain?.nativeCurrency.symbol ?? \"ETH\",\n    value\n  };\n}\n\n// src/actions/accounts/getAccount.ts\nfunction getAccount() {\n  const {\n    data,\n    connector,\n    status\n  } = getConfig();\n  switch (status) {\n    case \"connected\":\n      return {\n        address: data?.account,\n        connector,\n        isConnected: true,\n        isConnecting: false,\n        isDisconnected: false,\n        isReconnecting: false,\n        status\n      };\n    case \"reconnecting\":\n      return {\n        address: data?.account,\n        connector,\n        isConnected: !!data?.account,\n        isConnecting: false,\n        isDisconnected: false,\n        isReconnecting: true,\n        status\n      };\n    case \"connecting\":\n      return {\n        address: data?.account,\n        connector,\n        isConnected: false,\n        isConnecting: true,\n        isDisconnected: false,\n        isReconnecting: false,\n        status\n      };\n    case \"disconnected\":\n      return {\n        address: void 0,\n        connector: void 0,\n        isConnected: false,\n        isConnecting: false,\n        isDisconnected: true,\n        isReconnecting: false,\n        status\n      };\n  }\n}\n\n// src/actions/accounts/getNetwork.ts\nfunction getNetwork() {\n  const config2 = getConfig();\n  const chainId = config2.data?.chain?.id;\n  const activeChains = config2.chains ?? [];\n  const activeChain = [...(config2.publicClient?.chains || []), ...activeChains].find(x => x.id === chainId) ?? {\n    id: chainId,\n    name: `Chain ${chainId}`,\n    network: `${chainId}`,\n    nativeCurrency: {\n      name: \"Ether\",\n      decimals: 18,\n      symbol: \"ETH\"\n    },\n    rpcUrls: {\n      default: {\n        http: [\"\"]\n      },\n      public: {\n        http: [\"\"]\n      }\n    }\n  };\n  return {\n    chain: chainId ? {\n      ...activeChain,\n      ...config2.data?.chain,\n      id: chainId\n    } : void 0,\n    chains: activeChains\n  };\n}\n\n// src/actions/accounts/signMessage.ts\nasync function signMessage(args) {\n  const walletClient = await getWalletClient();\n  if (!walletClient) throw new ConnectorNotFoundError();\n  return await walletClient.signMessage({\n    message: args.message\n  });\n}\n\n// src/actions/accounts/signTypedData.ts\nasync function signTypedData({\n  domain,\n  message,\n  primaryType,\n  types\n}) {\n  const walletClient = await getWalletClient();\n  if (!walletClient) throw new ConnectorNotFoundError();\n  const {\n    chainId\n  } = domain;\n  if (chainId) assertActiveChain({\n    chainId\n  });\n  return walletClient.signTypedData({\n    message,\n    primaryType,\n    types,\n    domain\n  });\n}\n\n// src/actions/accounts/switchNetwork.ts\nasync function switchNetwork({\n  chainId\n}) {\n  const {\n    connector\n  } = getConfig();\n  if (!connector) throw new ConnectorNotFoundError();\n  if (!connector.switchChain) throw new SwitchChainNotSupportedError({\n    connector\n  });\n  return connector.switchChain(chainId);\n}\n\n// src/actions/accounts/watchAccount.ts\nimport { shallow as shallow4 } from \"zustand/shallow\";\nfunction watchAccount(callback, {\n  selector = x => x\n} = {}) {\n  const config2 = getConfig();\n  const handleChange = () => callback(getAccount());\n  const unsubscribe = config2.subscribe(({\n    data,\n    connector,\n    status\n  }) => selector({\n    address: data?.account,\n    connector,\n    status\n  }), handleChange, {\n    equalityFn: shallow4\n  });\n  return unsubscribe;\n}\n\n// src/actions/accounts/watchNetwork.ts\nimport { shallow as shallow5 } from \"zustand/shallow\";\nfunction watchNetwork(callback, {\n  selector = x => x\n} = {}) {\n  const config2 = getConfig();\n  const handleChange = () => callback(getNetwork());\n  const unsubscribe = config2.subscribe(({\n    data,\n    chains\n  }) => selector({\n    chainId: data?.chain?.id,\n    chains\n  }), handleChange, {\n    equalityFn: shallow5\n  });\n  return unsubscribe;\n}\n\n// src/actions/ens/fetchEnsAddress.ts\nimport { getAddress } from \"viem\";\nasync function fetchEnsAddress({\n  chainId,\n  name\n}) {\n  const {\n    normalize\n  } = await import(\"viem/ens\");\n  const publicClient = getPublicClient({\n    chainId\n  });\n  const address = await publicClient.getEnsAddress({\n    name: normalize(name)\n  });\n  try {\n    if (address === \"0x0000000000000000000000000000000000000000\") return null;\n    return address ? getAddress(address) : null;\n  } catch (_error) {\n    return null;\n  }\n}\n\n// src/actions/ens/fetchEnsAvatar.ts\nasync function fetchEnsAvatar({\n  name,\n  chainId\n}) {\n  const {\n    normalize\n  } = await import(\"viem/ens\");\n  const publicClient = getPublicClient({\n    chainId\n  });\n  const avatar = await publicClient.getEnsAvatar({\n    name: normalize(name)\n  });\n  return avatar;\n}\n\n// src/actions/ens/fetchEnsName.ts\nimport { getAddress as getAddress2 } from \"viem\";\nasync function fetchEnsName({\n  address,\n  chainId\n}) {\n  const publicClient = getPublicClient({\n    chainId\n  });\n  return publicClient.getEnsName({\n    address: getAddress2(address)\n  });\n}\n\n// src/actions/ens/fetchEnsResolver.ts\nasync function fetchEnsResolver({\n  chainId,\n  name\n}) {\n  const {\n    normalize\n  } = await import(\"viem/ens\");\n  const publicClient = getPublicClient({\n    chainId\n  });\n  const resolver = await publicClient.getEnsResolver({\n    name: normalize(name)\n  });\n  return resolver;\n}\n\n// src/actions/network-status/fetchBlockNumber.ts\nasync function fetchBlockNumber({\n  chainId\n} = {}) {\n  const publicClient = getPublicClient({\n    chainId\n  });\n  const blockNumber = await publicClient.getBlockNumber();\n  return blockNumber;\n}\n\n// src/actions/network-status/fetchFeeData.ts\nimport { formatUnits as formatUnits3, parseGwei } from \"viem\";\nasync function fetchFeeData({\n  chainId,\n  formatUnits: units = \"gwei\"\n} = {}) {\n  const publicClient = getPublicClient({\n    chainId\n  });\n  const block = await publicClient.getBlock();\n  let gasPrice = null;\n  try {\n    gasPrice = await publicClient.getGasPrice();\n  } catch {}\n  let lastBaseFeePerGas = null;\n  let maxFeePerGas = null;\n  let maxPriorityFeePerGas = null;\n  if (block?.baseFeePerGas) {\n    lastBaseFeePerGas = block.baseFeePerGas;\n    maxPriorityFeePerGas = parseGwei(\"1\");\n    maxFeePerGas = block.baseFeePerGas * 2n + maxPriorityFeePerGas;\n  }\n  const unit = getUnit(units);\n  const formatted = {\n    gasPrice: gasPrice ? formatUnits3(gasPrice, unit) : null,\n    maxFeePerGas: maxFeePerGas ? formatUnits3(maxFeePerGas, unit) : null,\n    maxPriorityFeePerGas: maxPriorityFeePerGas ? formatUnits3(maxPriorityFeePerGas, unit) : null\n  };\n  return {\n    lastBaseFeePerGas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    formatted\n  };\n}\n\n// src/actions/transactions/fetchTransaction.ts\nasync function fetchTransaction({\n  chainId,\n  hash\n}) {\n  const publicClient = getPublicClient({\n    chainId\n  });\n  return publicClient.getTransaction({\n    hash\n  });\n}\n\n// src/actions/transactions/prepareSendTransaction.ts\nimport { isAddress } from \"viem\";\nasync function prepareSendTransaction({\n  accessList,\n  account,\n  chainId,\n  data,\n  gas: gas_,\n  gasPrice,\n  maxFeePerGas,\n  maxPriorityFeePerGas,\n  nonce,\n  to: to_,\n  value,\n  walletClient: walletClient_\n}) {\n  const publicClient = getPublicClient({\n    chainId\n  });\n  const walletClient = walletClient_ ?? (await getWalletClient({\n    chainId\n  }));\n  if (!walletClient) throw new ConnectorNotFoundError();\n  if (chainId) assertActiveChain({\n    chainId\n  });\n  const to = (to_ && !isAddress(to_) ? await fetchEnsAddress({\n    name: to_\n  }) : to_) || void 0;\n  if (to && !isAddress(to)) throw new Error(\"Invalid address\");\n  const gas = typeof gas_ === \"undefined\" ? await publicClient.estimateGas({\n    accessList,\n    account: walletClient.account,\n    data,\n    gas: gas_ ?? void 0,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    to,\n    value\n  }) : gas_ || void 0;\n  return {\n    accessList,\n    account,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    mode: \"prepared\",\n    nonce,\n    to,\n    value,\n    ...(chainId ? {\n      chainId\n    } : {})\n  };\n}\n\n// src/actions/transactions/sendTransaction.ts\nasync function sendTransaction({\n  accessList,\n  account,\n  chainId,\n  data,\n  gas,\n  gasPrice,\n  maxFeePerGas,\n  maxPriorityFeePerGas,\n  mode,\n  nonce,\n  to,\n  value\n}) {\n  const walletClient = await getWalletClient({\n    chainId\n  });\n  if (!walletClient) throw new ConnectorNotFoundError();\n  if (chainId) assertActiveChain({\n    chainId\n  });\n  let args;\n  if (mode === \"prepared\") {\n    args = {\n      account,\n      accessList,\n      chain: null,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value\n    };\n  } else {\n    args = await prepareSendTransaction({\n      accessList,\n      account,\n      chainId,\n      data,\n      gas: gas || null,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value\n    });\n  }\n  const hash = await walletClient.sendTransaction({\n    ...args,\n    chain: chainId ? {\n      id: chainId\n    } : null\n  });\n  return {\n    hash\n  };\n}\n\n// src/actions/transactions/waitForTransaction.ts\nimport { hexToString as hexToString3 } from \"viem\";\nasync function waitForTransaction({\n  chainId,\n  confirmations = 1,\n  hash,\n  onReplaced,\n  timeout = 0\n}) {\n  const publicClient = getPublicClient({\n    chainId\n  });\n  const receipt = await publicClient.waitForTransactionReceipt({\n    hash,\n    confirmations,\n    onReplaced,\n    timeout\n  });\n  if (receipt.status === \"reverted\") {\n    const txn = await publicClient.getTransaction({\n      hash: receipt.transactionHash\n    });\n    const code = await publicClient.call({\n      ...txn,\n      gasPrice: txn.type !== \"eip1559\" ? txn.gasPrice : void 0,\n      maxFeePerGas: txn.type === \"eip1559\" ? txn.maxFeePerGas : void 0,\n      maxPriorityFeePerGas: txn.type === \"eip1559\" ? txn.maxPriorityFeePerGas : void 0\n    });\n    const reason = hexToString3(`0x${code.substring(138)}`);\n    throw new Error(reason);\n  }\n  return receipt;\n}\n\n// src/actions/transactions/watchPendingTransactions.ts\nimport { shallow as shallow6 } from \"zustand/shallow\";\nfunction watchPendingTransactions(args, callback) {\n  let unwatch;\n  const createListener = publicClient => {\n    if (unwatch) unwatch();\n    unwatch = publicClient.watchPendingTransactions({\n      onTransactions: callback,\n      poll: true\n    });\n  };\n  const publicClient_ = getWebSocketPublicClient({\n    chainId: args.chainId\n  }) ?? getPublicClient({\n    chainId: args.chainId\n  });\n  createListener(publicClient_);\n  const config2 = getConfig();\n  const unsubscribe = config2.subscribe(({\n    publicClient,\n    webSocketPublicClient\n  }) => ({\n    publicClient,\n    webSocketPublicClient\n  }), async ({\n    publicClient,\n    webSocketPublicClient\n  }) => {\n    const publicClient_2 = webSocketPublicClient ?? publicClient;\n    if (!args.chainId && publicClient_2) {\n      createListener(publicClient_2);\n    }\n  }, {\n    equalityFn: shallow6\n  });\n  return () => {\n    unsubscribe();\n    unwatch?.();\n  };\n}\n\n// src/utils/assertActiveChain.ts\nfunction assertActiveChain({\n  chainId\n}) {\n  const {\n    chain: activeChain,\n    chains\n  } = getNetwork();\n  const activeChainId = activeChain?.id;\n  if (activeChainId && chainId !== activeChainId) {\n    throw new ChainMismatchError({\n      activeChain: chains.find(x => x.id === activeChainId)?.name ?? `Chain ${activeChainId}`,\n      targetChain: chains.find(x => x.id === chainId)?.name ?? `Chain ${chainId}`\n    });\n  }\n}\nexport { configureChains, ChainMismatchError, ChainNotConfiguredError, ConnectorAlreadyConnectedError, ConfigChainsNotFound, SwitchChainNotSupportedError, ConnectorNotFoundError, deepEqual, deserialize, getCallParameters, getSendTransactionParameters, getUnit, serialize, noopStorage, createStorage, Config, createConfig, getConfig, connect, disconnect, erc20ABI, erc721ABI, erc4626ABI, fetchToken, getPublicClient, getWalletClient, getWebSocketPublicClient, watchPublicClient, watchWalletClient, watchWebSocketPublicClient, prepareWriteContract, getContract, multicall, readContract, readContracts, watchContractEvent, watchBlockNumber, watchMulticall, watchReadContract, watchReadContracts, writeContract, fetchBalance, getAccount, getNetwork, signMessage, signTypedData, switchNetwork, watchAccount, watchNetwork, fetchEnsAddress, fetchEnsAvatar, fetchEnsName, fetchEnsResolver, fetchBlockNumber, fetchFeeData, fetchTransaction, prepareSendTransaction, sendTransaction, waitForTransaction, watchPendingTransactions };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}