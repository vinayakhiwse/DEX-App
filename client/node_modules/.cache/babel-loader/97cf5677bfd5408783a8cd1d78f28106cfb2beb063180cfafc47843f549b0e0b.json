{"ast":null,"code":"import { EventEmitter as b } from \"events\";\nimport { getAccountsFromNamespaces as A, getSdkError as R, isValidArray as w } from \"@walletconnect/utils\";\nimport { UniversalProvider as T } from \"@walletconnect/universal-provider\";\nconst P = \"wc\",\n  S = \"ethereum_provider\",\n  $ = `${P}@2:${S}:`,\n  j = \"https://rpc.walletconnect.com/v1/\",\n  u = [\"eth_sendTransaction\", \"personal_sign\"],\n  E = [\"eth_accounts\", \"eth_requestAccounts\", \"eth_sendRawTransaction\", \"eth_sign\", \"eth_signTransaction\", \"eth_signTypedData\", \"eth_signTypedData_v3\", \"eth_signTypedData_v4\", \"eth_sendTransaction\", \"personal_sign\", \"wallet_switchEthereumChain\", \"wallet_addEthereumChain\", \"wallet_getPermissions\", \"wallet_requestPermissions\", \"wallet_registerOnboarding\", \"wallet_watchAsset\", \"wallet_scanQRCode\"],\n  m = [\"chainChanged\", \"accountsChanged\"],\n  _ = [\"chainChanged\", \"accountsChanged\", \"message\", \"disconnect\", \"connect\"];\nvar N = Object.defineProperty,\n  q = Object.defineProperties,\n  D = Object.getOwnPropertyDescriptors,\n  y = Object.getOwnPropertySymbols,\n  U = Object.prototype.hasOwnProperty,\n  Q = Object.prototype.propertyIsEnumerable,\n  O = (a, t, s) => t in a ? N(a, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: s\n  }) : a[t] = s,\n  p = (a, t) => {\n    for (var s in t || (t = {})) U.call(t, s) && O(a, s, t[s]);\n    if (y) for (var s of y(t)) Q.call(t, s) && O(a, s, t[s]);\n    return a;\n  },\n  M = (a, t) => q(a, D(t));\nfunction g(a) {\n  return Number(a[0].split(\":\")[1]);\n}\nfunction f(a) {\n  return `0x${a.toString(16)}`;\n}\nfunction L(a) {\n  const {\n    chains: t,\n    optionalChains: s,\n    methods: i,\n    optionalMethods: n,\n    events: e,\n    optionalEvents: h,\n    rpcMap: c\n  } = a;\n  if (!w(t)) throw new Error(\"Invalid chains\");\n  const o = {\n      chains: t,\n      methods: i || u,\n      events: e || m,\n      rpcMap: p({}, t.length ? {\n        [g(t)]: c[g(t)]\n      } : {})\n    },\n    r = e?.filter(l => !m.includes(l)),\n    d = i?.filter(l => !u.includes(l));\n  if (!s && !h && !n && !(r != null && r.length) && !(d != null && d.length)) return {\n    required: t.length ? o : void 0\n  };\n  const C = r?.length && d?.length || !s,\n    I = {\n      chains: [...new Set(C ? o.chains.concat(s || []) : s)],\n      methods: [...new Set(o.methods.concat(n != null && n.length ? n : E))],\n      events: [...new Set(o.events.concat(h != null && h.length ? h : _))],\n      rpcMap: c\n    };\n  return {\n    required: t.length ? o : void 0,\n    optional: s.length ? I : void 0\n  };\n}\nclass v {\n  constructor() {\n    this.events = new b(), this.namespace = \"eip155\", this.accounts = [], this.chainId = 1, this.STORAGE_KEY = $, this.on = (t, s) => (this.events.on(t, s), this), this.once = (t, s) => (this.events.once(t, s), this), this.removeListener = (t, s) => (this.events.removeListener(t, s), this), this.off = (t, s) => (this.events.off(t, s), this), this.parseAccount = t => this.isCompatibleChainId(t) ? this.parseAccountId(t).address : t, this.signer = {}, this.rpc = {};\n  }\n  static async init(t) {\n    const s = new v();\n    return await s.initialize(t), s;\n  }\n  async request(t) {\n    return await this.signer.request(t, this.formatChainId(this.chainId));\n  }\n  sendAsync(t, s) {\n    this.signer.sendAsync(t, s, this.formatChainId(this.chainId));\n  }\n  get connected() {\n    return this.signer.client ? this.signer.client.core.relayer.connected : !1;\n  }\n  get connecting() {\n    return this.signer.client ? this.signer.client.core.relayer.connecting : !1;\n  }\n  async enable() {\n    return this.session || (await this.connect()), await this.request({\n      method: \"eth_requestAccounts\"\n    });\n  }\n  async connect(t) {\n    if (!this.signer.client) throw new Error(\"Provider not initialized. Call init() first\");\n    this.loadConnectOpts(t);\n    const {\n      required: s,\n      optional: i\n    } = L(this.rpc);\n    try {\n      const n = await new Promise(async (h, c) => {\n        var o;\n        this.rpc.showQrModal && ((o = this.modal) == null || o.subscribeModal(r => {\n          !r.open && !this.signer.session && (this.signer.abortPairingAttempt(), c(new Error(\"Connection request reset. Please try again.\")));\n        })), await this.signer.connect(M(p({\n          namespaces: p({}, s && {\n            [this.namespace]: s\n          })\n        }, i && {\n          optionalNamespaces: {\n            [this.namespace]: i\n          }\n        }), {\n          pairingTopic: t?.pairingTopic\n        })).then(r => {\n          h(r);\n        }).catch(r => {\n          c(new Error(r.message));\n        });\n      });\n      if (!n) return;\n      const e = A(n.namespaces, [this.namespace]);\n      this.setChainIds(this.rpc.chains.length ? this.rpc.chains : e), this.setAccounts(e), this.events.emit(\"connect\", {\n        chainId: f(this.chainId)\n      });\n    } catch (n) {\n      throw this.signer.logger.error(n), n;\n    } finally {\n      this.modal && this.modal.closeModal();\n    }\n  }\n  async disconnect() {\n    this.session && (await this.signer.disconnect()), this.reset();\n  }\n  get isWalletConnect() {\n    return !0;\n  }\n  get session() {\n    return this.signer.session;\n  }\n  registerEventListeners() {\n    this.signer.on(\"session_event\", t => {\n      const {\n          params: s\n        } = t,\n        {\n          event: i\n        } = s;\n      i.name === \"accountsChanged\" ? (this.accounts = this.parseAccounts(i.data), this.events.emit(\"accountsChanged\", this.accounts)) : i.name === \"chainChanged\" ? this.setChainId(this.formatChainId(i.data)) : this.events.emit(i.name, i.data), this.events.emit(\"session_event\", t);\n    }), this.signer.on(\"chainChanged\", t => {\n      const s = parseInt(t);\n      this.chainId = s, this.events.emit(\"chainChanged\", f(this.chainId)), this.persist();\n    }), this.signer.on(\"session_update\", t => {\n      this.events.emit(\"session_update\", t);\n    }), this.signer.on(\"session_delete\", t => {\n      this.reset(), this.events.emit(\"session_delete\", t), this.events.emit(\"disconnect\", M(p({}, R(\"USER_DISCONNECTED\")), {\n        data: t.topic,\n        name: \"USER_DISCONNECTED\"\n      }));\n    }), this.signer.on(\"display_uri\", t => {\n      var s, i;\n      this.rpc.showQrModal && ((s = this.modal) == null || s.closeModal(), (i = this.modal) == null || i.openModal({\n        uri: t\n      })), this.events.emit(\"display_uri\", t);\n    });\n  }\n  switchEthereumChain(t) {\n    this.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{\n        chainId: t.toString(16)\n      }]\n    });\n  }\n  isCompatibleChainId(t) {\n    return typeof t == \"string\" ? t.startsWith(`${this.namespace}:`) : !1;\n  }\n  formatChainId(t) {\n    return `${this.namespace}:${t}`;\n  }\n  parseChainId(t) {\n    return Number(t.split(\":\")[1]);\n  }\n  setChainIds(t) {\n    const s = t.filter(i => this.isCompatibleChainId(i)).map(i => this.parseChainId(i));\n    s.length && (this.chainId = s[0], this.events.emit(\"chainChanged\", f(this.chainId)), this.persist());\n  }\n  setChainId(t) {\n    if (this.isCompatibleChainId(t)) {\n      const s = this.parseChainId(t);\n      this.chainId = s, this.switchEthereumChain(s);\n    }\n  }\n  parseAccountId(t) {\n    const [s, i, n] = t.split(\":\");\n    return {\n      chainId: `${s}:${i}`,\n      address: n\n    };\n  }\n  setAccounts(t) {\n    this.accounts = t.filter(s => this.parseChainId(this.parseAccountId(s).chainId) === this.chainId).map(s => this.parseAccountId(s).address), this.events.emit(\"accountsChanged\", this.accounts);\n  }\n  getRpcConfig(t) {\n    var s, i;\n    const n = (s = t?.chains) != null ? s : [],\n      e = (i = t?.optionalChains) != null ? i : [],\n      h = n.concat(e);\n    if (!h.length) throw new Error(\"No chains specified in either `chains` or `optionalChains`\");\n    const c = n.length ? t?.methods || u : [],\n      o = n.length ? t?.events || m : [],\n      r = t?.optionalMethods || [],\n      d = t?.optionalEvents || [],\n      C = t?.rpcMap || this.buildRpcMap(h, t.projectId),\n      I = t?.qrModalOptions || void 0;\n    return {\n      chains: n?.map(l => this.formatChainId(l)),\n      optionalChains: e.map(l => this.formatChainId(l)),\n      methods: c,\n      events: o,\n      optionalMethods: r,\n      optionalEvents: d,\n      rpcMap: C,\n      showQrModal: !!(t != null && t.showQrModal),\n      qrModalOptions: I,\n      projectId: t.projectId,\n      metadata: t.metadata\n    };\n  }\n  buildRpcMap(t, s) {\n    const i = {};\n    return t.forEach(n => {\n      i[n] = this.getRpcUrl(n, s);\n    }), i;\n  }\n  async initialize(t) {\n    if (this.rpc = this.getRpcConfig(t), this.chainId = this.rpc.chains.length ? g(this.rpc.chains) : g(this.rpc.optionalChains), this.signer = await T.init({\n      projectId: this.rpc.projectId,\n      metadata: this.rpc.metadata,\n      disableProviderPing: t.disableProviderPing,\n      relayUrl: t.relayUrl,\n      storageOptions: t.storageOptions\n    }), this.registerEventListeners(), await this.loadPersistedSession(), this.rpc.showQrModal) {\n      let s;\n      try {\n        const {\n          WalletConnectModal: i\n        } = await import(\"@walletconnect/modal\");\n        s = i;\n      } catch {\n        throw new Error(\"To use QR modal, please install @walletconnect/modal package\");\n      }\n      if (s) try {\n        this.modal = new s(p({\n          walletConnectVersion: 2,\n          projectId: this.rpc.projectId,\n          standaloneChains: this.rpc.chains\n        }, this.rpc.qrModalOptions));\n      } catch (i) {\n        throw this.signer.logger.error(i), new Error(\"Could not generate WalletConnectModal Instance\");\n      }\n    }\n  }\n  loadConnectOpts(t) {\n    if (!t) return;\n    const {\n      chains: s,\n      optionalChains: i,\n      rpcMap: n\n    } = t;\n    s && w(s) && (this.rpc.chains = s.map(e => this.formatChainId(e)), s.forEach(e => {\n      this.rpc.rpcMap[e] = n?.[e] || this.getRpcUrl(e);\n    })), i && w(i) && (this.rpc.optionalChains = [], this.rpc.optionalChains = i?.map(e => this.formatChainId(e)), i.forEach(e => {\n      this.rpc.rpcMap[e] = n?.[e] || this.getRpcUrl(e);\n    }));\n  }\n  getRpcUrl(t, s) {\n    var i;\n    return ((i = this.rpc.rpcMap) == null ? void 0 : i[t]) || `${j}?chainId=eip155:${t}&projectId=${s || this.rpc.projectId}`;\n  }\n  async loadPersistedSession() {\n    if (!this.session) return;\n    const t = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`),\n      s = this.session.namespaces[`${this.namespace}:${t}`] ? this.session.namespaces[`${this.namespace}:${t}`] : this.session.namespaces[this.namespace];\n    this.setChainIds(t ? [this.formatChainId(t)] : s?.accounts), this.setAccounts(s?.accounts);\n  }\n  reset() {\n    this.chainId = 1, this.accounts = [];\n  }\n  persist() {\n    this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId);\n  }\n  parseAccounts(t) {\n    return typeof t == \"string\" || t instanceof String ? [this.parseAccount(t)] : t.map(s => this.parseAccount(s));\n  }\n}\nconst G = v;\nexport { G as EthereumProvider, _ as OPTIONAL_EVENTS, E as OPTIONAL_METHODS, m as REQUIRED_EVENTS, u as REQUIRED_METHODS, v as default };\n//# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}