{"ast":null,"code":"import { ChaCha20Poly1305 as ue } from \"@stablelib/chacha20poly1305\";\nimport { HKDF as En } from \"@stablelib/hkdf\";\nimport { randomBytes as le } from \"@stablelib/random\";\nimport { SHA256 as bn, hash as de } from \"@stablelib/sha256\";\nimport * as fe from \"@stablelib/x25519\";\nimport { toString as g, fromString as E, concat as pe } from \"uint8arrays\";\nimport { detect as Nn } from \"detect-browser\";\nimport { toMiliseconds as W, FIVE_MINUTES as me, fromMiliseconds as On } from \"@walletconnect/time\";\nimport { getDocument as Sn, getNavigator as ye, getLocation as he } from \"@walletconnect/window-getters\";\nimport { getWindowMetadata as wn } from \"@walletconnect/window-metadata\";\nimport * as k from \"query-string\";\nimport { RELAY_JSONRPC as In } from \"@walletconnect/relay-api\";\nconst V = \":\";\nfunction ve(e) {\n  const [n, t] = e.split(V);\n  return {\n    namespace: n,\n    reference: t\n  };\n}\nfunction ge(e) {\n  const {\n    namespace: n,\n    reference: t\n  } = e;\n  return [n, t].join(V);\n}\nfunction z(e) {\n  const [n, t, r] = e.split(V);\n  return {\n    namespace: n,\n    reference: t,\n    address: r\n  };\n}\nfunction Ee(e) {\n  const {\n    namespace: n,\n    reference: t,\n    address: r\n  } = e;\n  return [n, t, r].join(V);\n}\nfunction Y(e, n) {\n  const t = [];\n  return e.forEach(r => {\n    const o = n(r);\n    t.includes(o) || t.push(o);\n  }), t;\n}\nfunction be(e) {\n  const {\n    address: n\n  } = z(e);\n  return n;\n}\nfunction Ne(e) {\n  const {\n    namespace: n,\n    reference: t\n  } = z(e);\n  return ge({\n    namespace: n,\n    reference: t\n  });\n}\nfunction Pn(e, n) {\n  const {\n    namespace: t,\n    reference: r\n  } = ve(n);\n  return Ee({\n    namespace: t,\n    reference: r,\n    address: e\n  });\n}\nfunction Tn(e) {\n  return Y(e, be);\n}\nfunction Oe(e) {\n  return Y(e, Ne);\n}\nfunction Rn(e, n = []) {\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...o.accounts);\n  }), t;\n}\nfunction An(e, n = []) {\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...Oe(o.accounts));\n  }), t;\n}\nfunction Un(e, n = []) {\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...M(r, o));\n  }), t;\n}\nfunction M(e, n) {\n  return e.includes(\":\") ? [e] : n.chains || [];\n}\nconst K = e => e?.split(\":\"),\n  Se = e => {\n    const n = e && K(e);\n    if (n) return n[3];\n  },\n  _n = e => {\n    const n = e && K(e);\n    if (n) return n[2] + \":\" + n[3];\n  },\n  we = e => {\n    const n = e && K(e);\n    if (n) return n.pop();\n  },\n  Cn = (e, n) => {\n    const t = `${e.domain} wants you to sign in with your Ethereum account:`,\n      r = we(n),\n      o = e.statement,\n      s = `URI: ${e.aud}`,\n      i = `Version: ${e.version}`,\n      l = `Chain ID: ${Se(n)}`,\n      d = `Nonce: ${e.nonce}`,\n      c = `Issued At: ${e.iat}`,\n      u = e.resources && e.resources.length > 0 ? `Resources:\n${e.resources.map(a => `- ${a}`).join(`\n`)}` : void 0;\n    return [t, r, \"\", o, \"\", s, i, l, d, c, u].filter(a => a != null).join(`\n`);\n  },\n  J = \"base10\",\n  p = \"base16\",\n  L = \"base64pad\",\n  x = \"utf8\",\n  Q = 0,\n  _ = 1,\n  $n = 0,\n  Ie = 1,\n  Z = 12,\n  X = 32;\nfunction jn() {\n  const e = fe.generateKeyPair();\n  return {\n    privateKey: g(e.secretKey, p),\n    publicKey: g(e.publicKey, p)\n  };\n}\nfunction Dn() {\n  const e = le(X);\n  return g(e, p);\n}\nfunction kn(e, n) {\n  const t = fe.sharedKey(E(e, p), E(n, p), !0),\n    r = new En(bn, t).expand(X);\n  return g(r, p);\n}\nfunction Vn(e) {\n  const n = de(E(e, p));\n  return g(n, p);\n}\nfunction Mn(e) {\n  const n = de(E(e, x));\n  return g(n, p);\n}\nfunction Pe(e) {\n  return E(`${e}`, J);\n}\nfunction $(e) {\n  return Number(g(e, J));\n}\nfunction Kn(e) {\n  const n = Pe(typeof e.type < \"u\" ? e.type : Q);\n  if ($(n) === _ && typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n  const t = typeof e.senderPublicKey < \"u\" ? E(e.senderPublicKey, p) : void 0,\n    r = typeof e.iv < \"u\" ? E(e.iv, p) : le(Z),\n    o = new ue(E(e.symKey, p)).seal(r, E(e.message, x));\n  return Te({\n    type: n,\n    sealed: o,\n    iv: r,\n    senderPublicKey: t\n  });\n}\nfunction Ln(e) {\n  const n = new ue(E(e.symKey, p)),\n    {\n      sealed: t,\n      iv: r\n    } = ee(e.encoded),\n    o = n.open(r, t);\n  if (o === null) throw new Error(\"Failed to decrypt\");\n  return g(o, x);\n}\nfunction Te(e) {\n  if ($(e.type) === _) {\n    if (typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n    return g(pe([e.type, e.senderPublicKey, e.iv, e.sealed]), L);\n  }\n  return g(pe([e.type, e.iv, e.sealed]), L);\n}\nfunction ee(e) {\n  const n = E(e, L),\n    t = n.slice($n, Ie),\n    r = Ie;\n  if ($(t) === _) {\n    const l = r + X,\n      d = l + Z,\n      c = n.slice(r, l),\n      u = n.slice(l, d),\n      a = n.slice(d);\n    return {\n      type: t,\n      sealed: a,\n      iv: u,\n      senderPublicKey: c\n    };\n  }\n  const o = r + Z,\n    s = n.slice(r, o),\n    i = n.slice(o);\n  return {\n    type: t,\n    sealed: i,\n    iv: s\n  };\n}\nfunction xn(e, n) {\n  const t = ee(e);\n  return Re({\n    type: $(t.type),\n    senderPublicKey: typeof t.senderPublicKey < \"u\" ? g(t.senderPublicKey, p) : void 0,\n    receiverPublicKey: n?.receiverPublicKey\n  });\n}\nfunction Re(e) {\n  const n = e?.type || Q;\n  if (n === _) {\n    if (typeof e?.senderPublicKey > \"u\") throw new Error(\"missing sender public key\");\n    if (typeof e?.receiverPublicKey > \"u\") throw new Error(\"missing receiver public key\");\n  }\n  return {\n    type: n,\n    senderPublicKey: e?.senderPublicKey,\n    receiverPublicKey: e?.receiverPublicKey\n  };\n}\nfunction Fn(e) {\n  return e.type === _ && typeof e.senderPublicKey == \"string\" && typeof e.receiverPublicKey == \"string\";\n}\nvar Hn = Object.defineProperty,\n  Ae = Object.getOwnPropertySymbols,\n  qn = Object.prototype.hasOwnProperty,\n  Bn = Object.prototype.propertyIsEnumerable,\n  Ue = (e, n, t) => n in e ? Hn(e, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : e[n] = t,\n  _e = (e, n) => {\n    for (var t in n || (n = {})) qn.call(n, t) && Ue(e, t, n[t]);\n    if (Ae) for (var t of Ae(n)) Bn.call(n, t) && Ue(e, t, n[t]);\n    return e;\n  };\nconst Ce = \"ReactNative\",\n  m = {\n    reactNative: \"react-native\",\n    node: \"node\",\n    browser: \"browser\",\n    unknown: \"unknown\"\n  },\n  F = \" \",\n  Gn = \":\",\n  $e = \"/\",\n  ne = 2,\n  Wn = 1e3,\n  je = \"js\";\nfunction te() {\n  return typeof process < \"u\" && typeof process.versions < \"u\" && typeof process.versions.node < \"u\";\n}\nfunction H() {\n  return !Sn() && !!ye() && navigator.product === Ce;\n}\nfunction q() {\n  return !te() && !!ye();\n}\nfunction R() {\n  return H() ? m.reactNative : te() ? m.node : q() ? m.browser : m.unknown;\n}\nfunction De(e, n) {\n  let t = k.parse(e);\n  return t = _e(_e({}, t), n), e = k.stringify(t), e;\n}\nfunction zn() {\n  return wn() || {\n    name: \"\",\n    description: \"\",\n    url: \"\",\n    icons: [\"\"]\n  };\n}\nfunction Yn(e, n) {\n  var t;\n  const r = R(),\n    o = {\n      protocol: e,\n      version: n,\n      env: r\n    };\n  return r === \"browser\" && (o.host = ((t = he()) == null ? void 0 : t.host) || \"unknown\"), o;\n}\nfunction ke() {\n  if (R() === m.reactNative && typeof global < \"u\" && typeof (global == null ? void 0 : global.Platform) < \"u\") {\n    const {\n      OS: t,\n      Version: r\n    } = global.Platform;\n    return [t, r].join(\"-\");\n  }\n  const e = Nn();\n  if (e === null) return \"unknown\";\n  const n = e.os ? e.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  return e.type === \"browser\" ? [n, e.name, e.version].join(\"-\") : [n, e.version].join(\"-\");\n}\nfunction Ve() {\n  var e;\n  const n = R();\n  return n === m.browser ? [n, ((e = he()) == null ? void 0 : e.host) || \"unknown\"].join(\":\") : n;\n}\nfunction Me(e, n, t) {\n  const r = ke(),\n    o = Ve();\n  return [[e, n].join(\"-\"), [je, t].join(\"-\"), r, o].join(\"/\");\n}\nfunction Jn({\n  protocol: e,\n  version: n,\n  relayUrl: t,\n  sdkVersion: r,\n  auth: o,\n  projectId: s,\n  useOnCloseEvent: i\n}) {\n  const l = t.split(\"?\"),\n    d = Me(e, n, r),\n    c = {\n      auth: o,\n      ua: d,\n      projectId: s,\n      useOnCloseEvent: i || void 0\n    },\n    u = De(l[1] || \"\", c);\n  return l[0] + \"?\" + u;\n}\nfunction Qn(e) {\n  let n = (e.match(/^[^:]+(?=:\\/\\/)/gi) || [])[0];\n  const t = typeof n < \"u\" ? e.split(\"://\")[1] : e;\n  return n = n === \"wss\" ? \"https\" : \"http\", [n, t].join(\"://\");\n}\nfunction Zn(e, n, t) {\n  if (!e[n] || typeof e[n] !== t) throw new Error(`Missing or invalid \"${n}\" param`);\n}\nfunction Ke(e, n = ne) {\n  return Le(e.split($e), n);\n}\nfunction Xn(e) {\n  return Ke(e).join(F);\n}\nfunction O(e, n) {\n  return e.filter(t => n.includes(t)).length === e.length;\n}\nfunction Le(e, n = ne) {\n  return e.slice(Math.max(e.length - n, 0));\n}\nfunction et(e) {\n  return Object.fromEntries(e.entries());\n}\nfunction nt(e) {\n  return new Map(Object.entries(e));\n}\nfunction tt(e, n) {\n  const t = {};\n  return Object.keys(e).forEach(r => {\n    t[r] = n(e[r]);\n  }), t;\n}\nconst rt = e => e;\nfunction xe(e) {\n  return e.trim().replace(/^\\w/, n => n.toUpperCase());\n}\nfunction ot(e) {\n  return e.split(F).map(n => xe(n)).join(F);\n}\nfunction st(e = me, n) {\n  const t = W(e || me);\n  let r, o, s;\n  return {\n    resolve: i => {\n      s && r && (clearTimeout(s), r(i));\n    },\n    reject: i => {\n      s && o && (clearTimeout(s), o(i));\n    },\n    done: () => new Promise((i, l) => {\n      s = setTimeout(() => {\n        l(new Error(n));\n      }, t), r = i, o = l;\n    })\n  };\n}\nfunction it(e, n, t) {\n  return new Promise(async (r, o) => {\n    const s = setTimeout(() => o(new Error(t)), n);\n    try {\n      const i = await e;\n      r(i);\n    } catch (i) {\n      o(i);\n    }\n    clearTimeout(s);\n  });\n}\nfunction re(e, n) {\n  if (typeof n == \"string\" && n.startsWith(`${e}:`)) return n;\n  if (e.toLowerCase() === \"topic\") {\n    if (typeof n != \"string\") throw new Error('Value must be \"string\" for expirer target type: topic');\n    return `topic:${n}`;\n  } else if (e.toLowerCase() === \"id\") {\n    if (typeof n != \"number\") throw new Error('Value must be \"number\" for expirer target type: id');\n    return `id:${n}`;\n  }\n  throw new Error(`Unknown expirer target type: ${e}`);\n}\nfunction ct(e) {\n  return re(\"topic\", e);\n}\nfunction at(e) {\n  return re(\"id\", e);\n}\nfunction ut(e) {\n  const [n, t] = e.split(\":\"),\n    r = {\n      id: void 0,\n      topic: void 0\n    };\n  if (n === \"topic\" && typeof t == \"string\") r.topic = t;else if (n === \"id\" && Number.isInteger(Number(t))) r.id = Number(t);else throw new Error(`Invalid target, expected id:number or topic:string, got ${n}:${t}`);\n  return r;\n}\nfunction lt(e, n) {\n  return On((n || Date.now()) + W(e));\n}\nfunction dt(e) {\n  return Date.now() >= W(e);\n}\nfunction ft(e, n) {\n  return `${e}${n ? `:${n}` : \"\"}`;\n}\nfunction S(e = [], n = []) {\n  return [...new Set([...e, ...n])];\n}\nasync function pt({\n  id: e,\n  topic: n,\n  wcDeepLink: t\n}) {\n  try {\n    if (!t) return;\n    const r = typeof t == \"string\" ? JSON.parse(t) : t;\n    let o = r?.href;\n    if (typeof o != \"string\") return;\n    o.endsWith(\"/\") && (o = o.slice(0, -1));\n    const s = `${o}/wc?requestId=${e}&sessionTopic=${n}`,\n      i = R();\n    i === m.browser ? s.startsWith(\"https://\") ? window.open(s, \"_blank\", \"noreferrer noopener\") : window.open(s, \"_self\", \"noreferrer noopener\") : i === m.reactNative && typeof (global == null ? void 0 : global.Linking) < \"u\" && (await global.Linking.openURL(s));\n  } catch (r) {\n    console.error(r);\n  }\n}\nconst Fe = \"irn\";\nfunction mt(e) {\n  return e?.relay || {\n    protocol: Fe\n  };\n}\nfunction yt(e) {\n  const n = In[e];\n  if (typeof n > \"u\") throw new Error(`Relay Protocol not supported: ${e}`);\n  return n;\n}\nvar ht = Object.defineProperty,\n  He = Object.getOwnPropertySymbols,\n  vt = Object.prototype.hasOwnProperty,\n  gt = Object.prototype.propertyIsEnumerable,\n  qe = (e, n, t) => n in e ? ht(e, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : e[n] = t,\n  Et = (e, n) => {\n    for (var t in n || (n = {})) vt.call(n, t) && qe(e, t, n[t]);\n    if (He) for (var t of He(n)) gt.call(n, t) && qe(e, t, n[t]);\n    return e;\n  };\nfunction Be(e, n = \"-\") {\n  const t = {},\n    r = \"relay\" + n;\n  return Object.keys(e).forEach(o => {\n    if (o.startsWith(r)) {\n      const s = o.replace(r, \"\"),\n        i = e[o];\n      t[s] = i;\n    }\n  }), t;\n}\nfunction bt(e) {\n  const n = e.indexOf(\":\"),\n    t = e.indexOf(\"?\") !== -1 ? e.indexOf(\"?\") : void 0,\n    r = e.substring(0, n),\n    o = e.substring(n + 1, t).split(\"@\"),\n    s = typeof t < \"u\" ? e.substring(t) : \"\",\n    i = k.parse(s);\n  return {\n    protocol: r,\n    topic: Ge(o[0]),\n    version: parseInt(o[1], 10),\n    symKey: i.symKey,\n    relay: Be(i)\n  };\n}\nfunction Ge(e) {\n  return e.startsWith(\"//\") ? e.substring(2) : e;\n}\nfunction We(e, n = \"-\") {\n  const t = \"relay\",\n    r = {};\n  return Object.keys(e).forEach(o => {\n    const s = t + n + o;\n    e[o] && (r[s] = e[o]);\n  }), r;\n}\nfunction Nt(e) {\n  return `${e.protocol}:${e.topic}@${e.version}?` + k.stringify(Et({\n    symKey: e.symKey\n  }, We(e.relay)));\n}\nvar Ot = Object.defineProperty,\n  St = Object.defineProperties,\n  wt = Object.getOwnPropertyDescriptors,\n  ze = Object.getOwnPropertySymbols,\n  It = Object.prototype.hasOwnProperty,\n  Pt = Object.prototype.propertyIsEnumerable,\n  Ye = (e, n, t) => n in e ? Ot(e, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : e[n] = t,\n  Tt = (e, n) => {\n    for (var t in n || (n = {})) It.call(n, t) && Ye(e, t, n[t]);\n    if (ze) for (var t of ze(n)) Pt.call(n, t) && Ye(e, t, n[t]);\n    return e;\n  },\n  Rt = (e, n) => St(e, wt(n));\nfunction A(e) {\n  const n = [];\n  return e.forEach(t => {\n    const [r, o] = t.split(\":\");\n    n.push(`${r}:${o}`);\n  }), n;\n}\nfunction Je(e) {\n  const n = [];\n  return Object.values(e).forEach(t => {\n    n.push(...A(t.accounts));\n  }), n;\n}\nfunction Qe(e, n) {\n  const t = [];\n  return Object.values(e).forEach(r => {\n    A(r.accounts).includes(n) && t.push(...r.methods);\n  }), t;\n}\nfunction Ze(e, n) {\n  const t = [];\n  return Object.values(e).forEach(r => {\n    A(r.accounts).includes(n) && t.push(...r.events);\n  }), t;\n}\nfunction At(e, n) {\n  const t = cn(e, n);\n  if (t) throw new Error(t.message);\n  const r = {};\n  for (const [o, s] of Object.entries(e)) r[o] = {\n    methods: s.methods,\n    events: s.events,\n    chains: s.accounts.map(i => `${i.split(\":\")[0]}:${i.split(\":\")[1]}`)\n  };\n  return r;\n}\nfunction Ut(e) {\n  const {\n      proposal: {\n        requiredNamespaces: n,\n        optionalNamespaces: t = {}\n      },\n      supportedNamespaces: r\n    } = e,\n    o = se(n),\n    s = se(t),\n    i = {};\n  Object.keys(r).forEach(c => {\n    const u = r[c].chains,\n      a = r[c].methods,\n      b = r[c].events,\n      I = r[c].accounts;\n    u.forEach(y => {\n      if (!I.some(f => f.includes(y))) throw new Error(`No accounts provided for chain ${y} in namespace ${c}`);\n    }), i[c] = {\n      chains: u,\n      methods: a,\n      events: b,\n      accounts: I\n    };\n  });\n  const l = un(n, i, \"approve()\");\n  if (l) throw new Error(l.message);\n  const d = {};\n  return !Object.keys(n).length && !Object.keys(t).length ? i : (Object.keys(o).forEach(c => {\n    const u = r[c].chains.filter(y => {\n        var f, v;\n        return (v = (f = o[c]) == null ? void 0 : f.chains) == null ? void 0 : v.includes(y);\n      }),\n      a = r[c].methods.filter(y => {\n        var f, v;\n        return (v = (f = o[c]) == null ? void 0 : f.methods) == null ? void 0 : v.includes(y);\n      }),\n      b = r[c].events.filter(y => {\n        var f, v;\n        return (v = (f = o[c]) == null ? void 0 : f.events) == null ? void 0 : v.includes(y);\n      }),\n      I = u.map(y => r[c].accounts.filter(f => f.includes(`${y}:`))).flat();\n    d[c] = {\n      chains: u,\n      methods: a,\n      events: b,\n      accounts: I\n    };\n  }), Object.keys(s).forEach(c => {\n    var u, a, b, I, y, f;\n    if (!r[c]) return;\n    const v = (a = (u = s[c]) == null ? void 0 : u.chains) == null ? void 0 : a.filter(P => r[c].chains.includes(P)),\n      hn = r[c].methods.filter(P => {\n        var T, C;\n        return (C = (T = s[c]) == null ? void 0 : T.methods) == null ? void 0 : C.includes(P);\n      }),\n      vn = r[c].events.filter(P => {\n        var T, C;\n        return (C = (T = s[c]) == null ? void 0 : T.events) == null ? void 0 : C.includes(P);\n      }),\n      gn = v?.map(P => r[c].accounts.filter(T => T.includes(`${P}:`))).flat();\n    d[c] = {\n      chains: S((b = d[c]) == null ? void 0 : b.chains, v),\n      methods: S((I = d[c]) == null ? void 0 : I.methods, hn),\n      events: S((y = d[c]) == null ? void 0 : y.events, vn),\n      accounts: S((f = d[c]) == null ? void 0 : f.accounts, gn)\n    };\n  }), d);\n}\nfunction oe(e) {\n  return e.includes(\":\");\n}\nfunction Xe(e) {\n  return oe(e) ? e.split(\":\")[0] : e;\n}\nfunction se(e) {\n  var n, t, r;\n  const o = {};\n  if (!B(e)) return o;\n  for (const [s, i] of Object.entries(e)) {\n    const l = oe(s) ? [s] : i.chains,\n      d = i.methods || [],\n      c = i.events || [],\n      u = Xe(s);\n    o[u] = Rt(Tt({}, o[u]), {\n      chains: S(l, (n = o[u]) == null ? void 0 : n.chains),\n      methods: S(d, (t = o[u]) == null ? void 0 : t.methods),\n      events: S(c, (r = o[u]) == null ? void 0 : r.events)\n    });\n  }\n  return o;\n}\nconst _t = {\n    INVALID_METHOD: {\n      message: \"Invalid method.\",\n      code: 1001\n    },\n    INVALID_EVENT: {\n      message: \"Invalid event.\",\n      code: 1002\n    },\n    INVALID_UPDATE_REQUEST: {\n      message: \"Invalid update request.\",\n      code: 1003\n    },\n    INVALID_EXTEND_REQUEST: {\n      message: \"Invalid extend request.\",\n      code: 1004\n    },\n    INVALID_SESSION_SETTLE_REQUEST: {\n      message: \"Invalid session settle request.\",\n      code: 1005\n    },\n    UNAUTHORIZED_METHOD: {\n      message: \"Unauthorized method.\",\n      code: 3001\n    },\n    UNAUTHORIZED_EVENT: {\n      message: \"Unauthorized event.\",\n      code: 3002\n    },\n    UNAUTHORIZED_UPDATE_REQUEST: {\n      message: \"Unauthorized update request.\",\n      code: 3003\n    },\n    UNAUTHORIZED_EXTEND_REQUEST: {\n      message: \"Unauthorized extend request.\",\n      code: 3004\n    },\n    USER_REJECTED: {\n      message: \"User rejected.\",\n      code: 5e3\n    },\n    USER_REJECTED_CHAINS: {\n      message: \"User rejected chains.\",\n      code: 5001\n    },\n    USER_REJECTED_METHODS: {\n      message: \"User rejected methods.\",\n      code: 5002\n    },\n    USER_REJECTED_EVENTS: {\n      message: \"User rejected events.\",\n      code: 5003\n    },\n    UNSUPPORTED_CHAINS: {\n      message: \"Unsupported chains.\",\n      code: 5100\n    },\n    UNSUPPORTED_METHODS: {\n      message: \"Unsupported methods.\",\n      code: 5101\n    },\n    UNSUPPORTED_EVENTS: {\n      message: \"Unsupported events.\",\n      code: 5102\n    },\n    UNSUPPORTED_ACCOUNTS: {\n      message: \"Unsupported accounts.\",\n      code: 5103\n    },\n    UNSUPPORTED_NAMESPACE_KEY: {\n      message: \"Unsupported namespace key.\",\n      code: 5104\n    },\n    USER_DISCONNECTED: {\n      message: \"User disconnected.\",\n      code: 6e3\n    },\n    SESSION_SETTLEMENT_FAILED: {\n      message: \"Session settlement failed.\",\n      code: 7e3\n    },\n    WC_METHOD_UNSUPPORTED: {\n      message: \"Unsupported wc_ method.\",\n      code: 10001\n    }\n  },\n  Ct = {\n    NOT_INITIALIZED: {\n      message: \"Not initialized.\",\n      code: 1\n    },\n    NO_MATCHING_KEY: {\n      message: \"No matching key.\",\n      code: 2\n    },\n    RESTORE_WILL_OVERRIDE: {\n      message: \"Restore will override.\",\n      code: 3\n    },\n    RESUBSCRIBED: {\n      message: \"Resubscribed.\",\n      code: 4\n    },\n    MISSING_OR_INVALID: {\n      message: \"Missing or invalid.\",\n      code: 5\n    },\n    EXPIRED: {\n      message: \"Expired.\",\n      code: 6\n    },\n    UNKNOWN_TYPE: {\n      message: \"Unknown type.\",\n      code: 7\n    },\n    MISMATCHED_TOPIC: {\n      message: \"Mismatched topic.\",\n      code: 8\n    },\n    NON_CONFORMING_NAMESPACES: {\n      message: \"Non conforming namespaces.\",\n      code: 9\n    }\n  };\nfunction N(e, n) {\n  const {\n    message: t,\n    code: r\n  } = Ct[e];\n  return {\n    message: n ? `${t} ${n}` : t,\n    code: r\n  };\n}\nfunction U(e, n) {\n  const {\n    message: t,\n    code: r\n  } = _t[e];\n  return {\n    message: n ? `${t} ${n}` : t,\n    code: r\n  };\n}\nfunction j(e, n) {\n  return Array.isArray(e) ? typeof n < \"u\" && e.length ? e.every(n) : !0 : !1;\n}\nfunction B(e) {\n  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;\n}\nfunction w(e) {\n  return typeof e > \"u\";\n}\nfunction h(e, n) {\n  return n && w(e) ? !0 : typeof e == \"string\" && !!e.trim().length;\n}\nfunction G(e, n) {\n  return n && w(e) ? !0 : typeof e == \"number\" && !isNaN(e);\n}\nfunction $t(e, n) {\n  const {\n      requiredNamespaces: t\n    } = n,\n    r = Object.keys(e.namespaces),\n    o = Object.keys(t);\n  let s = !0;\n  return O(o, r) ? (r.forEach(i => {\n    const {\n        accounts: l,\n        methods: d,\n        events: c\n      } = e.namespaces[i],\n      u = A(l),\n      a = t[i];\n    (!O(M(i, a), u) || !O(a.methods, d) || !O(a.events, c)) && (s = !1);\n  }), s) : !1;\n}\nfunction D(e) {\n  return h(e, !1) && e.includes(\":\") ? e.split(\":\").length === 2 : !1;\n}\nfunction en(e) {\n  if (h(e, !1) && e.includes(\":\")) {\n    const n = e.split(\":\");\n    if (n.length === 3) {\n      const t = n[0] + \":\" + n[1];\n      return !!n[2] && D(t);\n    }\n  }\n  return !1;\n}\nfunction jt(e) {\n  if (h(e, !1)) try {\n    return typeof new URL(e) < \"u\";\n  } catch {\n    return !1;\n  }\n  return !1;\n}\nfunction Dt(e) {\n  var n;\n  return (n = e?.proposer) == null ? void 0 : n.publicKey;\n}\nfunction kt(e) {\n  return e?.topic;\n}\nfunction Vt(e, n) {\n  let t = null;\n  return h(e?.publicKey, !1) || (t = N(\"MISSING_OR_INVALID\", `${n} controller public key should be a string`)), t;\n}\nfunction ie(e) {\n  let n = !0;\n  return j(e) ? e.length && (n = e.every(t => h(t, !1))) : n = !1, n;\n}\nfunction nn(e, n, t) {\n  let r = null;\n  return j(n) && n.length ? n.forEach(o => {\n    r || D(o) || (r = U(\"UNSUPPORTED_CHAINS\", `${t}, chain ${o} should be a string and conform to \"namespace:chainId\" format`));\n  }) : D(e) || (r = U(\"UNSUPPORTED_CHAINS\", `${t}, chains must be defined as \"namespace:chainId\" e.g. \"eip155:1\": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: [\"eip155:1\", \"eip155:5\"] }`)), r;\n}\nfunction tn(e, n, t) {\n  let r = null;\n  return Object.entries(e).forEach(([o, s]) => {\n    if (r) return;\n    const i = nn(o, M(o, s), `${n} ${t}`);\n    i && (r = i);\n  }), r;\n}\nfunction rn(e, n) {\n  let t = null;\n  return j(e) ? e.forEach(r => {\n    t || en(r) || (t = U(\"UNSUPPORTED_ACCOUNTS\", `${n}, account ${r} should be a string and conform to \"namespace:chainId:address\" format`));\n  }) : t = U(\"UNSUPPORTED_ACCOUNTS\", `${n}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`), t;\n}\nfunction on(e, n) {\n  let t = null;\n  return Object.values(e).forEach(r => {\n    if (t) return;\n    const o = rn(r?.accounts, `${n} namespace`);\n    o && (t = o);\n  }), t;\n}\nfunction sn(e, n) {\n  let t = null;\n  return ie(e?.methods) ? ie(e?.events) || (t = U(\"UNSUPPORTED_EVENTS\", `${n}, events should be an array of strings or empty array for no events`)) : t = U(\"UNSUPPORTED_METHODS\", `${n}, methods should be an array of strings or empty array for no methods`), t;\n}\nfunction ce(e, n) {\n  let t = null;\n  return Object.values(e).forEach(r => {\n    if (t) return;\n    const o = sn(r, `${n}, namespace`);\n    o && (t = o);\n  }), t;\n}\nfunction Mt(e, n, t) {\n  let r = null;\n  if (e && B(e)) {\n    const o = ce(e, n);\n    o && (r = o);\n    const s = tn(e, n, t);\n    s && (r = s);\n  } else r = N(\"MISSING_OR_INVALID\", `${n}, ${t} should be an object with data`);\n  return r;\n}\nfunction cn(e, n) {\n  let t = null;\n  if (e && B(e)) {\n    const r = ce(e, n);\n    r && (t = r);\n    const o = on(e, n);\n    o && (t = o);\n  } else t = N(\"MISSING_OR_INVALID\", `${n}, namespaces should be an object with data`);\n  return t;\n}\nfunction an(e) {\n  return h(e.protocol, !0);\n}\nfunction Kt(e, n) {\n  let t = !1;\n  return n && !e ? t = !0 : e && j(e) && e.length && e.forEach(r => {\n    t = an(r);\n  }), t;\n}\nfunction Lt(e) {\n  return typeof e == \"number\";\n}\nfunction xt(e) {\n  return typeof e < \"u\" && typeof e !== null;\n}\nfunction Ft(e) {\n  return !(!e || typeof e != \"object\" || !e.code || !G(e.code, !1) || !e.message || !h(e.message, !1));\n}\nfunction Ht(e) {\n  return !(w(e) || !h(e.method, !1));\n}\nfunction qt(e) {\n  return !(w(e) || w(e.result) && w(e.error) || !G(e.id, !1) || !h(e.jsonrpc, !1));\n}\nfunction Bt(e) {\n  return !(w(e) || !h(e.name, !1));\n}\nfunction Gt(e, n) {\n  return !(!D(n) || !Je(e).includes(n));\n}\nfunction Wt(e, n, t) {\n  return h(t, !1) ? Qe(e, n).includes(t) : !1;\n}\nfunction zt(e, n, t) {\n  return h(t, !1) ? Ze(e, n).includes(t) : !1;\n}\nfunction un(e, n, t) {\n  let r = null;\n  const o = Yt(e),\n    s = Jt(n),\n    i = Object.keys(o),\n    l = Object.keys(s),\n    d = ln(Object.keys(e)),\n    c = ln(Object.keys(n)),\n    u = d.filter(a => !c.includes(a));\n  return u.length && (r = N(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces keys don't satisfy requiredNamespaces.\n      Required: ${u.toString()}\n      Received: ${Object.keys(n).toString()}`)), O(i, l) || (r = N(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces chains don't satisfy required namespaces.\n      Required: ${i.toString()}\n      Approved: ${l.toString()}`)), Object.keys(n).forEach(a => {\n    if (!a.includes(\":\") || r) return;\n    const b = A(n[a].accounts);\n    b.includes(a) || (r = N(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces accounts don't satisfy namespace accounts for ${a}\n        Required: ${a}\n        Approved: ${b.toString()}`));\n  }), i.forEach(a => {\n    r || (O(o[a].methods, s[a].methods) ? O(o[a].events, s[a].events) || (r = N(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces events don't satisfy namespace events for ${a}`)) : r = N(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces methods don't satisfy namespace methods for ${a}`));\n  }), r;\n}\nfunction Yt(e) {\n  const n = {};\n  return Object.keys(e).forEach(t => {\n    var r;\n    t.includes(\":\") ? n[t] = e[t] : (r = e[t].chains) == null || r.forEach(o => {\n      n[o] = {\n        methods: e[t].methods,\n        events: e[t].events\n      };\n    });\n  }), n;\n}\nfunction ln(e) {\n  return [...new Set(e.map(n => n.includes(\":\") ? n.split(\":\")[0] : n))];\n}\nfunction Jt(e) {\n  const n = {};\n  return Object.keys(e).forEach(t => {\n    if (t.includes(\":\")) n[t] = e[t];else {\n      const r = A(e[t].accounts);\n      r?.forEach(o => {\n        n[o] = {\n          accounts: e[t].accounts.filter(s => s.includes(`${o}:`)),\n          methods: e[t].methods,\n          events: e[t].events\n        };\n      });\n    }\n  }), n;\n}\nfunction Qt(e, n) {\n  return G(e, !1) && e <= n.max && e >= n.min;\n}\nfunction Zt() {\n  const e = R();\n  return new Promise(n => {\n    switch (e) {\n      case m.browser:\n        n(dn());\n        break;\n      case m.reactNative:\n        n(fn());\n        break;\n      case m.node:\n        n(pn());\n        break;\n      default:\n        n(!0);\n    }\n  });\n}\nfunction dn() {\n  return q() && navigator?.onLine;\n}\nasync function fn() {\n  if (H() && typeof global < \"u\" && global != null && global.NetInfo) {\n    const e = await (global == null ? void 0 : global.NetInfo.fetch());\n    return e?.isConnected;\n  }\n  return !0;\n}\nfunction pn() {\n  return !0;\n}\nfunction Xt(e) {\n  switch (R()) {\n    case m.browser:\n      mn(e);\n      break;\n    case m.reactNative:\n      yn(e);\n      break;\n    case m.node:\n      break;\n  }\n}\nfunction mn(e) {\n  q() && (window.addEventListener(\"online\", () => e(!0)), window.addEventListener(\"offline\", () => e(!1)));\n}\nfunction yn(e) {\n  H() && typeof global < \"u\" && global != null && global.NetInfo && global?.NetInfo.addEventListener(n => e(n?.isConnected));\n}\nconst ae = {};\nclass er {\n  static get(n) {\n    return ae[n];\n  }\n  static set(n, t) {\n    ae[n] = t;\n  }\n  static delete(n) {\n    delete ae[n];\n  }\n}\nexport { J as BASE10, p as BASE16, L as BASE64, Gn as COLON, ne as DEFAULT_DEPTH, F as EMPTY_SPACE, m as ENV_MAP, er as MemoryStore, Wn as ONE_THOUSAND, Ce as REACT_NATIVE_PRODUCT, Fe as RELAYER_DEFAULT_PROTOCOL, je as SDK_TYPE, $e as SLASH, Q as TYPE_0, _ as TYPE_1, x as UTF8, De as appendToQueryString, Zn as assertType, Ut as buildApprovedNamespaces, lt as calcExpiry, ot as capitalize, xe as capitalizeWord, st as createDelayedPromise, it as createExpiringPromise, $ as decodeTypeByte, Ln as decrypt, kn as deriveSymKey, ee as deserialize, Pe as encodeTypeByte, Kn as encrypt, ft as engineEvent, rt as enumify, Ee as formatAccountId, Pn as formatAccountWithChain, ge as formatChainId, re as formatExpirerTarget, at as formatIdTarget, Cn as formatMessage, Xn as formatMessageContext, We as formatRelayParams, Jn as formatRelayRpcUrl, ct as formatTopicTarget, Me as formatUA, Nt as formatUri, jn as generateKeyPair, Dn as generateRandomBytes32, A as getAccountsChains, Rn as getAccountsFromNamespaces, be as getAddressFromAccount, Tn as getAddressesFromAccounts, zn as getAppMetadata, dn as getBrowserOnlineStatus, Ne as getChainFromAccount, Oe as getChainsFromAccounts, M as getChainsFromNamespace, An as getChainsFromNamespaces, Un as getChainsFromRequiredNamespaces, we as getDidAddress, K as getDidAddressSegments, Se as getDidChainId, R as getEnvironment, Qn as getHttpUrl, N as getInternalError, Ve as getJavascriptID, ke as getJavascriptOS, Le as getLastItems, _n as getNamespacedDidChainId, Je as getNamespacesChains, Ze as getNamespacesEventsForChainId, Qe as getNamespacesMethodsForChainId, pn as getNodeOnlineStatus, fn as getReactNativeOnlineStatus, Yn as getRelayClientMetadata, yt as getRelayProtocolApi, mt as getRelayProtocolName, At as getRequiredNamespacesFromNamespaces, U as getSdkError, Y as getUniqueValues, pt as handleDeeplinkRedirect, O as hasOverlap, Vn as hashKey, Mn as hashMessage, q as isBrowser, oe as isCaipNamespace, un as isConformingNamespaces, dt as isExpired, te as isNode, Zt as isOnline, Dt as isProposalStruct, H as isReactNative, $t as isSessionCompatible, kt as isSessionStruct, Fn as isTypeOneEnvelope, w as isUndefined, en as isValidAccountId, rn as isValidAccounts, sn as isValidActions, j as isValidArray, D as isValidChainId, nn as isValidChains, Vt as isValidController, Ft as isValidErrorReason, Bt as isValidEvent, Lt as isValidId, on as isValidNamespaceAccounts, ce as isValidNamespaceActions, tn as isValidNamespaceChains, ie as isValidNamespaceMethodsOrEvents, cn as isValidNamespaces, Gt as isValidNamespacesChainId, zt as isValidNamespacesEvent, Wt as isValidNamespacesRequest, G as isValidNumber, B as isValidObject, xt as isValidParams, an as isValidRelay, Kt as isValidRelays, Ht as isValidRequest, Qt as isValidRequestExpiry, Mt as isValidRequiredNamespaces, qt as isValidResponse, h as isValidString, jt as isValidUrl, tt as mapEntries, et as mapToObj, S as mergeArrays, se as normalizeNamespaces, nt as objToMap, z as parseAccountId, ve as parseChainId, Ke as parseContextNames, ut as parseExpirerTarget, Xe as parseNamespaceKey, Be as parseRelayParams, Ge as parseTopic, bt as parseUri, Te as serialize, mn as subscribeToBrowserNetworkChange, Xt as subscribeToNetworkChange, yn as subscribeToReactNativeNetworkChange, xn as validateDecoding, Re as validateEncoding };\n//# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}