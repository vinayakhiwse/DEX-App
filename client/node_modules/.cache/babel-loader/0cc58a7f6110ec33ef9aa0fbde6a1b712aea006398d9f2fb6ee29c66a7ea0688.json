{"ast":null,"code":"import { filterDOMProps as $kOq5K$filterDOMProps, useFormReset as $kOq5K$useFormReset, mergeProps as $kOq5K$mergeProps, useEffectEvent as $kOq5K$useEffectEvent } from \"@react-aria/utils\";\nimport { useField as $kOq5K$useField } from \"@react-aria/label\";\nimport { useFocusable as $kOq5K$useFocusable } from \"@react-aria/focus\";\nimport { useEffect as $kOq5K$useEffect, useRef as $kOq5K$useRef } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n    * Copyright 2020 Adobe. All rights reserved.\n    * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License. You may obtain a copy\n    * of the License at http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software distributed under\n    * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n    * OF ANY KIND, either express or implied. See the License for the specific language\n    * governing permissions and limitations under the License.\n    */\n\nfunction $2d73ec29415bd339$export$712718f7aec83d5(props, ref) {\n  let {\n    inputElementType = \"input\",\n    isDisabled = false,\n    isRequired = false,\n    isReadOnly = false,\n    validationState: validationState,\n    isInvalid = false,\n    type = \"text\",\n    value: value,\n    defaultValue: defaultValue,\n    onChange = () => {}\n  } = props;\n  let {\n    focusableProps: focusableProps\n  } = (0, $kOq5K$useFocusable)(props, ref);\n  let {\n    labelProps: labelProps,\n    fieldProps: fieldProps,\n    descriptionProps: descriptionProps,\n    errorMessageProps: errorMessageProps\n  } = (0, $kOq5K$useField)(props);\n  let domProps = (0, $kOq5K$filterDOMProps)(props, {\n    labelable: true\n  });\n  const inputOnlyProps = {\n    type: type,\n    pattern: props.pattern\n  };\n  var _ref;\n  (0, $kOq5K$useFormReset)(ref, (_ref = value !== null && value !== void 0 ? value : defaultValue) !== null && _ref !== void 0 ? _ref : \"\", onChange);\n  return {\n    labelProps: labelProps,\n    inputProps: (0, $kOq5K$mergeProps)(domProps, inputElementType === \"input\" && inputOnlyProps, {\n      disabled: isDisabled,\n      readOnly: isReadOnly,\n      \"aria-required\": isRequired || undefined,\n      \"aria-invalid\": isInvalid || validationState === \"invalid\" || undefined,\n      \"aria-errormessage\": props[\"aria-errormessage\"],\n      \"aria-activedescendant\": props[\"aria-activedescendant\"],\n      \"aria-autocomplete\": props[\"aria-autocomplete\"],\n      \"aria-haspopup\": props[\"aria-haspopup\"],\n      value: props.value,\n      defaultValue: props.value ? undefined : props.defaultValue,\n      onChange: e => onChange(e.target.value),\n      autoComplete: props.autoComplete,\n      maxLength: props.maxLength,\n      minLength: props.minLength,\n      name: props.name,\n      placeholder: props.placeholder,\n      inputMode: props.inputMode,\n      // Clipboard events\n      onCopy: props.onCopy,\n      onCut: props.onCut,\n      onPaste: props.onPaste,\n      // Composition events\n      onCompositionEnd: props.onCompositionEnd,\n      onCompositionStart: props.onCompositionStart,\n      onCompositionUpdate: props.onCompositionUpdate,\n      // Selection events\n      onSelect: props.onSelect,\n      // Input events\n      onBeforeInput: props.onBeforeInput,\n      onInput: props.onInput,\n      ...focusableProps,\n      ...fieldProps\n    }),\n    descriptionProps: descriptionProps,\n    errorMessageProps: errorMessageProps\n  };\n}\n\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $d841c8010a73d545$var$supportsNativeBeforeInputEvent() {\n  return typeof window !== \"undefined\" && window.InputEvent &&\n  // @ts-ignore\n  typeof InputEvent.prototype.getTargetRanges === \"function\";\n}\nfunction $d841c8010a73d545$export$4f384c9210e583c3(props, state, inputRef) {\n  // All browsers implement the 'beforeinput' event natively except Firefox\n  // (currently behind a flag as of Firefox 84). React's polyfill does not\n  // run in all cases that the native event fires, e.g. when deleting text.\n  // Use the native event if available so that we can prevent invalid deletions.\n  // We do not attempt to polyfill this in Firefox since it would be very complicated,\n  // the benefit of doing so is fairly minor, and it's going to be natively supported soon.\n  let onBeforeInputFallback = (0, $kOq5K$useEffectEvent)(e => {\n    let input = inputRef.current;\n    // Compute the next value of the input if the event is allowed to proceed.\n    // See https://www.w3.org/TR/input-events-2/#interface-InputEvent-Attributes for a full list of input types.\n    let nextValue;\n    switch (e.inputType) {\n      case \"historyUndo\":\n      case \"historyRedo\":\n        // Explicitly allow undo/redo. e.data is null in this case, but there's no need to validate,\n        // because presumably the input would have already been validated previously.\n        return;\n      case \"deleteContent\":\n      case \"deleteByCut\":\n      case \"deleteByDrag\":\n        nextValue = input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n        break;\n      case \"deleteContentForward\":\n        // This is potentially incorrect, since the browser may actually delete more than a single UTF-16\n        // character. In reality, a full Unicode grapheme cluster consisting of multiple UTF-16 characters\n        // or code points may be deleted. However, in our currently supported locales, there are no such cases.\n        // If we support additional locales in the future, this may need to change.\n        nextValue = input.selectionEnd === input.selectionStart ? input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd + 1) : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n        break;\n      case \"deleteContentBackward\":\n        nextValue = input.selectionEnd === input.selectionStart ? input.value.slice(0, input.selectionStart - 1) + input.value.slice(input.selectionStart) : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n        break;\n      case \"deleteSoftLineBackward\":\n      case \"deleteHardLineBackward\":\n        nextValue = input.value.slice(input.selectionStart);\n        break;\n      default:\n        if (e.data != null) nextValue = input.value.slice(0, input.selectionStart) + e.data + input.value.slice(input.selectionEnd);\n        break;\n    }\n    // If we did not compute a value, or the new value is invalid, prevent the event\n    // so that the browser does not update the input text, move the selection, or add to\n    // the undo/redo stack.\n    if (nextValue == null || !state.validate(nextValue)) e.preventDefault();\n  });\n  (0, $kOq5K$useEffect)(() => {\n    if (!$d841c8010a73d545$var$supportsNativeBeforeInputEvent()) return;\n    let input = inputRef.current;\n    input.addEventListener(\"beforeinput\", onBeforeInputFallback, false);\n    return () => {\n      input.removeEventListener(\"beforeinput\", onBeforeInputFallback, false);\n    };\n  }, [inputRef, onBeforeInputFallback]);\n  let onBeforeInput = !$d841c8010a73d545$var$supportsNativeBeforeInputEvent() ? e => {\n    let nextValue = e.target.value.slice(0, e.target.selectionStart) + e.data + e.target.value.slice(e.target.selectionEnd);\n    if (!state.validate(nextValue)) e.preventDefault();\n  } : null;\n  let {\n    labelProps: labelProps,\n    inputProps: textFieldProps,\n    descriptionProps: descriptionProps,\n    errorMessageProps: errorMessageProps\n  } = (0, $2d73ec29415bd339$export$712718f7aec83d5)(props, inputRef);\n  let compositionStartState = (0, $kOq5K$useRef)(null);\n  return {\n    inputProps: (0, $kOq5K$mergeProps)(textFieldProps, {\n      onBeforeInput: onBeforeInput,\n      onCompositionStart() {\n        // Chrome does not implement Input Events Level 2, which specifies the insertFromComposition\n        // and deleteByComposition inputType values for the beforeinput event. These are meant to occur\n        // at the end of a composition (e.g. Pinyin IME, Android auto correct, etc.), and crucially, are\n        // cancelable. The insertCompositionText and deleteCompositionText input types are not cancelable,\n        // nor would we want to cancel them because the input from the user is incomplete at that point.\n        // In Safari, insertFromComposition/deleteFromComposition will fire, however, allowing us to cancel\n        // the final composition result if it is invalid. As a fallback for Chrome and Firefox, which either\n        // don't support Input Events Level 2, or beforeinput at all, we store the state of the input when\n        // the compositionstart event fires, and undo the changes in compositionend (below) if it is invalid.\n        // Unfortunately, this messes up the undo/redo stack, but until insertFromComposition/deleteByComposition\n        // are implemented, there is no other way to prevent composed input.\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=1022204\n        let {\n          value: value,\n          selectionStart: selectionStart,\n          selectionEnd: selectionEnd\n        } = inputRef.current;\n        compositionStartState.current = {\n          value: value,\n          selectionStart: selectionStart,\n          selectionEnd: selectionEnd\n        };\n      },\n      onCompositionEnd() {\n        if (!state.validate(inputRef.current.value)) {\n          // Restore the input value in the DOM immediately so we can synchronously update the selection position.\n          // But also update the value in React state as well so it is correct for future updates.\n          let {\n            value: value,\n            selectionStart: selectionStart,\n            selectionEnd: selectionEnd\n          } = compositionStartState.current;\n          inputRef.current.value = value;\n          inputRef.current.setSelectionRange(selectionStart, selectionEnd);\n          state.setInputValue(value);\n        }\n      }\n    }),\n    labelProps: labelProps,\n    descriptionProps: descriptionProps,\n    errorMessageProps: errorMessageProps\n  };\n}\nexport { $2d73ec29415bd339$export$712718f7aec83d5 as useTextField, $d841c8010a73d545$export$4f384c9210e583c3 as useFormattedTextField };\n//# sourceMappingURL=module.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}