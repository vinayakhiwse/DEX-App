{"ast":null,"code":"\"use client\";\n\n// src/config.ts\nimport { createSyncStoragePersister } from \"@tanstack/query-sync-storage-persister\";\nimport { QueryClient } from \"@tanstack/react-query\";\nimport { persistQueryClient } from \"@tanstack/react-query-persist-client\";\nimport { createConfig as createCoreConfig, createStorage, noopStorage } from \"@wagmi/core\";\nfunction createConfig({\n  queryClient = new QueryClient({\n    defaultOptions: {\n      queries: {\n        cacheTime: 1e3 * 60 * 60 * 24,\n        networkMode: \"offlineFirst\",\n        refetchOnWindowFocus: false,\n        retry: 0\n      },\n      mutations: {\n        networkMode: \"offlineFirst\"\n      }\n    }\n  }),\n  storage = createStorage({\n    storage: typeof window !== \"undefined\" && window.localStorage ? window.localStorage : noopStorage\n  }),\n  persister = typeof window !== \"undefined\" ? createSyncStoragePersister({\n    key: \"cache\",\n    storage,\n    serialize: x => x,\n    deserialize: x => x\n  }) : void 0,\n  ...args\n}) {\n  const config = createCoreConfig({\n    ...args,\n    storage\n  });\n  if (persister) persistQueryClient({\n    queryClient,\n    persister,\n    dehydrateOptions: {\n      shouldDehydrateQuery: query => query.cacheTime !== 0 && query.queryKey[0].persist !== false\n    }\n  });\n  return Object.assign(config, {\n    queryClient\n  });\n}\n\n// src/context.ts\nimport { QueryClientProvider } from \"@tanstack/react-query\";\nimport * as React from \"react\";\nvar Context = React.createContext(void 0);\nvar queryClientContext = React.createContext(void 0);\nfunction WagmiConfig({\n  children,\n  config\n}) {\n  return React.createElement(Context.Provider, {\n    children: React.createElement(QueryClientProvider, {\n      children,\n      client: config.queryClient,\n      context: queryClientContext\n    }),\n    value: config\n  });\n}\nfunction useConfig() {\n  const config = React.useContext(Context);\n  if (!config) throw new Error([\"`useConfig` must be used within `WagmiConfig`.\\n\", \"Read more: https://wagmi.sh/react/WagmiConfig\"].join(\"\\n\"));\n  return config;\n}\n\n// src/hooks/accounts/useAccount.ts\nimport { getAccount, watchAccount } from \"@wagmi/core\";\nimport * as React9 from \"react\";\n\n// src/hooks/utils/query/useBaseQuery.ts\nimport { notifyManager, useIsRestoring, useQueryClient, useQueryErrorResetBoundary } from \"@tanstack/react-query\";\nimport * as React2 from \"react\";\n\n// src/hooks/utils/useSyncExternalStore.ts\nimport * as pkg from \"use-sync-external-store/shim/index.js\";\nvar useSyncExternalStore2 = pkg.useSyncExternalStore;\n\n// src/hooks/utils/query/utils.ts\nfunction isQueryKey(value) {\n  return Array.isArray(value);\n}\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  }\n  const ctor = o.constructor;\n  if (typeof ctor === \"undefined\") {\n    return true;\n  }\n  const prot = ctor.prototype;\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  }\n  if (!prot.hasOwnProperty(\"isPrototypeOf\")) {\n    return false;\n  }\n  return true;\n}\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === \"[object Object]\";\n}\nfunction parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n  if (typeof arg2 === \"function\") {\n    return {\n      ...arg3,\n      queryKey: arg1,\n      queryFn: arg2\n    };\n  }\n  return {\n    ...arg2,\n    queryKey: arg1\n  };\n}\nfunction queryKeyHashFn(queryKey17) {\n  return JSON.stringify(queryKey17, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : typeof val === \"bigint\" ? val.toString() : val);\n}\nfunction shouldThrowError(_useErrorBoundary, params) {\n  if (typeof _useErrorBoundary === \"function\") {\n    return _useErrorBoundary(...params);\n  }\n  return !!_useErrorBoundary;\n}\nfunction trackResult(result, observer) {\n  const trackedResult = {};\n  Object.keys(result).forEach(key => {\n    Object.defineProperty(trackedResult, key, {\n      configurable: false,\n      enumerable: true,\n      get: () => {\n        observer.trackedProps.add(key);\n        return result[key];\n      }\n    });\n  });\n  return trackedResult;\n}\n\n// src/hooks/utils/query/useBaseQuery.ts\nfunction useBaseQuery(options, Observer) {\n  const queryClient = useQueryClient({\n    context: options.context\n  });\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const defaultedOptions = queryClient.defaultQueryOptions({\n    ...options,\n    queryKeyHashFn\n  });\n  defaultedOptions._optimisticResults = isRestoring ? \"isRestoring\" : \"optimistic\";\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);\n  }\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);\n  }\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);\n  }\n  if (defaultedOptions.suspense) {\n    if (typeof defaultedOptions.staleTime !== \"number\") {\n      defaultedOptions.staleTime = 1e3;\n    }\n  }\n  if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {\n    if (!errorResetBoundary.isReset()) {\n      defaultedOptions.retryOnMount = false;\n    }\n  }\n  const [observer] = React2.useState(() => new Observer(queryClient, defaultedOptions));\n  const result = observer.getOptimisticResult(defaultedOptions);\n  useSyncExternalStore2(React2.useCallback(onStoreChange => isRestoring ? () => void 0 : observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());\n  React2.useEffect(() => {\n    errorResetBoundary.clearReset();\n  }, [errorResetBoundary]);\n  React2.useEffect(() => {\n    observer.setOptions(defaultedOptions, {\n      listeners: false\n    });\n  }, [defaultedOptions, observer]);\n  if (defaultedOptions.suspense && result.isLoading && result.isFetching && !isRestoring) {\n    throw observer.fetchOptimistic(defaultedOptions).then(({\n      data\n    }) => {\n      defaultedOptions.onSuccess?.(data);\n      defaultedOptions.onSettled?.(data, null);\n    }).catch(error => {\n      errorResetBoundary.clearReset();\n      defaultedOptions.onError?.(error);\n      defaultedOptions.onSettled?.(void 0, error);\n    });\n  }\n  if (result.isError && !errorResetBoundary.isReset() && !result.isFetching && shouldThrowError(defaultedOptions.useErrorBoundary, [result.error, observer.getCurrentQuery()])) {\n    throw result.error;\n  }\n  const status = result.status === \"loading\" && result.fetchStatus === \"idle\" ? \"idle\" : result.status;\n  const isIdle = status === \"idle\";\n  const isLoading = status === \"loading\" && result.fetchStatus === \"fetching\";\n  return {\n    ...result,\n    defaultedOptions,\n    isIdle,\n    isLoading,\n    observer,\n    status\n  };\n}\n\n// src/hooks/utils/query/useInfiniteQuery.ts\nimport { InfiniteQueryObserver } from \"@tanstack/react-query\";\nfunction useInfiniteQuery(arg1, arg2, arg3) {\n  const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n  const baseQuery = useBaseQuery({\n    context: queryClientContext,\n    ...parsedOptions\n  }, InfiniteQueryObserver);\n  const result = {\n    data: baseQuery.data,\n    error: baseQuery.error,\n    fetchNextPage: baseQuery.fetchNextPage,\n    fetchStatus: baseQuery.fetchStatus,\n    hasNextPage: baseQuery.hasNextPage,\n    isError: baseQuery.isError,\n    isFetched: baseQuery.isFetched,\n    isFetchedAfterMount: baseQuery.isFetchedAfterMount,\n    isFetching: baseQuery.isFetching,\n    isFetchingNextPage: baseQuery.isFetchingNextPage,\n    isIdle: baseQuery.isIdle,\n    isLoading: baseQuery.isLoading,\n    isRefetching: baseQuery.isRefetching,\n    isSuccess: baseQuery.isSuccess,\n    refetch: baseQuery.refetch,\n    status: baseQuery.status,\n    internal: {\n      dataUpdatedAt: baseQuery.dataUpdatedAt,\n      errorUpdatedAt: baseQuery.errorUpdatedAt,\n      failureCount: baseQuery.failureCount,\n      isFetchedAfterMount: baseQuery.isFetchedAfterMount,\n      isLoadingError: baseQuery.isLoadingError,\n      isPaused: baseQuery.isPaused,\n      isPlaceholderData: baseQuery.isPlaceholderData,\n      isPreviousData: baseQuery.isPreviousData,\n      isRefetchError: baseQuery.isRefetchError,\n      isStale: baseQuery.isStale,\n      remove: baseQuery.remove\n    }\n  };\n  return !baseQuery.defaultedOptions.notifyOnChangeProps ? trackResult(result, baseQuery.observer) : result;\n}\n\n// src/hooks/utils/query/useMutation.ts\nimport { parseMutationArgs, useMutation as useMutation_ } from \"@tanstack/react-query\";\nfunction useMutation(arg1, arg2, arg3) {\n  const options = parseMutationArgs(arg1, arg2, arg3);\n  return useMutation_({\n    context: queryClientContext,\n    ...options\n  });\n}\n\n// src/hooks/utils/query/useQuery.ts\nimport { QueryObserver } from \"@tanstack/react-query\";\nfunction useQuery(arg1, arg2, arg3) {\n  const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n  const baseQuery = useBaseQuery({\n    context: queryClientContext,\n    ...parsedOptions\n  }, QueryObserver);\n  const result = {\n    data: baseQuery.data,\n    error: baseQuery.error,\n    fetchStatus: baseQuery.fetchStatus,\n    isError: baseQuery.isError,\n    isFetched: baseQuery.isFetched,\n    isFetchedAfterMount: baseQuery.isFetchedAfterMount,\n    isFetching: baseQuery.isFetching,\n    isIdle: baseQuery.isIdle,\n    isLoading: baseQuery.isLoading,\n    isRefetching: baseQuery.isRefetching,\n    isSuccess: baseQuery.isSuccess,\n    refetch: baseQuery.refetch,\n    status: baseQuery.status,\n    internal: {\n      dataUpdatedAt: baseQuery.dataUpdatedAt,\n      errorUpdatedAt: baseQuery.errorUpdatedAt,\n      failureCount: baseQuery.failureCount,\n      isFetchedAfterMount: baseQuery.isFetchedAfterMount,\n      isLoadingError: baseQuery.isLoadingError,\n      isPaused: baseQuery.isPaused,\n      isPlaceholderData: baseQuery.isPlaceholderData,\n      isPreviousData: baseQuery.isPreviousData,\n      isRefetchError: baseQuery.isRefetchError,\n      isStale: baseQuery.isStale,\n      remove: baseQuery.remove\n    }\n  };\n  return !baseQuery.defaultedOptions.notifyOnChangeProps ? trackResult(result, baseQuery.observer) : result;\n}\n\n// src/hooks/utils/query/useQueryClient.ts\nimport { useQueryClient as useQueryClient_ } from \"@tanstack/react-query\";\nvar useQueryClient2 = () => useQueryClient_({\n  context: queryClientContext\n});\n\n// src/hooks/viem/usePublicClient.ts\nimport { getPublicClient, watchPublicClient } from \"@wagmi/core\";\nimport { useSyncExternalStoreWithSelector } from \"use-sync-external-store/shim/with-selector.js\";\nfunction usePublicClient({\n  chainId\n} = {}) {\n  return useSyncExternalStoreWithSelector(cb => watchPublicClient({\n    chainId\n  }, cb), () => getPublicClient({\n    chainId\n  }), () => getPublicClient({\n    chainId\n  }), x => x, (a, b) => a.uid === b.uid);\n}\n\n// src/hooks/viem/useWalletClient.ts\nimport { getWalletClient, watchWalletClient } from \"@wagmi/core\";\nimport * as React3 from \"react\";\nfunction queryKey({\n  chainId\n}) {\n  return [{\n    entity: \"walletClient\",\n    chainId,\n    persist: false\n  }];\n}\nfunction queryFn({\n  queryKey: [{\n    chainId\n  }]\n}) {\n  return getWalletClient({\n    chainId\n  });\n}\nfunction useWalletClient({\n  chainId: chainId_,\n  suspense,\n  onError,\n  onSettled,\n  onSuccess\n} = {}) {\n  const {\n    connector\n  } = useAccount();\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  const walletClientQuery = useQuery(queryKey({\n    chainId\n  }), queryFn, {\n    cacheTime: 0,\n    enabled: Boolean(connector),\n    staleTime: Infinity,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n  const queryClient = useQueryClient2();\n  React3.useEffect(() => {\n    const unwatch = watchWalletClient({\n      chainId\n    }, walletClient => {\n      if (walletClient) queryClient.invalidateQueries(queryKey({\n        chainId\n      }));else queryClient.removeQueries(queryKey({\n        chainId\n      }));\n    });\n    return unwatch;\n  }, [queryClient, chainId]);\n  return walletClientQuery;\n}\n\n// src/hooks/viem/useWebSocketPublicClient.ts\nimport { getWebSocketPublicClient, watchWebSocketPublicClient } from \"@wagmi/core\";\nimport { useSyncExternalStoreWithSelector as useSyncExternalStoreWithSelector2 } from \"use-sync-external-store/shim/with-selector.js\";\nfunction useWebSocketPublicClient({\n  chainId\n} = {}) {\n  return useSyncExternalStoreWithSelector2(cb => watchWebSocketPublicClient({\n    chainId\n  }, cb), () => getWebSocketPublicClient({\n    chainId\n  }), () => getWebSocketPublicClient({\n    chainId\n  }), x => x, (a, b) => a?.uid === b?.uid);\n}\n\n// src/hooks/utils/useChainId.ts\nfunction useChainId({\n  chainId\n} = {}) {\n  const publicClient = usePublicClient({\n    chainId\n  });\n  return publicClient.chain.id;\n}\n\n// src/hooks/utils/useForceUpdate.ts\nimport * as React4 from \"react\";\nfunction useForceUpdate() {\n  const [, forceUpdate] = React4.useReducer(x => x + 1, 0);\n  return forceUpdate;\n}\n\n// src/hooks/utils/useInvalidateOnBlock.ts\nimport * as React7 from \"react\";\n\n// src/hooks/network-status/useBlockNumber.ts\nimport { fetchBlockNumber } from \"@wagmi/core\";\nimport * as React5 from \"react\";\nfunction queryKey2({\n  chainId,\n  scopeKey\n}) {\n  return [{\n    entity: \"blockNumber\",\n    chainId,\n    scopeKey\n  }];\n}\nfunction queryFn2({\n  queryKey: [{\n    chainId\n  }]\n}) {\n  return fetchBlockNumber({\n    chainId\n  });\n}\nfunction useBlockNumber({\n  cacheTime = 0,\n  chainId: chainId_,\n  enabled = true,\n  scopeKey,\n  staleTime,\n  suspense,\n  watch = false,\n  onBlock,\n  onError,\n  onSettled,\n  onSuccess\n} = {}) {\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  const publicClient = usePublicClient({\n    chainId\n  });\n  const webSocketPublicClient = useWebSocketPublicClient({\n    chainId\n  });\n  const queryClient = useQueryClient2();\n  React5.useEffect(() => {\n    if (!enabled) return;\n    if (!watch && !onBlock) return;\n    const publicClient_ = webSocketPublicClient ?? publicClient;\n    const unwatch = publicClient_.watchBlockNumber({\n      onBlockNumber: blockNumber => {\n        if (watch) queryClient.setQueryData(queryKey2({\n          chainId,\n          scopeKey\n        }), blockNumber);\n        if (onBlock) onBlock(blockNumber);\n      },\n      emitOnBegin: true\n    });\n    return unwatch;\n  }, [chainId, scopeKey, onBlock, publicClient, queryClient, watch, webSocketPublicClient, enabled]);\n  return useQuery(queryKey2({\n    scopeKey,\n    chainId\n  }), queryFn2, {\n    cacheTime,\n    enabled,\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\n// src/hooks/network-status/useFeeData.ts\nimport { fetchFeeData } from \"@wagmi/core\";\nimport * as React6 from \"react\";\nfunction queryKey3({\n  chainId,\n  formatUnits,\n  scopeKey\n}) {\n  return [{\n    entity: \"feeData\",\n    chainId,\n    formatUnits,\n    scopeKey\n  }];\n}\nfunction queryFn3({\n  queryKey: [{\n    chainId,\n    formatUnits\n  }]\n}) {\n  return fetchFeeData({\n    chainId,\n    formatUnits\n  });\n}\nfunction useFeeData({\n  cacheTime,\n  chainId: chainId_,\n  enabled = true,\n  formatUnits = \"gwei\",\n  scopeKey,\n  staleTime,\n  suspense,\n  watch,\n  onError,\n  onSettled,\n  onSuccess\n} = {}) {\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  const queryKey_ = React6.useMemo(() => queryKey3({\n    chainId,\n    formatUnits,\n    scopeKey\n  }), [chainId, formatUnits, scopeKey]);\n  const feeDataQuery = useQuery(queryKey_, queryFn3, {\n    cacheTime,\n    enabled,\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n  useInvalidateOnBlock({\n    chainId,\n    enabled: Boolean(enabled && watch),\n    queryKey: queryKey_\n  });\n  return feeDataQuery;\n}\n\n// src/hooks/utils/useInvalidateOnBlock.ts\nfunction useInvalidateOnBlock({\n  chainId,\n  enabled,\n  queryKey: queryKey17\n}) {\n  const queryClient = useQueryClient2();\n  const onBlock = React7.useCallback(() => queryClient.invalidateQueries({\n    queryKey: queryKey17\n  }, {\n    cancelRefetch: false\n  }), [queryClient, queryKey17]);\n  useBlockNumber({\n    chainId,\n    enabled,\n    onBlock: enabled ? onBlock : void 0,\n    scopeKey: enabled ? void 0 : \"idle\"\n  });\n}\n\n// src/hooks/utils/useSyncExternalStoreWithTracked.ts\nimport { deepEqual } from \"@wagmi/core\";\nimport * as React8 from \"react\";\nimport { useSyncExternalStoreWithSelector as useSyncExternalStoreWithSelector3 } from \"use-sync-external-store/shim/with-selector.js\";\nvar isPlainObject2 = obj => typeof obj === \"object\" && !Array.isArray(obj);\nfunction useSyncExternalStoreWithTracked(subscribe, getSnapshot, getServerSnapshot = getSnapshot, isEqual = deepEqual) {\n  const trackedKeys = React8.useRef([]);\n  const result = useSyncExternalStoreWithSelector3(subscribe, getSnapshot, getServerSnapshot, x => x, (a, b) => {\n    if (isPlainObject2(a) && isPlainObject2(b) && trackedKeys.current.length) {\n      for (const key of trackedKeys.current) {\n        const equal = isEqual(a[key], b[key]);\n        if (!equal) return false;\n      }\n      return true;\n    }\n    return isEqual(a, b);\n  });\n  if (isPlainObject2(result)) {\n    const trackedResult = {\n      ...result\n    };\n    Object.defineProperties(trackedResult, Object.entries(trackedResult).reduce((res, [key, value]) => {\n      return {\n        ...res,\n        [key]: {\n          configurable: false,\n          enumerable: true,\n          get: () => {\n            if (!trackedKeys.current.includes(key)) {\n              trackedKeys.current.push(key);\n            }\n            return value;\n          }\n        }\n      };\n    }, {}));\n    return trackedResult;\n  }\n  return result;\n}\n\n// src/hooks/accounts/useAccount.ts\nfunction useAccount({\n  onConnect,\n  onDisconnect\n} = {}) {\n  const config = useConfig();\n  const watchAccount_ = React9.useCallback(callback => watchAccount(callback), [config]);\n  const account = useSyncExternalStoreWithTracked(watchAccount_, getAccount);\n  const previousAccountRef = React9.useRef();\n  const previousAccount = previousAccountRef.current;\n  React9.useEffect(() => {\n    if (previousAccount?.status !== \"connected\" && account.status === \"connected\") {\n      onConnect?.({\n        address: account.address,\n        connector: account.connector,\n        isReconnected: previousAccount?.status === \"reconnecting\" || previousAccount?.status === void 0\n      });\n    }\n    if (previousAccount?.status === \"connected\" && account.status === \"disconnected\") {\n      onDisconnect?.();\n    }\n    previousAccountRef.current = account;\n  }, [onConnect, onDisconnect, previousAccount, account]);\n  return account;\n}\n\n// src/hooks/accounts/useBalance.ts\nimport { fetchBalance } from \"@wagmi/core\";\nimport * as React10 from \"react\";\nfunction queryKey4({\n  address,\n  chainId,\n  formatUnits,\n  scopeKey,\n  token\n}) {\n  return [{\n    entity: \"balance\",\n    address,\n    chainId,\n    formatUnits,\n    scopeKey,\n    token\n  }];\n}\nfunction queryFn4({\n  queryKey: [{\n    address,\n    chainId,\n    formatUnits,\n    token\n  }]\n}) {\n  if (!address) throw new Error(\"address is required\");\n  return fetchBalance({\n    address,\n    chainId,\n    formatUnits,\n    token\n  });\n}\nfunction useBalance({\n  address,\n  cacheTime,\n  chainId: chainId_,\n  enabled = true,\n  formatUnits,\n  scopeKey,\n  staleTime,\n  suspense,\n  token,\n  watch,\n  onError,\n  onSettled,\n  onSuccess\n} = {}) {\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  const queryKey_ = React10.useMemo(() => queryKey4({\n    address,\n    chainId,\n    formatUnits,\n    scopeKey,\n    token\n  }), [address, chainId, formatUnits, scopeKey, token]);\n  const balanceQuery = useQuery(queryKey_, queryFn4, {\n    cacheTime,\n    enabled: Boolean(enabled && address),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n  useInvalidateOnBlock({\n    chainId,\n    enabled: Boolean(enabled && watch && address),\n    queryKey: queryKey_\n  });\n  return balanceQuery;\n}\n\n// src/hooks/accounts/useConnect.ts\nimport { connect } from \"@wagmi/core\";\nimport * as React11 from \"react\";\nvar mutationKey = args => [{\n  entity: \"connect\",\n  ...args\n}];\nvar mutationFn = args => {\n  const {\n    connector,\n    chainId\n  } = args;\n  if (!connector) throw new Error(\"connector is required\");\n  return connect({\n    connector,\n    chainId\n  });\n};\nfunction useConnect({\n  chainId,\n  connector,\n  onError,\n  onMutate,\n  onSettled,\n  onSuccess\n} = {}) {\n  const config = useConfig();\n  const {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    mutate,\n    mutateAsync,\n    reset,\n    status,\n    variables\n  } = useMutation(mutationKey({\n    connector,\n    chainId\n  }), mutationFn, {\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  });\n  const connect2 = React11.useCallback(args => {\n    return mutate({\n      chainId: args?.chainId ?? chainId,\n      connector: args?.connector ?? connector\n    });\n  }, [chainId, connector, mutate]);\n  const connectAsync = React11.useCallback(args => {\n    return mutateAsync({\n      chainId: args?.chainId ?? chainId,\n      connector: args?.connector ?? connector\n    });\n  }, [chainId, connector, mutateAsync]);\n  return {\n    connect: connect2,\n    connectAsync,\n    connectors: config.connectors,\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    pendingConnector: variables?.connector,\n    reset,\n    status,\n    variables\n  };\n}\n\n// src/hooks/accounts/useDisconnect.ts\nimport { disconnect } from \"@wagmi/core\";\nvar mutationKey2 = [{\n  entity: \"disconnect\"\n}];\nvar mutationFn2 = () => disconnect();\nfunction useDisconnect({\n  onError,\n  onMutate,\n  onSettled,\n  onSuccess\n} = {}) {\n  const {\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    mutate: disconnect2,\n    mutateAsync: disconnectAsync,\n    reset,\n    status\n  } = useMutation(mutationKey2, mutationFn2, {\n    ...(onError ? {\n      onError(error2, _variables, context) {\n        onError(error2, context);\n      }\n    } : {}),\n    onMutate,\n    ...(onSettled ? {\n      onSettled(_data, error2, _variables, context) {\n        onSettled(error2, context);\n      }\n    } : {}),\n    ...(onSuccess ? {\n      onSuccess(_data, _variables, context) {\n        onSuccess(context);\n      }\n    } : {})\n  });\n  return {\n    disconnect: disconnect2,\n    disconnectAsync,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    reset,\n    status\n  };\n}\n\n// src/hooks/accounts/useNetwork.ts\nimport { getNetwork, watchNetwork } from \"@wagmi/core\";\nimport { useCallback as useCallback5 } from \"react\";\nfunction useNetwork() {\n  const config = useConfig();\n  const watchNetwork_ = useCallback5(callback => watchNetwork(callback), [config]);\n  return useSyncExternalStoreWithTracked(watchNetwork_, getNetwork);\n}\n\n// src/hooks/accounts/useSignMessage.ts\nimport { signMessage } from \"@wagmi/core\";\nimport * as React12 from \"react\";\nvar mutationKey3 = args => [{\n  entity: \"signMessage\",\n  ...args\n}];\nvar mutationFn3 = args => {\n  const {\n    message\n  } = args;\n  if (!message) throw new Error(\"message is required\");\n  return signMessage({\n    message\n  });\n};\nfunction useSignMessage({\n  message,\n  onError,\n  onMutate,\n  onSettled,\n  onSuccess\n} = {}) {\n  const {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    mutate,\n    mutateAsync,\n    reset,\n    status,\n    variables\n  } = useMutation(mutationKey3({\n    message\n  }), mutationFn3, {\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  });\n  const signMessage2 = React12.useCallback(args => mutate(args || {\n    message\n  }), [message, mutate]);\n  const signMessageAsync = React12.useCallback(args => mutateAsync(args || {\n    message\n  }), [message, mutateAsync]);\n  return {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    reset,\n    signMessage: signMessage2,\n    signMessageAsync,\n    status,\n    variables\n  };\n}\n\n// src/hooks/accounts/useSignTypedData.ts\nimport { signTypedData } from \"@wagmi/core\";\nimport * as React13 from \"react\";\nfunction mutationKey4({\n  domain,\n  types,\n  message,\n  primaryType\n}) {\n  return [{\n    entity: \"signTypedData\",\n    domain,\n    types,\n    message,\n    primaryType\n  }];\n}\nfunction mutationFn4(args) {\n  const {\n    domain,\n    types,\n    primaryType,\n    message\n  } = args;\n  if (!domain) throw new Error(\"domain is required\");\n  if (!types) throw new Error(\"types is required\");\n  if (!primaryType) throw new Error(\"primaryType is required\");\n  if (!message) throw new Error(\"message is required\");\n  return signTypedData({\n    domain,\n    message,\n    primaryType,\n    types\n  });\n}\nfunction useSignTypedData({\n  domain,\n  types,\n  message,\n  primaryType,\n  onError,\n  onMutate,\n  onSettled,\n  onSuccess\n} = {}) {\n  const {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    mutate,\n    mutateAsync,\n    reset,\n    status,\n    variables\n  } = useMutation(mutationKey4({\n    domain,\n    message,\n    primaryType,\n    types\n  }), mutationFn4, {\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  });\n  const signTypedData2 = React13.useCallback(args => mutate({\n    domain: args?.domain ?? domain,\n    types: args?.types ?? types,\n    message: args?.message ?? message,\n    primaryType: args?.primaryType ?? primaryType\n  }), [domain, types, primaryType, message, mutate]);\n  const signTypedDataAsync = React13.useCallback(args => mutateAsync({\n    domain: args?.domain ?? domain,\n    types: args?.types ?? types,\n    message: args?.message ?? message,\n    primaryType: args?.primaryType ?? primaryType\n  }), [domain, types, primaryType, message, mutateAsync]);\n  return {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    reset,\n    signTypedData: signTypedData2,\n    signTypedDataAsync,\n    status,\n    variables\n  };\n}\n\n// src/hooks/accounts/useSwitchNetwork.ts\nimport { switchNetwork } from \"@wagmi/core\";\nimport * as React14 from \"react\";\nvar mutationKey5 = args => [{\n  entity: \"switchNetwork\",\n  ...args\n}];\nvar mutationFn5 = args => {\n  const {\n    chainId\n  } = args;\n  if (!chainId) throw new Error(\"chainId is required\");\n  return switchNetwork({\n    chainId\n  });\n};\nfunction useSwitchNetwork({\n  chainId,\n  throwForSwitchChainNotSupported,\n  onError,\n  onMutate,\n  onSettled,\n  onSuccess\n} = {}) {\n  const config = useConfig();\n  const forceUpdate = useForceUpdate();\n  const {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    mutate,\n    mutateAsync,\n    reset,\n    status,\n    variables\n  } = useMutation(mutationKey5({\n    chainId\n  }), mutationFn5, {\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  });\n  const switchNetwork_ = React14.useCallback(chainId_ => mutate({\n    chainId: chainId_ ?? chainId\n  }), [chainId, mutate]);\n  const switchNetworkAsync_ = React14.useCallback(chainId_ => mutateAsync({\n    chainId: chainId_ ?? chainId\n  }), [chainId, mutateAsync]);\n  React14.useEffect(() => {\n    const unwatch = config.subscribe(({\n      chains,\n      connector\n    }) => ({\n      chains,\n      connector\n    }), forceUpdate);\n    return unwatch;\n  }, [config, forceUpdate]);\n  let switchNetwork2;\n  let switchNetworkAsync;\n  const supportsSwitchChain = !!config.connector?.switchChain;\n  if (throwForSwitchChainNotSupported || supportsSwitchChain) {\n    switchNetwork2 = switchNetwork_;\n    switchNetworkAsync = switchNetworkAsync_;\n  }\n  return {\n    chains: config.chains ?? [],\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    pendingChainId: variables?.chainId,\n    reset,\n    status,\n    switchNetwork: switchNetwork2,\n    switchNetworkAsync,\n    variables\n  };\n}\n\n// src/hooks/contracts/useContractEvent.ts\nimport * as React15 from \"react\";\nfunction useContractEvent({\n  address,\n  chainId,\n  abi,\n  listener,\n  eventName\n} = {}) {\n  const publicClient = usePublicClient({\n    chainId\n  });\n  const webSocketPublicClient = useWebSocketPublicClient({\n    chainId\n  });\n  const unwatch = React15.useRef();\n  React15.useEffect(() => {\n    if (!abi || !address || !eventName) return;\n    const publicClient_ = webSocketPublicClient || publicClient;\n    unwatch.current = publicClient_.watchContractEvent({\n      abi,\n      address,\n      eventName,\n      onLogs: listener\n    });\n    return unwatch.current;\n  }, [abi, address, eventName, publicClient.uid, webSocketPublicClient?.uid]);\n  return unwatch.current;\n}\n\n// src/hooks/contracts/useContractInfiniteReads.ts\nimport { replaceEqualDeep } from \"@tanstack/react-query\";\nimport { deepEqual as deepEqual2, readContracts } from \"@wagmi/core\";\nimport * as React16 from \"react\";\nfunction queryKey5({\n  allowFailure,\n  blockNumber,\n  blockTag,\n  cacheKey,\n  scopeKey\n}) {\n  return [{\n    entity: \"readContractsInfinite\",\n    allowFailure,\n    blockNumber,\n    blockTag,\n    cacheKey,\n    scopeKey\n  }];\n}\nfunction queryFn5({\n  contracts\n}) {\n  return ({\n    queryKey: [{\n      allowFailure,\n      blockNumber,\n      blockTag\n    }],\n    pageParam\n  }) => {\n    return readContracts({\n      allowFailure,\n      blockNumber,\n      blockTag,\n      contracts: contracts(pageParam || void 0)\n    });\n  };\n}\nfunction useContractInfiniteReads({\n  allowFailure,\n  blockNumber,\n  blockTag,\n  cacheKey,\n  cacheTime,\n  contracts,\n  enabled: enabled_ = true,\n  getNextPageParam,\n  isDataEqual,\n  keepPreviousData,\n  onError,\n  onSettled,\n  onSuccess,\n  scopeKey,\n  select,\n  staleTime,\n  structuralSharing = (oldData, newData) => deepEqual2(oldData, newData) ? oldData : replaceEqualDeep(oldData, newData),\n  suspense\n}) {\n  const queryKey_ = React16.useMemo(() => queryKey5({\n    allowFailure,\n    blockNumber,\n    blockTag,\n    cacheKey,\n    scopeKey\n  }), [allowFailure, blockNumber, blockTag, cacheKey, scopeKey]);\n  const enabled = React16.useMemo(() => {\n    const enabled2 = Boolean(enabled_ && contracts);\n    return enabled2;\n  }, [contracts, enabled_]);\n  return useInfiniteQuery(queryKey_, queryFn5({\n    contracts\n  }), {\n    cacheTime,\n    enabled,\n    getNextPageParam,\n    isDataEqual,\n    keepPreviousData,\n    select,\n    staleTime,\n    structuralSharing,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\nfunction paginatedIndexesConfig(fn, {\n  perPage,\n  start,\n  direction\n}) {\n  const contracts = (page = 0) => [...Array(perPage).keys()].map(index => {\n    return direction === \"increment\" ? start + index + page * perPage : start - index - page * perPage;\n  }).filter(index => index >= 0).flatMap(fn);\n  return {\n    contracts,\n    getNextPageParam(lastPage, pages) {\n      return lastPage?.length === perPage ? pages.length : void 0;\n    }\n  };\n}\n\n// src/hooks/contracts/useContractRead.ts\nimport { replaceEqualDeep as replaceEqualDeep2 } from \"@tanstack/react-query\";\nimport { deepEqual as deepEqual3, readContract } from \"@wagmi/core\";\nimport * as React17 from \"react\";\nfunction queryKey6({\n  account,\n  address,\n  args,\n  blockNumber,\n  blockTag,\n  chainId,\n  functionName,\n  scopeKey\n}) {\n  return [{\n    entity: \"readContract\",\n    account,\n    address,\n    args,\n    blockNumber,\n    blockTag,\n    chainId,\n    functionName,\n    scopeKey\n  }];\n}\nfunction queryFn6({\n  abi\n}) {\n  return async ({\n    queryKey: [{\n      account,\n      address,\n      args,\n      blockNumber,\n      blockTag,\n      chainId,\n      functionName\n    }]\n  }) => {\n    if (!abi) throw new Error(\"abi is required\");\n    if (!address) throw new Error(\"address is required\");\n    return (await readContract({\n      account,\n      address,\n      args,\n      blockNumber,\n      blockTag,\n      chainId,\n      abi,\n      functionName\n    })) ?? null;\n  };\n}\nfunction useContractRead({\n  abi,\n  address,\n  account,\n  args,\n  blockNumber: blockNumberOverride,\n  blockTag,\n  cacheOnBlock = false,\n  cacheTime,\n  chainId: chainId_,\n  enabled: enabled_ = true,\n  functionName,\n  isDataEqual,\n  keepPreviousData,\n  onError,\n  onSettled,\n  onSuccess,\n  scopeKey,\n  select,\n  staleTime,\n  structuralSharing = (oldData, newData) => deepEqual3(oldData, newData) ? oldData : replaceEqualDeep2(oldData, newData),\n  suspense,\n  watch\n} = {}) {\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  const {\n    data: blockNumber_\n  } = useBlockNumber({\n    chainId,\n    enabled: watch || cacheOnBlock,\n    scopeKey: watch || cacheOnBlock ? void 0 : \"idle\",\n    watch\n  });\n  const blockNumber = blockNumberOverride ?? blockNumber_;\n  const queryKey_ = React17.useMemo(() => queryKey6({\n    account,\n    address,\n    args,\n    blockNumber: cacheOnBlock ? blockNumber : void 0,\n    blockTag,\n    chainId,\n    functionName,\n    scopeKey\n  }), [account, address, args, blockNumber, blockTag, cacheOnBlock, chainId, functionName, scopeKey]);\n  const enabled = React17.useMemo(() => {\n    let enabled2 = Boolean(enabled_ && abi && address && functionName);\n    if (cacheOnBlock) enabled2 = Boolean(enabled2 && blockNumber);\n    return enabled2;\n  }, [abi, address, blockNumber, cacheOnBlock, enabled_, functionName]);\n  useInvalidateOnBlock({\n    chainId,\n    enabled: Boolean(enabled && watch && !cacheOnBlock),\n    queryKey: queryKey_\n  });\n  return useQuery(queryKey_, queryFn6({\n    abi\n  }), {\n    cacheTime,\n    enabled,\n    isDataEqual,\n    keepPreviousData,\n    select,\n    staleTime,\n    structuralSharing,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\n// src/hooks/contracts/useContractReads.ts\nimport { replaceEqualDeep as replaceEqualDeep3 } from \"@tanstack/react-query\";\nimport { deepEqual as deepEqual4, readContracts as readContracts2 } from \"@wagmi/core\";\nimport * as React18 from \"react\";\nfunction queryKey7({\n  allowFailure,\n  blockNumber,\n  blockTag,\n  chainId,\n  contracts,\n  scopeKey\n}) {\n  return [{\n    entity: \"readContracts\",\n    allowFailure,\n    blockNumber,\n    blockTag,\n    chainId,\n    scopeKey,\n    contracts: (contracts ?? []).map(({\n      address,\n      args,\n      chainId: chainId2,\n      functionName\n    }) => ({\n      address,\n      args,\n      chainId: chainId2,\n      functionName\n    }))\n  }];\n}\nfunction queryFn7({\n  abis\n}) {\n  return ({\n    queryKey: [{\n      allowFailure,\n      blockNumber,\n      blockTag,\n      contracts: contracts_\n    }]\n  }) => {\n    const contracts = contracts_.map((contract, i) => ({\n      ...contract,\n      abi: abis[i]\n    }));\n    return readContracts2({\n      allowFailure,\n      contracts,\n      blockNumber,\n      blockTag\n    });\n  };\n}\nfunction useContractReads({\n  allowFailure: allowFailure_,\n  blockNumber: blockNumberOverride,\n  blockTag,\n  cacheOnBlock = false,\n  cacheTime,\n  contracts,\n  enabled: enabled_ = true,\n  isDataEqual,\n  keepPreviousData,\n  onError,\n  onSettled,\n  onSuccess,\n  scopeKey,\n  select,\n  staleTime,\n  structuralSharing = (oldData, newData) => deepEqual4(oldData, newData) ? oldData : replaceEqualDeep3(oldData, newData),\n  suspense,\n  watch\n} = {}) {\n  const allowFailure = allowFailure_ ?? true;\n  const {\n    data: blockNumber_\n  } = useBlockNumber({\n    enabled: watch || cacheOnBlock,\n    watch\n  });\n  const chainId = useChainId();\n  const blockNumber = blockNumberOverride ?? blockNumber_;\n  const queryKey_ = React18.useMemo(() => queryKey7({\n    allowFailure,\n    blockNumber: cacheOnBlock ? blockNumber : void 0,\n    blockTag,\n    chainId,\n    contracts,\n    scopeKey\n  }), [allowFailure, blockNumber, blockTag, cacheOnBlock, chainId, scopeKey, contracts]);\n  const enabled = React18.useMemo(() => {\n    let enabled2 = Boolean(enabled_ && contracts?.every(x => x.abi && x.address && x.functionName));\n    if (cacheOnBlock) enabled2 = Boolean(enabled2 && blockNumber);\n    return enabled2;\n  }, [blockNumber, cacheOnBlock, contracts, enabled_]);\n  useInvalidateOnBlock({\n    enabled: Boolean(enabled && watch && !cacheOnBlock),\n    queryKey: queryKey_\n  });\n  const abis = (contracts ?? []).map(({\n    abi\n  }) => abi);\n  return useQuery(queryKey_, queryFn7({\n    abis\n  }), {\n    cacheTime,\n    enabled,\n    isDataEqual,\n    keepPreviousData,\n    staleTime,\n    select,\n    structuralSharing,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\n// src/hooks/contracts/useContractWrite.ts\nimport { writeContract } from \"@wagmi/core\";\nimport { getSendTransactionParameters } from \"@wagmi/core/internal\";\nimport * as React19 from \"react\";\nfunction mutationKey6({\n  address,\n  abi,\n  functionName,\n  ...config\n}) {\n  const {\n    args,\n    accessList,\n    account,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    request,\n    value\n  } = config;\n  return [{\n    entity: \"writeContract\",\n    address,\n    args,\n    abi,\n    accessList,\n    account,\n    functionName,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    request,\n    value\n  }];\n}\nfunction mutationFn6(config) {\n  if (config.mode === \"prepared\") {\n    if (!config.request) throw new Error(\"request is required\");\n    return writeContract({\n      mode: \"prepared\",\n      request: config.request\n    });\n  }\n  if (!config.address) throw new Error(\"address is required\");\n  if (!config.abi) throw new Error(\"abi is required\");\n  if (!config.functionName) throw new Error(\"functionName is required\");\n  return writeContract({\n    address: config.address,\n    args: config.args,\n    chainId: config.chainId,\n    abi: config.abi,\n    functionName: config.functionName,\n    accessList: config.accessList,\n    account: config.account,\n    gas: config.gas,\n    gasPrice: config.gasPrice,\n    maxFeePerGas: config.maxFeePerGas,\n    maxPriorityFeePerGas: config.maxPriorityFeePerGas,\n    nonce: config.nonce,\n    value: config.value\n  });\n}\nfunction useContractWrite(config) {\n  const {\n    address,\n    abi,\n    args,\n    chainId,\n    functionName,\n    mode,\n    request\n  } = config;\n  const {\n    accessList,\n    account,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    value\n  } = getSendTransactionParameters(config);\n  const {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    mutate,\n    mutateAsync,\n    reset,\n    status,\n    variables\n  } = useMutation(mutationKey6({\n    address,\n    abi,\n    functionName,\n    chainId,\n    mode,\n    args,\n    accessList,\n    account,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    request,\n    value\n  }), mutationFn6, {\n    onError: config.onError,\n    onMutate: config.onMutate,\n    onSettled: config.onSettled,\n    onSuccess: config.onSuccess\n  });\n  const write = React19.useMemo(() => {\n    if (config.mode === \"prepared\") {\n      if (!request) return void 0;\n      return () => mutate({\n        mode: \"prepared\",\n        request: config.request,\n        chainId: config.chainId\n      });\n    }\n    return overrideConfig => mutate({\n      address,\n      args,\n      abi,\n      functionName,\n      chainId,\n      accessList,\n      account,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      value,\n      ...overrideConfig\n    });\n  }, [accessList, account, abi, address, args, chainId, config.chainId, config.mode, config.request, functionName, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, mutate, nonce, request, value]);\n  const writeAsync = React19.useMemo(() => {\n    if (config.mode === \"prepared\") {\n      if (!request) return void 0;\n      return () => mutateAsync({\n        mode: \"prepared\",\n        request: config.request\n      });\n    }\n    return overrideConfig => mutateAsync({\n      address,\n      args,\n      abi,\n      chainId,\n      functionName,\n      accessList,\n      account,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      value,\n      ...overrideConfig\n    });\n  }, [accessList, account, abi, address, args, chainId, config.mode, config.request, functionName, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, mutateAsync, nonce, request, value]);\n  return {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    reset,\n    status,\n    variables,\n    write,\n    writeAsync\n  };\n}\n\n// src/hooks/contracts/usePrepareContractWrite.ts\nimport { prepareWriteContract } from \"@wagmi/core\";\nimport { getCallParameters } from \"@wagmi/core/internal\";\nfunction queryKey8({\n  accessList,\n  account,\n  activeChainId,\n  args,\n  address,\n  blockNumber,\n  blockTag,\n  chainId,\n  functionName,\n  gas,\n  gasPrice,\n  maxFeePerGas,\n  maxPriorityFeePerGas,\n  nonce,\n  scopeKey,\n  walletClientAddress,\n  value\n}) {\n  return [{\n    entity: \"prepareContractTransaction\",\n    accessList,\n    account,\n    activeChainId,\n    address,\n    args,\n    blockNumber,\n    blockTag,\n    chainId,\n    functionName,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    scopeKey,\n    walletClientAddress,\n    value\n  }];\n}\nfunction queryFn8({\n  abi,\n  walletClient\n}) {\n  return ({\n    queryKey: [{\n      accessList,\n      account,\n      args,\n      address,\n      blockNumber,\n      blockTag,\n      chainId,\n      functionName,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      value\n    }]\n  }) => {\n    if (!abi) throw new Error(\"abi is required\");\n    if (!address) throw new Error(\"address is required\");\n    if (!functionName) throw new Error(\"functionName is required\");\n    return prepareWriteContract({\n      abi,\n      accessList,\n      account,\n      args,\n      address,\n      blockNumber,\n      blockTag,\n      chainId,\n      functionName,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      walletClient,\n      value\n    });\n  };\n}\nfunction usePrepareContractWrite({\n  address,\n  abi,\n  functionName,\n  chainId,\n  args,\n  cacheTime,\n  enabled = true,\n  scopeKey,\n  staleTime,\n  suspense,\n  onError,\n  onSettled,\n  onSuccess,\n  ...config\n} = {}) {\n  const {\n    chain: activeChain\n  } = useNetwork();\n  const {\n    data: walletClient\n  } = useWalletClient({\n    chainId\n  });\n  const {\n    accessList,\n    account,\n    blockNumber,\n    blockTag,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    value\n  } = getCallParameters(config);\n  const prepareContractWriteQuery = useQuery(queryKey8({\n    accessList,\n    account,\n    activeChainId: activeChain?.id,\n    address,\n    args,\n    blockNumber,\n    blockTag,\n    chainId,\n    functionName,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    scopeKey,\n    walletClientAddress: walletClient?.account.address,\n    value\n  }), queryFn8({\n    abi,\n    walletClient\n  }), {\n    cacheTime,\n    enabled: Boolean(enabled && abi && address && functionName && walletClient),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n  return Object.assign(prepareContractWriteQuery, {\n    config: {\n      chainId,\n      mode: \"prepared\",\n      request: void 0,\n      ...prepareContractWriteQuery.data\n    }\n  });\n}\n\n// src/hooks/contracts/useToken.ts\nimport { fetchToken } from \"@wagmi/core\";\nfunction queryKey9({\n  address,\n  chainId,\n  formatUnits,\n  scopeKey\n}) {\n  return [{\n    entity: \"token\",\n    address,\n    chainId,\n    formatUnits,\n    scopeKey\n  }];\n}\nfunction queryFn9({\n  queryKey: [{\n    address,\n    chainId,\n    formatUnits\n  }]\n}) {\n  if (!address) throw new Error(\"address is required\");\n  return fetchToken({\n    address,\n    chainId,\n    formatUnits\n  });\n}\nfunction useToken({\n  address,\n  chainId: chainId_,\n  formatUnits = \"ether\",\n  cacheTime,\n  enabled = true,\n  scopeKey,\n  staleTime = 1e3 * 60 * 60 * 24,\n  suspense,\n  onError,\n  onSettled,\n  onSuccess\n} = {}) {\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey9({\n    address,\n    chainId,\n    formatUnits,\n    scopeKey\n  }), queryFn9, {\n    cacheTime,\n    enabled: Boolean(enabled && address),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\n// src/hooks/ens/useEnsAddress.ts\nimport { fetchEnsAddress } from \"@wagmi/core\";\nfunction queryKey10({\n  chainId,\n  name,\n  scopeKey\n}) {\n  return [{\n    entity: \"ensAddress\",\n    chainId,\n    name,\n    scopeKey\n  }];\n}\nfunction queryFn10({\n  queryKey: [{\n    chainId,\n    name\n  }]\n}) {\n  if (!name) throw new Error(\"name is required\");\n  return fetchEnsAddress({\n    chainId,\n    name\n  });\n}\nfunction useEnsAddress({\n  cacheTime,\n  chainId: chainId_,\n  enabled = true,\n  name,\n  scopeKey,\n  staleTime = 1e3 * 60 * 60 * 24,\n  suspense,\n  onError,\n  onSettled,\n  onSuccess\n} = {}) {\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey10({\n    chainId,\n    name,\n    scopeKey\n  }), queryFn10, {\n    cacheTime,\n    enabled: Boolean(enabled && chainId && name),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\n// src/hooks/ens/useEnsAvatar.ts\nimport { fetchEnsAvatar } from \"@wagmi/core\";\nfunction queryKey11({\n  name,\n  chainId,\n  scopeKey\n}) {\n  return [{\n    entity: \"ensAvatar\",\n    name,\n    chainId,\n    scopeKey\n  }];\n}\nfunction queryFn11({\n  queryKey: [{\n    name,\n    chainId\n  }]\n}) {\n  if (!name) throw new Error(\"name is required\");\n  return fetchEnsAvatar({\n    name,\n    chainId\n  });\n}\nfunction useEnsAvatar({\n  cacheTime,\n  chainId: chainId_,\n  enabled = true,\n  name,\n  scopeKey,\n  staleTime = 1e3 * 60 * 60 * 24,\n  suspense,\n  onError,\n  onSettled,\n  onSuccess\n} = {}) {\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey11({\n    name,\n    chainId,\n    scopeKey\n  }), queryFn11, {\n    cacheTime,\n    enabled: Boolean(enabled && name && chainId),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\n// src/hooks/ens/useEnsName.ts\nimport { fetchEnsName } from \"@wagmi/core\";\nfunction queryKey12({\n  address,\n  chainId,\n  scopeKey\n}) {\n  return [{\n    entity: \"ensName\",\n    address,\n    chainId,\n    scopeKey\n  }];\n}\nfunction queryFn12({\n  queryKey: [{\n    address,\n    chainId\n  }]\n}) {\n  if (!address) throw new Error(\"address is required\");\n  return fetchEnsName({\n    address,\n    chainId\n  });\n}\nfunction useEnsName({\n  address,\n  cacheTime,\n  chainId: chainId_,\n  enabled = true,\n  scopeKey,\n  staleTime = 1e3 * 60 * 60 * 24,\n  suspense,\n  onError,\n  onSettled,\n  onSuccess\n} = {}) {\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey12({\n    address,\n    chainId,\n    scopeKey\n  }), queryFn12, {\n    cacheTime,\n    enabled: Boolean(enabled && address && chainId),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\n// src/hooks/ens/useEnsResolver.ts\nimport { fetchEnsResolver } from \"@wagmi/core\";\nfunction queryKey13({\n  chainId,\n  name,\n  scopeKey\n}) {\n  return [{\n    entity: \"ensResolver\",\n    chainId,\n    name,\n    scopeKey,\n    persist: false\n  }];\n}\nfunction queryFn13({\n  queryKey: [{\n    chainId,\n    name\n  }]\n}) {\n  if (!name) throw new Error(\"name is required\");\n  return fetchEnsResolver({\n    chainId,\n    name\n  });\n}\nfunction useEnsResolver({\n  chainId: chainId_,\n  name,\n  enabled = true,\n  scopeKey,\n  suspense,\n  onError,\n  onSettled,\n  onSuccess\n} = {}) {\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey13({\n    chainId,\n    name,\n    scopeKey\n  }), queryFn13, {\n    cacheTime: 0,\n    enabled: Boolean(enabled && chainId && name),\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\n// src/hooks/transactions/usePrepareSendTransaction.ts\nimport { prepareSendTransaction } from \"@wagmi/core\";\nfunction queryKey14({\n  accessList,\n  account,\n  activeChainId,\n  chainId,\n  data,\n  gas,\n  gasPrice,\n  maxFeePerGas,\n  maxPriorityFeePerGas,\n  nonce,\n  to,\n  value,\n  scopeKey,\n  walletClientAddress\n}) {\n  return [{\n    entity: \"prepareSendTransaction\",\n    activeChainId,\n    accessList,\n    account,\n    chainId,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    to,\n    value,\n    scopeKey,\n    walletClientAddress\n  }];\n}\nfunction queryFn14({\n  walletClient\n}) {\n  return ({\n    queryKey: [{\n      accessList,\n      account,\n      chainId,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value\n    }]\n  }) => {\n    if (!to) throw new Error(\"to is required\");\n    return prepareSendTransaction({\n      accessList,\n      account,\n      chainId,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n      walletClient\n    });\n  };\n}\nfunction usePrepareSendTransaction({\n  accessList,\n  account,\n  chainId,\n  cacheTime,\n  data,\n  enabled = true,\n  gas,\n  gasPrice,\n  maxFeePerGas,\n  maxPriorityFeePerGas,\n  nonce,\n  scopeKey,\n  staleTime,\n  suspense,\n  to,\n  value,\n  onError,\n  onSettled,\n  onSuccess\n} = {}) {\n  const {\n    chain: activeChain\n  } = useNetwork();\n  const {\n    data: walletClient\n  } = useWalletClient({\n    chainId\n  });\n  const prepareSendTransactionQuery = useQuery(queryKey14({\n    accessList,\n    activeChainId: activeChain?.id,\n    account,\n    chainId,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    scopeKey,\n    to,\n    value,\n    walletClientAddress: walletClient?.account.address\n  }), queryFn14({\n    walletClient\n  }), {\n    cacheTime,\n    enabled: Boolean(enabled && walletClient && to),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n  return Object.assign(prepareSendTransactionQuery, {\n    config: {\n      mode: \"prepared\",\n      ...(prepareSendTransactionQuery.isSuccess ? prepareSendTransactionQuery.data : void 0)\n    }\n  });\n}\n\n// src/hooks/transactions/useSendTransaction.ts\nimport { sendTransaction } from \"@wagmi/core\";\nimport * as React20 from \"react\";\nvar mutationKey7 = args => [{\n  entity: \"sendTransaction\",\n  ...args\n}];\nvar mutationFn7 = ({\n  accessList,\n  account,\n  chainId,\n  data,\n  gas,\n  gasPrice,\n  maxFeePerGas,\n  maxPriorityFeePerGas,\n  mode,\n  nonce,\n  to,\n  value\n}) => {\n  if (!to) throw new Error(\"to is required.\");\n  return sendTransaction({\n    accessList,\n    account,\n    chainId,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    mode,\n    nonce,\n    to,\n    value\n  });\n};\nfunction useSendTransaction({\n  accessList,\n  account,\n  chainId,\n  data: data_,\n  gas,\n  gasPrice,\n  maxFeePerGas,\n  maxPriorityFeePerGas,\n  mode,\n  nonce,\n  to,\n  value,\n  onError,\n  onMutate,\n  onSettled,\n  onSuccess\n} = {}) {\n  const {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    mutate,\n    mutateAsync,\n    reset,\n    status,\n    variables\n  } = useMutation(mutationKey7({\n    accessList,\n    account,\n    chainId,\n    data: data_,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    mode,\n    nonce,\n    to,\n    value\n  }), mutationFn7, {\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  });\n  const sendTransaction2 = React20.useCallback(args => mutate({\n    chainId,\n    mode,\n    ...(args || {\n      accessList,\n      account,\n      chainId,\n      data: data_,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      mode,\n      nonce,\n      value,\n      to\n    })\n  }), [accessList, account, chainId, data_, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, mode, mutate, nonce, to, value]);\n  const sendTransactionAsync = React20.useCallback(args => mutateAsync({\n    chainId,\n    mode,\n    ...(args || {\n      accessList,\n      account,\n      chainId,\n      data: data_,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      mode,\n      nonce,\n      value,\n      to\n    })\n  }), [accessList, account, chainId, data_, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, mode, mutateAsync, nonce, to, value]);\n  return {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    reset,\n    sendTransaction: mode === \"prepared\" && !to ? void 0 : sendTransaction2,\n    sendTransactionAsync: mode === \"prepared\" && !to ? void 0 : sendTransactionAsync,\n    status,\n    variables\n  };\n}\n\n// src/hooks/transactions/useTransaction.ts\nimport { fetchTransaction } from \"@wagmi/core\";\nfunction queryKey15({\n  chainId,\n  hash,\n  scopeKey\n}) {\n  return [{\n    entity: \"transaction\",\n    chainId,\n    hash,\n    scopeKey\n  }];\n}\nfunction queryFn15({\n  queryKey: [{\n    chainId,\n    hash\n  }]\n}) {\n  if (!hash) throw new Error(\"hash is required\");\n  return fetchTransaction({\n    chainId,\n    hash\n  });\n}\nfunction useTransaction({\n  cacheTime = 0,\n  chainId: chainId_,\n  enabled = true,\n  hash,\n  scopeKey,\n  staleTime,\n  suspense,\n  onError,\n  onSettled,\n  onSuccess\n} = {}) {\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey15({\n    chainId,\n    hash,\n    scopeKey\n  }), queryFn15, {\n    cacheTime,\n    enabled: Boolean(enabled && hash),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\n// src/hooks/transactions/useWaitForTransaction.ts\nimport { waitForTransaction } from \"@wagmi/core\";\nfunction queryKey16({\n  confirmations,\n  chainId,\n  hash,\n  scopeKey,\n  timeout\n}) {\n  return [{\n    entity: \"waitForTransaction\",\n    confirmations,\n    chainId,\n    hash,\n    scopeKey,\n    timeout\n  }];\n}\nfunction queryFn16({\n  onReplaced\n}) {\n  return ({\n    queryKey: [{\n      chainId,\n      confirmations,\n      hash,\n      timeout\n    }]\n  }) => {\n    if (!hash) throw new Error(\"hash is required\");\n    return waitForTransaction({\n      chainId,\n      confirmations,\n      hash,\n      onReplaced,\n      timeout\n    });\n  };\n}\nfunction useWaitForTransaction({\n  chainId: chainId_,\n  confirmations,\n  hash,\n  timeout,\n  cacheTime,\n  enabled = true,\n  scopeKey,\n  staleTime,\n  suspense,\n  onError,\n  onReplaced,\n  onSettled,\n  onSuccess\n} = {}) {\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey16({\n    chainId,\n    confirmations,\n    hash,\n    scopeKey,\n    timeout\n  }), queryFn16({\n    onReplaced\n  }), {\n    cacheTime,\n    enabled: Boolean(enabled && hash),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\n// src/hooks/transactions/useWatchPendingTransactions.ts\nimport * as React21 from \"react\";\nfunction useWatchPendingTransactions({\n  chainId: chainId_,\n  enabled = true,\n  listener\n}) {\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  const publicClient = usePublicClient({\n    chainId\n  });\n  const webSocketPublicClient = useWebSocketPublicClient({\n    chainId\n  });\n  React21.useEffect(() => {\n    if (!enabled) return;\n    const publicClient_ = webSocketPublicClient ?? publicClient;\n    return publicClient_.watchPendingTransactions({\n      onTransactions: listener\n    });\n  }, [enabled, listener, publicClient, webSocketPublicClient]);\n}\n\n// src/index.ts\nimport { ChainMismatchError, ChainNotConfiguredError, Connector, ConnectorAlreadyConnectedError, ConnectorNotFoundError, ConfigChainsNotFound, SwitchChainNotSupportedError, configureChains, createStorage as createStorage2, deepEqual as deepEqual5, deserialize, erc20ABI, erc721ABI, erc4626ABI, readContracts as readContracts3, serialize } from \"@wagmi/core\";\nimport { mainnet, sepolia } from \"viem/chains\";\nexport { ChainMismatchError, ChainNotConfiguredError, ConfigChainsNotFound, Connector, ConnectorAlreadyConnectedError, ConnectorNotFoundError, Context, SwitchChainNotSupportedError, WagmiConfig, configureChains, createConfig, createStorage2 as createStorage, deepEqual5 as deepEqual, deserialize, erc20ABI, erc4626ABI, erc721ABI, mainnet, paginatedIndexesConfig, readContracts3 as readContracts, sepolia, serialize, useAccount, useBalance, useBlockNumber, useChainId, useConfig, useConnect, useContractEvent, useContractInfiniteReads, useContractRead, useContractReads, useContractWrite, useDisconnect, useEnsAddress, useEnsAvatar, useEnsName, useEnsResolver, useFeeData, useInfiniteQuery, useMutation, useNetwork, usePrepareContractWrite, usePrepareSendTransaction, usePublicClient, useQuery, useQueryClient2 as useQueryClient, useSendTransaction, useSignMessage, useSignTypedData, useSwitchNetwork, useToken, useTransaction, useWaitForTransaction, useWalletClient, useWatchPendingTransactions, useWebSocketPublicClient };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}