{"ast":null,"code":"import { TransactionNotFoundError, TransactionReceiptNotFoundError, WaitForTransactionReceiptTimeoutError } from '../../errors/transaction.js';\nimport { observe } from '../../utils/observe.js';\nimport { withRetry } from '../../utils/promise/withRetry.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getBlock } from './getBlock.js';\nimport { getTransaction } from './getTransaction.js';\nimport { getTransactionReceipt } from './getTransactionReceipt.js';\nimport { watchBlockNumber } from './watchBlockNumber.js';\n/**\n * Waits for the [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms.html#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt). If the Transaction reverts, then the action will throw an error.\n *\n * - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt.html\n * - Example: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/sending-transactions\n * - JSON-RPC Methods:\n *   - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.\n *   - If a Transaction has been replaced:\n *     - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions\n *     - Checks if one of the Transactions is a replacement\n *     - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).\n *\n * The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).\n *\n * Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.\n *\n * There are 3 types of Transaction Replacement reasons:\n *\n * - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`)\n * - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`)\n * - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForTransactionReceiptParameters}\n * @returns The transaction receipt. {@link WaitForTransactionReceiptReturnType}\n *\n * @example\n * import { createPublicClient, waitForTransactionReceipt, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionReceipt = await waitForTransactionReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function waitForTransactionReceipt(client, {\n  confirmations = 1,\n  hash,\n  onReplaced,\n  pollingInterval = client.pollingInterval,\n  timeout\n}) {\n  const observerId = stringify(['waitForTransactionReceipt', client.uid, hash]);\n  let transaction;\n  let replacedTransaction;\n  let receipt;\n  let retrying = false;\n  return new Promise((resolve, reject) => {\n    if (timeout) setTimeout(() => reject(new WaitForTransactionReceiptTimeoutError({\n      hash\n    })), timeout);\n    const _unobserve = observe(observerId, {\n      onReplaced,\n      resolve,\n      reject\n    }, emit => {\n      const _unwatch = watchBlockNumber(client, {\n        emitMissed: true,\n        emitOnBegin: true,\n        poll: true,\n        pollingInterval,\n        async onBlockNumber(blockNumber_) {\n          if (retrying) return;\n          let blockNumber = blockNumber_;\n          const done = fn => {\n            _unwatch();\n            fn();\n            _unobserve();\n          };\n          try {\n            // If we already have a valid receipt, let's check if we have enough\n            // confirmations. If we do, then we can resolve.\n            if (receipt) {\n              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n              done(() => emit.resolve(receipt));\n              return;\n            }\n            // Get the transaction to check if it's been replaced.\n            // We need to retry as some RPC Providers may be slow to sync\n            // up mined transactions.\n            if (!transaction) {\n              retrying = true;\n              await withRetry(async () => {\n                transaction = await getTransaction(client, {\n                  hash\n                });\n                if (transaction.blockNumber) blockNumber = transaction.blockNumber;\n              }, {\n                // exponential backoff\n                delay: ({\n                  count\n                }) => ~~(1 << count) * 200,\n                retryCount: 6\n              });\n              retrying = false;\n            }\n            // Get the receipt to check if it's been processed.\n            receipt = await getTransactionReceipt(client, {\n              hash\n            });\n            // Check if we have enough confirmations. If not, continue polling.\n            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n            done(() => emit.resolve(receipt));\n          } catch (err) {\n            // If the receipt is not found, the transaction will be pending.\n            // We need to check if it has potentially been replaced.\n            if (transaction && (err instanceof TransactionNotFoundError || err instanceof TransactionReceiptNotFoundError)) {\n              try {\n                replacedTransaction = transaction;\n                // Let's retrieve the transactions from the current block.\n                const block = await getBlock(client, {\n                  blockNumber,\n                  includeTransactions: true\n                });\n                const replacementTransaction = block.transactions.find(({\n                  from,\n                  nonce\n                }) => from === replacedTransaction.from && nonce === replacedTransaction.nonce);\n                // If we couldn't find a replacement transaction, continue polling.\n                if (!replacementTransaction) return;\n                // If we found a replacement transaction, return it's receipt.\n                receipt = await getTransactionReceipt(client, {\n                  hash: replacementTransaction.hash\n                });\n                // Check if we have enough confirmations. If not, continue polling.\n                if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n                let reason = 'replaced';\n                if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value) {\n                  reason = 'repriced';\n                } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {\n                  reason = 'cancelled';\n                }\n                done(() => {\n                  emit.onReplaced?.({\n                    reason,\n                    replacedTransaction: replacedTransaction,\n                    transaction: replacementTransaction,\n                    transactionReceipt: receipt\n                  });\n                  emit.resolve(receipt);\n                });\n              } catch (err_) {\n                done(() => emit.reject(err_));\n              }\n            } else {\n              done(() => emit.reject(err));\n            }\n          }\n        }\n      });\n    });\n  });\n}\n//# sourceMappingURL=waitForTransactionReceipt.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}