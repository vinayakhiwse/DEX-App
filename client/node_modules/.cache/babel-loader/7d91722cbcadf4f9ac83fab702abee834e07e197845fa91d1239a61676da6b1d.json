{"ast":null,"code":"import { useReducer as $d70Aq$useReducer, useEffect as $d70Aq$useEffect, useState as $d70Aq$useState, useMemo as $d70Aq$useMemo } from \"react\";\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\nvar $f86e6c1ec7da6ebb$exports = {};\n$parcel$export($f86e6c1ec7da6ebb$exports, \"useAsyncList\", () => $f86e6c1ec7da6ebb$export$bc3384a35de93d66);\nfunction $0d86e9c8f07f9a7b$export$762f73dccccd255d(options) {\n  let {\n    initialItems = [],\n    initialSelectedKeys: initialSelectedKeys,\n    getKey = item => item.id || item.key,\n    filter: filter,\n    initialFilterText = ''\n  } = options;\n  // Store both items and filteredItems in state so we can go back to the unfiltered list\n  let [state, setState] = $d70Aq$useState({\n    items: initialItems,\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys || []),\n    filterText: initialFilterText\n  });\n  let filteredItems = $d70Aq$useMemo(() => filter ? state.items.filter(item => filter(item, state.filterText)) : state.items, [state.items, state.filterText, filter]);\n  return {\n    ...state,\n    items: filteredItems,\n    ...$0d86e9c8f07f9a7b$export$79c0c687a5963b0a({\n      getKey: getKey\n    }, setState),\n    getItem(key) {\n      return state.items.find(item => getKey(item) === key);\n    }\n  };\n}\nfunction $0d86e9c8f07f9a7b$export$79c0c687a5963b0a(opts, dispatch) {\n  let {\n    cursor: cursor,\n    getKey: getKey\n  } = opts;\n  return {\n    setSelectedKeys(selectedKeys) {\n      dispatch(state => ({\n        ...state,\n        selectedKeys: selectedKeys\n      }));\n    },\n    setFilterText(filterText) {\n      dispatch(state => ({\n        ...state,\n        filterText: filterText\n      }));\n    },\n    insert(index, ...values) {\n      dispatch(state => $0d86e9c8f07f9a7b$var$insert(state, index, ...values));\n    },\n    insertBefore(key, ...values) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) return;\n        return $0d86e9c8f07f9a7b$var$insert(state, index, ...values);\n      });\n    },\n    insertAfter(key, ...values) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) return;\n        return $0d86e9c8f07f9a7b$var$insert(state, index + 1, ...values);\n      });\n    },\n    prepend(...values) {\n      dispatch(state => $0d86e9c8f07f9a7b$var$insert(state, 0, ...values));\n    },\n    append(...values) {\n      dispatch(state => $0d86e9c8f07f9a7b$var$insert(state, state.items.length, ...values));\n    },\n    remove(...keys) {\n      dispatch(state => {\n        let keySet = new Set(keys);\n        let items = state.items.filter(item => !keySet.has(getKey(item)));\n        let selection = 'all';\n        if (state.selectedKeys !== 'all') {\n          selection = new Set(state.selectedKeys);\n          for (let key of keys) selection.delete(key);\n        }\n        if (cursor == null && items.length === 0) selection = new Set();\n        return {\n          ...state,\n          items: items,\n          selectedKeys: selection\n        };\n      });\n    },\n    removeSelectedItems() {\n      dispatch(state => {\n        if (state.selectedKeys === 'all') return {\n          ...state,\n          items: [],\n          selectedKeys: new Set()\n        };\n        let selectedKeys = state.selectedKeys;\n        let items = state.items.filter(item => !selectedKeys.has(getKey(item)));\n        return {\n          ...state,\n          items: items,\n          selectedKeys: new Set()\n        };\n      });\n    },\n    move(key, toIndex) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) return state;\n        let copy = state.items.slice();\n        let [item1] = copy.splice(index, 1);\n        copy.splice(toIndex, 0, item1);\n        return {\n          ...state,\n          items: copy\n        };\n      });\n    },\n    moveBefore(key1, keys) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key1);\n        if (toIndex === -1) return state;\n        // Find indices of keys to move. Sort them so that the order in the list is retained.\n        let indices = keys.map(key => state.items.findIndex(item => getKey(item) === key)).sort();\n        return $0d86e9c8f07f9a7b$var$move(state, indices, toIndex);\n      });\n    },\n    moveAfter(key2, keys) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key2);\n        if (toIndex === -1) return state;\n        let indices = keys.map(key => state.items.findIndex(item => getKey(item) === key)).sort();\n        return $0d86e9c8f07f9a7b$var$move(state, indices, toIndex + 1);\n      });\n    },\n    update(key, newValue) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) return state;\n        return {\n          ...state,\n          items: [...state.items.slice(0, index), newValue, ...state.items.slice(index + 1)]\n        };\n      });\n    }\n  };\n}\nfunction $0d86e9c8f07f9a7b$var$insert(state, index, ...values) {\n  return {\n    ...state,\n    items: [...state.items.slice(0, index), ...values, ...state.items.slice(index)]\n  };\n}\nfunction $0d86e9c8f07f9a7b$var$move(state, indices, toIndex) {\n  // Shift the target down by the number of items being moved from before the target\n  for (let index of indices) if (index < toIndex) toIndex--;\n  let moves = indices.map(from => ({\n    from: from,\n    to: toIndex++\n  }));\n  // Shift later from indices down if they have a larger index\n  for (let i = 0; i < moves.length; i++) {\n    let a = moves[i].from;\n    for (let j = i; j < moves.length; j++) {\n      let b = moves[j].from;\n      if (b > a) moves[j].from--;\n    }\n  }\n  // Interleave the moves so they can be applied one by one rather than all at once\n  for (let i1 = 0; i1 < moves.length; i1++) {\n    let a = moves[i1];\n    for (let j = moves.length - 1; j > i1; j--) {\n      let b = moves[j];\n      if (b.from < a.to) a.to++;else b.from++;\n    }\n  }\n  let copy = state.items.slice();\n  for (let move of moves) {\n    let [item] = copy.splice(move.from, 1);\n    copy.splice(move.to, 0, item);\n  }\n  return {\n    ...state,\n    items: copy\n  };\n}\nfunction $f86e6c1ec7da6ebb$var$reducer(data, action) {\n  let selectedKeys;\n  switch (data.state) {\n    case 'idle':\n    case 'error':\n      switch (action.type) {\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          var _filterText, _sortDescriptor;\n          return {\n            ...data,\n            filterText: (_filterText = action.filterText) !== null && _filterText !== void 0 ? _filterText : data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            sortDescriptor: (_sortDescriptor = action.sortDescriptor) !== null && _sortDescriptor !== void 0 ? _sortDescriptor : data.sortDescriptor,\n            abortController: action.abortController\n          };\n        case 'update':\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        case 'success':\n        case 'error':\n          return data;\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loading':\n    case 'sorting':\n    case 'filtering':\n      switch (action.type) {\n        case 'success':\n          // Ignore if there is a newer abortcontroller in state.\n          // This means that multiple requests were going at once.\n          // We want to take only the latest result.\n          if (action.abortController !== data.abortController) return data;\n          var _selectedKeys;\n          selectedKeys = (_selectedKeys = action.selectedKeys) !== null && _selectedKeys !== void 0 ? _selectedKeys : data.selectedKeys;\n          var _filterText1, _sortDescriptor1;\n          return {\n            ...data,\n            filterText: (_filterText1 = action.filterText) !== null && _filterText1 !== void 0 ? _filterText1 : data.filterText,\n            state: 'idle',\n            items: [...action.items],\n            selectedKeys: selectedKeys === 'all' ? 'all' : new Set(selectedKeys),\n            sortDescriptor: (_sortDescriptor1 = action.sortDescriptor) !== null && _sortDescriptor1 !== void 0 ? _sortDescriptor1 : data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) return data;\n          return {\n            ...data,\n            state: 'error',\n            error: action.error,\n            abortController: null\n          };\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading, and another load was triggered at the same time.\n          // We need to abort the previous load and start a new one.\n          data.abortController.abort();\n          var _filterText2;\n          return {\n            ...data,\n            filterText: (_filterText2 = action.filterText) !== null && _filterText2 !== void 0 ? _filterText2 : data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loadingMore':\n      switch (action.type) {\n        case 'success':\n          var _selectedKeys1;\n          selectedKeys = data.selectedKeys === 'all' || action.selectedKeys === 'all' ? 'all' : new Set([...data.selectedKeys, ...((_selectedKeys1 = action.selectedKeys) !== null && _selectedKeys1 !== void 0 ? _selectedKeys1 : [])]);\n          var _sortDescriptor2;\n          // Append the new items\n          return {\n            ...data,\n            state: 'idle',\n            items: [...data.items, ...action.items],\n            selectedKeys: selectedKeys,\n            sortDescriptor: (_sortDescriptor2 = action.sortDescriptor) !== null && _sortDescriptor2 !== void 0 ? _sortDescriptor2 : data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) return data;\n          return {\n            ...data,\n            state: 'error',\n            error: action.error\n          };\n        case 'loading':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading more, and another load was triggered at the same time.\n          // We need to abort the previous load more and start a new one.\n          data.abortController.abort();\n          var _filterText3;\n          return {\n            ...data,\n            filterText: (_filterText3 = action.filterText) !== null && _filterText3 !== void 0 ? _filterText3 : data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'loadingMore':\n          // If already loading more and another loading more is triggered, abort the new load more since\n          // it is a duplicate request since the cursor hasn't been updated.\n          // Do not overwrite the data.abortController\n          action.abortController.abort();\n          return data;\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    default:\n      throw new Error(`Invalid state \"${data.state}\"`);\n  }\n}\nfunction $f86e6c1ec7da6ebb$export$bc3384a35de93d66(options) {\n  const {\n    load: load,\n    sort: sort,\n    initialSelectedKeys: initialSelectedKeys,\n    initialSortDescriptor: initialSortDescriptor,\n    getKey = item => item.id || item.key,\n    initialFilterText = ''\n  } = options;\n  let [data, dispatch] = $d70Aq$useReducer($f86e6c1ec7da6ebb$var$reducer, {\n    state: 'idle',\n    error: null,\n    items: [],\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys),\n    sortDescriptor: initialSortDescriptor,\n    filterText: initialFilterText\n  });\n  const dispatchFetch = async (action, fn) => {\n    let abortController = new AbortController();\n    try {\n      dispatch({\n        ...action,\n        abortController: abortController\n      });\n      var _filterText;\n      let previousFilterText = (_filterText = action.filterText) !== null && _filterText !== void 0 ? _filterText : data.filterText;\n      var _sortDescriptor;\n      let response = await fn({\n        items: data.items.slice(),\n        selectedKeys: data.selectedKeys,\n        sortDescriptor: (_sortDescriptor = action.sortDescriptor) !== null && _sortDescriptor !== void 0 ? _sortDescriptor : data.sortDescriptor,\n        signal: abortController.signal,\n        cursor: action.type === 'loadingMore' ? data.cursor : null,\n        filterText: previousFilterText\n      });\n      var _filterText4;\n      let filterText = (_filterText4 = response.filterText) !== null && _filterText4 !== void 0 ? _filterText4 : previousFilterText;\n      dispatch({\n        type: 'success',\n        ...response,\n        abortController: abortController\n      });\n      // Fetch a new filtered list if filterText is updated via `load` response func rather than list.setFilterText\n      // Only do this if not aborted (e.g. user triggers another filter action before load completes)\n      if (filterText && filterText !== previousFilterText && !abortController.signal.aborted) dispatchFetch({\n        type: 'filtering',\n        filterText: filterText\n      }, load);\n    } catch (e) {\n      dispatch({\n        type: 'error',\n        error: e,\n        abortController: abortController\n      });\n    }\n  };\n  $d70Aq$useEffect(() => {\n    dispatchFetch({\n      type: 'loading'\n    }, load);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return {\n    items: data.items,\n    selectedKeys: data.selectedKeys,\n    sortDescriptor: data.sortDescriptor,\n    isLoading: data.state === 'loading' || data.state === 'loadingMore' || data.state === 'sorting' || data.state === 'filtering',\n    loadingState: data.state,\n    error: data.error,\n    filterText: data.filterText,\n    getItem(key) {\n      return data.items.find(item => getKey(item) === key);\n    },\n    reload() {\n      dispatchFetch({\n        type: 'loading'\n      }, load);\n    },\n    loadMore() {\n      // Ignore if already loading more or if performing server side filtering.\n      if (data.state === 'loadingMore' || data.state === 'filtering' || data.cursor == null) return;\n      dispatchFetch({\n        type: 'loadingMore'\n      }, load);\n    },\n    sort(sortDescriptor) {\n      dispatchFetch({\n        type: 'sorting',\n        sortDescriptor: sortDescriptor\n      }, sort || load);\n    },\n    ...$0d86e9c8f07f9a7b$export$79c0c687a5963b0a({\n      ...options,\n      getKey: getKey,\n      cursor: data.cursor\n    }, fn => {\n      dispatch({\n        type: 'update',\n        updater: fn\n      });\n    }),\n    setFilterText(filterText) {\n      dispatchFetch({\n        type: 'filtering',\n        filterText: filterText\n      }, load);\n    }\n  };\n}\nvar $be2ea0343af54212$exports = {};\n$parcel$export($be2ea0343af54212$exports, \"useTreeData\", () => $be2ea0343af54212$export$d14e1352e21f4a16);\nfunction $be2ea0343af54212$export$d14e1352e21f4a16(options) {\n  let {\n    initialItems: initialItems1 = [],\n    initialSelectedKeys: initialSelectedKeys,\n    getKey = item => item.id || item.key,\n    getChildren = item => item.children\n  } = options;\n  let map = $d70Aq$useMemo(() => new Map(), []);\n  // We only want to compute this on initial render.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  let initialNodes = $d70Aq$useMemo(() => buildTree(initialItems1), []);\n  let [items1, setItems] = $d70Aq$useState(initialNodes);\n  let [selectedKeys, setSelectedKeys] = $d70Aq$useState(new Set(initialSelectedKeys || []));\n  function buildTree(initialItems = [], parentKey) {\n    return initialItems.map(item => {\n      let node = {\n        key: getKey(item),\n        parentKey: parentKey,\n        value: item,\n        children: null\n      };\n      node.children = buildTree(getChildren(item), node.key);\n      map.set(node.key, node);\n      return node;\n    });\n  }\n  function updateTree(items, key, update) {\n    let node = map.get(key);\n    if (!node) return items;\n    // Create a new node. If null, then delete the node, otherwise replace.\n    let newNode = update(node);\n    if (newNode == null) deleteNode(node);else addNode(newNode);\n    // Walk up the tree and update each parent to refer to the new chilren.\n    while (node.parentKey) {\n      let nextParent = map.get(node.parentKey);\n      let copy = {\n        key: nextParent.key,\n        parentKey: nextParent.parentKey,\n        value: nextParent.value,\n        children: null\n      };\n      let children = nextParent.children;\n      if (newNode == null) children = children.filter(c => c !== node);\n      copy.children = children.map(child => {\n        if (child === node) return newNode;\n        return child;\n      });\n      map.set(copy.key, copy);\n      newNode = copy;\n      node = nextParent;\n    }\n    if (newNode == null) items = items.filter(c => c !== node);\n    return items.map(item => {\n      if (item === node) return newNode;\n      return item;\n    });\n  }\n  function addNode(node) {\n    map.set(node.key, node);\n    for (let child of node.children) addNode(child);\n  }\n  function deleteNode(node) {\n    map.delete(node.key);\n    for (let child of node.children) deleteNode(child);\n  }\n  return {\n    items: items1,\n    selectedKeys: selectedKeys,\n    setSelectedKeys: setSelectedKeys,\n    getItem(key) {\n      return map.get(key);\n    },\n    insert(parentKey, index, ...values) {\n      setItems(items => {\n        let nodes = buildTree(values, parentKey);\n        // If parentKey is null, insert into the root.\n        if (parentKey == null) return [...items.slice(0, index), ...nodes, ...items.slice(index)];\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(items, parentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [...parentNode.children.slice(0, index), ...nodes, ...parentNode.children.slice(index)]\n        }));\n      });\n    },\n    insertBefore(key, ...values) {\n      let node = map.get(key);\n      if (!node) return;\n      let parentNode = map.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items1;\n      let index = nodes.indexOf(node);\n      this.insert(parentNode === null || parentNode === void 0 ? void 0 : parentNode.key, index, ...values);\n    },\n    insertAfter(key, ...values) {\n      let node = map.get(key);\n      if (!node) return;\n      let parentNode = map.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items1;\n      let index = nodes.indexOf(node);\n      this.insert(parentNode === null || parentNode === void 0 ? void 0 : parentNode.key, index + 1, ...values);\n    },\n    prepend(parentKey, ...values) {\n      this.insert(parentKey, 0, ...values);\n    },\n    append(parentKey, ...values) {\n      if (parentKey == null) this.insert(null, items1.length, ...values);else {\n        let parentNode = map.get(parentKey);\n        if (!parentNode) return;\n        this.insert(parentKey, parentNode.children.length, ...values);\n      }\n    },\n    remove(...keys) {\n      let newItems = items1;\n      for (let key of keys) newItems = updateTree(newItems, key, () => null);\n      setItems(newItems);\n      let selection = new Set(selectedKeys);\n      for (let key1 of selectedKeys) if (!map.has(key1)) selection.delete(key1);\n      setSelectedKeys(selection);\n    },\n    removeSelectedItems() {\n      this.remove(...selectedKeys);\n    },\n    move(key, toParentKey, index) {\n      setItems(items => {\n        let node = map.get(key);\n        if (!node) return items;\n        items = updateTree(items, key, () => null);\n        const movedNode = {\n          ...node,\n          parentKey: toParentKey\n        };\n        return updateTree(items, toParentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [...parentNode.children.slice(0, index), movedNode, ...parentNode.children.slice(index)]\n        }));\n      });\n    },\n    update(oldKey, newValue) {\n      setItems(items => updateTree(items, oldKey, oldNode => {\n        let node = {\n          key: oldNode.key,\n          parentKey: oldNode.parentKey,\n          value: newValue,\n          children: null\n        };\n        node.children = buildTree(getChildren(newValue), node.key);\n        return node;\n      }));\n    }\n  };\n}\nexport { $0d86e9c8f07f9a7b$export$762f73dccccd255d as useListData, $f86e6c1ec7da6ebb$export$bc3384a35de93d66 as useAsyncList, $be2ea0343af54212$export$d14e1352e21f4a16 as useTreeData };\n//# sourceMappingURL=module.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}