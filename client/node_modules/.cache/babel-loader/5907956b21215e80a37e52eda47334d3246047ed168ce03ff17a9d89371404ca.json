{"ast":null,"code":"\"use client\";\n\n// src/use-input.ts\nimport { mapPropsVariants } from \"@nextui-org/system\";\nimport { useFocusRing } from \"@react-aria/focus\";\nimport { input } from \"@nextui-org/theme\";\nimport { useDOMRef, filterDOMProps } from \"@nextui-org/react-utils\";\nimport { useFocusWithin, useHover, usePress } from \"@react-aria/interactions\";\nimport { clsx, dataAttr, safeAriaLabel } from \"@nextui-org/shared-utils\";\nimport { useControlledState } from \"@react-stately/utils\";\nimport { useMemo, useCallback, useState } from \"react\";\nimport { chain, mergeProps } from \"@react-aria/utils\";\nimport { useTextField } from \"@react-aria/textfield\";\nfunction useInput(originalProps) {\n  const [props, variantProps] = mapPropsVariants(originalProps, input.variantKeys);\n  const {\n    ref,\n    as,\n    label,\n    description,\n    errorMessage,\n    className,\n    classNames,\n    autoFocus,\n    startContent,\n    endContent,\n    onClear,\n    onChange,\n    validationState,\n    onValueChange = () => {},\n    ...otherProps\n  } = props;\n  const handleValueChange = useCallback(value => {\n    onValueChange(value != null ? value : \"\");\n  }, [onValueChange]);\n  const [inputValue, setInputValue] = useControlledState(props.value, props.defaultValue, handleValueChange);\n  const [isFocusWithin, setFocusWithin] = useState(false);\n  const Component = as || \"div\";\n  const isFilled = !!inputValue;\n  const isFilledWithin = isFilled || isFocusWithin;\n  const baseStyles = clsx(classNames == null ? void 0 : classNames.base, className, isFilled ? \"is-filled\" : \"\");\n  const isMultiline = originalProps.isMultiline;\n  const domRef = useDOMRef(ref);\n  const handleClear = useCallback(() => {\n    setInputValue(\"\");\n    if (domRef.current) {\n      domRef.current.value = \"\";\n      domRef.current.focus();\n    }\n    onClear == null ? void 0 : onClear();\n  }, [domRef, setInputValue, onClear]);\n  const {\n    labelProps,\n    inputProps,\n    descriptionProps,\n    errorMessageProps\n  } = useTextField({\n    ...originalProps,\n    \"aria-label\": safeAriaLabel(originalProps == null ? void 0 : originalProps[\"aria-label\"], originalProps == null ? void 0 : originalProps.label, originalProps == null ? void 0 : originalProps.placeholder),\n    inputElementType: isMultiline ? \"textarea\" : \"input\",\n    onChange: setInputValue\n  }, domRef);\n  const {\n    isFocusVisible,\n    isFocused,\n    focusProps\n  } = useFocusRing({\n    autoFocus,\n    isTextInput: true\n  });\n  const {\n    isHovered,\n    hoverProps\n  } = useHover({\n    isDisabled: !!(originalProps == null ? void 0 : originalProps.isDisabled)\n  });\n  const {\n    focusProps: clearFocusProps,\n    isFocusVisible: isClearButtonFocusVisible\n  } = useFocusRing();\n  const {\n    focusWithinProps\n  } = useFocusWithin({\n    onFocusWithinChange: setFocusWithin\n  });\n  const {\n    pressProps: clearPressProps\n  } = usePress({\n    isDisabled: !!(originalProps == null ? void 0 : originalProps.isDisabled),\n    onPress: handleClear\n  });\n  const isInvalid = validationState === \"invalid\" || originalProps.isInvalid;\n  const labelPlacement = useMemo(() => {\n    var _a;\n    if ((!originalProps.labelPlacement || originalProps.labelPlacement === \"inside\") && !label) {\n      return \"outside\";\n    }\n    return (_a = originalProps.labelPlacement) != null ? _a : \"inside\";\n  }, [originalProps.labelPlacement, label]);\n  const isLabelPlaceholder = !props.placeholder && labelPlacement !== \"outside-left\" && !isMultiline;\n  const isClearable = !!onClear || originalProps.isClearable;\n  const hasElements = !!label || !!description || !!errorMessage;\n  const hasPlaceholder = !!props.placeholder;\n  const hasHelper = !!description || !!errorMessage;\n  const shouldLabelBeOutside = labelPlacement === \"outside\" || labelPlacement === \"outside-left\";\n  const shouldLabelBeInside = labelPlacement === \"inside\";\n  const hasStartContent = !!startContent;\n  const isLabelOutside = shouldLabelBeOutside ? labelPlacement === \"outside-left\" || hasPlaceholder || labelPlacement === \"outside\" && hasStartContent : false;\n  const isLabelOutsideAsPlaceholder = labelPlacement === \"outside\" && !hasPlaceholder && !hasStartContent;\n  const slots = useMemo(() => input({\n    ...variantProps,\n    isInvalid,\n    isClearable,\n    labelPlacement,\n    isLabelPlaceholder: isLabelPlaceholder && !hasStartContent\n  }), [...Object.values(variantProps), isInvalid, labelPlacement, isClearable, isLabelPlaceholder, hasStartContent]);\n  const getBaseProps = useCallback((props2 = {}) => {\n    return {\n      className: slots.base({\n        class: baseStyles\n      }),\n      \"data-filled\": dataAttr(isFilled),\n      \"data-filled-within\": dataAttr(isFilledWithin),\n      \"data-focus-within\": dataAttr(isFocusWithin),\n      \"data-focus-visible\": dataAttr(isFocusVisible),\n      \"data-readonly\": dataAttr(originalProps.isReadOnly),\n      \"data-focus\": dataAttr(isFocused),\n      \"data-hover\": dataAttr(isHovered),\n      \"data-required\": dataAttr(originalProps.isRequired),\n      \"data-invalid\": dataAttr(isInvalid),\n      \"data-disabled\": dataAttr(originalProps.isDisabled),\n      \"data-has-elements\": dataAttr(hasElements),\n      \"data-has-helper\": dataAttr(hasHelper),\n      ...focusWithinProps,\n      ...props2\n    };\n  }, [slots, baseStyles, isFilled, isFocused, isHovered, isInvalid, hasHelper, hasElements, isFocusWithin, isFocusVisible, isFilledWithin, focusWithinProps, originalProps.isReadOnly, originalProps.isRequired, originalProps.isDisabled]);\n  const getLabelProps = useCallback((props2 = {}) => {\n    return {\n      className: slots.label({\n        class: classNames == null ? void 0 : classNames.label\n      }),\n      ...labelProps,\n      ...props2\n    };\n  }, [slots, labelProps, classNames == null ? void 0 : classNames.label]);\n  const getInputProps = useCallback((props2 = {}) => {\n    return {\n      ref: domRef,\n      \"data-filled\": dataAttr(isFilled),\n      \"data-filled-within\": dataAttr(isFilledWithin),\n      className: slots.input({\n        class: clsx(classNames == null ? void 0 : classNames.input, !!inputValue ? \"is-filled\" : \"\")\n      }),\n      ...mergeProps(focusProps, inputProps, filterDOMProps(otherProps, {\n        enabled: true,\n        labelable: true,\n        omitEventNames: new Set(Object.keys(inputProps))\n      }), props2),\n      required: originalProps.isRequired,\n      \"aria-readonly\": dataAttr(originalProps.isReadOnly),\n      \"aria-required\": dataAttr(originalProps.isRequired),\n      onChange: chain(inputProps.onChange, onChange)\n    };\n  }, [slots, inputValue, focusProps, inputProps, otherProps, isFilled, isFilledWithin, classNames == null ? void 0 : classNames.input, originalProps.isReadOnly, originalProps.isRequired, onChange]);\n  const getInputWrapperProps = useCallback((props2 = {}) => {\n    return {\n      \"data-hover\": dataAttr(isHovered),\n      \"data-focus-visible\": dataAttr(isFocusVisible),\n      \"data-focus\": dataAttr(isFocused),\n      className: slots.inputWrapper({\n        class: clsx(classNames == null ? void 0 : classNames.inputWrapper, !!inputValue ? \"is-filled\" : \"\")\n      }),\n      onClick: e => {\n        var _a;\n        if (e.target === e.currentTarget) {\n          (_a = domRef.current) == null ? void 0 : _a.focus();\n        }\n      },\n      ...mergeProps(props2, hoverProps),\n      style: {\n        cursor: \"text\",\n        ...props2.style\n      }\n    };\n  }, [slots, isHovered, isFocusVisible, isFocused, inputValue, classNames == null ? void 0 : classNames.inputWrapper]);\n  const getInnerWrapperProps = useCallback((props2 = {}) => {\n    return {\n      ...props2,\n      className: slots.innerWrapper({\n        class: clsx(classNames == null ? void 0 : classNames.innerWrapper, props2 == null ? void 0 : props2.className)\n      })\n    };\n  }, [slots, classNames == null ? void 0 : classNames.innerWrapper]);\n  const getMainWrapperProps = useCallback((props2 = {}) => {\n    return {\n      ...props2,\n      className: slots.mainWrapper({\n        class: clsx(classNames == null ? void 0 : classNames.mainWrapper, props2 == null ? void 0 : props2.className)\n      })\n    };\n  }, [slots, classNames == null ? void 0 : classNames.mainWrapper]);\n  const getHelperWrapperProps = useCallback((props2 = {}) => {\n    return {\n      ...props2,\n      className: slots.helperWrapper({\n        class: clsx(classNames == null ? void 0 : classNames.helperWrapper, props2 == null ? void 0 : props2.className)\n      })\n    };\n  }, [slots, classNames == null ? void 0 : classNames.helperWrapper]);\n  const getDescriptionProps = useCallback((props2 = {}) => {\n    return {\n      ...props2,\n      ...descriptionProps,\n      className: slots.description({\n        class: clsx(classNames == null ? void 0 : classNames.description, props2 == null ? void 0 : props2.className)\n      })\n    };\n  }, [slots, classNames == null ? void 0 : classNames.description]);\n  const getErrorMessageProps = useCallback((props2 = {}) => {\n    return {\n      ...props2,\n      ...errorMessageProps,\n      className: slots.errorMessage({\n        class: clsx(classNames == null ? void 0 : classNames.errorMessage, props2 == null ? void 0 : props2.className)\n      })\n    };\n  }, [slots, errorMessageProps, classNames == null ? void 0 : classNames.errorMessage]);\n  const getClearButtonProps = useCallback((props2 = {}) => {\n    return {\n      ...props2,\n      role: \"button\",\n      tabIndex: 0,\n      \"data-focus-visible\": dataAttr(isClearButtonFocusVisible),\n      className: slots.clearButton({\n        class: clsx(classNames == null ? void 0 : classNames.clearButton, props2 == null ? void 0 : props2.className)\n      }),\n      ...mergeProps(clearPressProps, clearFocusProps)\n    };\n  }, [slots, isClearButtonFocusVisible, clearPressProps, clearFocusProps, classNames == null ? void 0 : classNames.clearButton]);\n  return {\n    Component,\n    classNames,\n    domRef,\n    label,\n    description,\n    startContent,\n    endContent,\n    labelPlacement,\n    isClearable,\n    isInvalid,\n    hasHelper,\n    hasStartContent,\n    isLabelOutside,\n    isLabelOutsideAsPlaceholder,\n    shouldLabelBeOutside,\n    shouldLabelBeInside,\n    hasPlaceholder,\n    errorMessage,\n    getBaseProps,\n    getLabelProps,\n    getInputProps,\n    getMainWrapperProps,\n    getInputWrapperProps,\n    getInnerWrapperProps,\n    getHelperWrapperProps,\n    getDescriptionProps,\n    getErrorMessageProps,\n    getClearButtonProps\n  };\n}\nexport { useInput };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}