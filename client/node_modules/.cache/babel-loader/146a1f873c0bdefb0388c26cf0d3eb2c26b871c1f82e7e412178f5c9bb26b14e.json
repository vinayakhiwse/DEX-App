{"ast":null,"code":"import { d, b, f, c, e, a, g } from './chunk-FHRYMRZ3.js';\nimport { twMerge, extendTailwindMerge } from 'tailwind-merge';\nvar re = {\n    twMerge: !0,\n    twMergeConfig: {},\n    responsiveVariants: !1\n  },\n  Z = i => i || void 0,\n  j = (...i) => Z(d(i).filter(Boolean).join(\" \")),\n  B = null,\n  O = {},\n  R = !1,\n  A = (...i) => v => v.twMerge ? ((!B || R) && (R = !1, B = b(O) ? twMerge : extendTailwindMerge(O)), Z(B(j(i)))) : j(i),\n  Y = (i, v) => {\n    for (let e in v) i.hasOwnProperty(e) ? i[e] = j(i[e], v[e]) : i[e] = v[e];\n    return i;\n  },\n  ce = (i, v) => {\n    let {\n        extend: e$1 = null,\n        slots: N = {},\n        variants: q = {},\n        compoundVariants: C = [],\n        compoundSlots: V = [],\n        defaultVariants: F = {}\n      } = i,\n      m = {\n        ...re,\n        ...v\n      },\n      M = e$1 != null && e$1.base ? j(e$1.base, i == null ? void 0 : i.base) : i == null ? void 0 : i.base,\n      g$1 = e$1 != null && e$1.variants && !b(e$1.variants) ? f(q, e$1.variants) : q,\n      h = e$1 != null && e$1.defaultVariants && !b(e$1.defaultVariants) ? {\n        ...e$1.defaultVariants,\n        ...F\n      } : F;\n    !b(m.twMergeConfig) && !c(m.twMergeConfig, O) && (R = !0, O = m.twMergeConfig);\n    let $ = b(N) ? {} : {\n        base: i == null ? void 0 : i.base,\n        ...N\n      },\n      w = b(e$1 == null ? void 0 : e$1.slots) ? $ : Y(e$1 == null ? void 0 : e$1.slots, b($) ? {\n        base: i == null ? void 0 : i.base\n      } : $),\n      d = f => {\n        if (b(g$1) && b(N) && b(e$1 == null ? void 0 : e$1.slots)) return A(M, f == null ? void 0 : f.class, f == null ? void 0 : f.className)(m);\n        if (C && !Array.isArray(C)) throw new TypeError(`The \"compoundVariants\" prop must be an array. Received: ${typeof C}`);\n        if (V && !Array.isArray(V)) throw new TypeError(`The \"compoundSlots\" prop must be an array. Received: ${typeof V}`);\n        let K = (t, n, a = [], s) => {\n            let r = a;\n            if (typeof n == \"string\") r = r.concat(g(n).split(\" \").map(l => `${t}:${l}`));else if (Array.isArray(n)) r = r.concat(n.reduce((l, c) => l.concat(`${t}:${c}`), []));else if (typeof n == \"object\" && typeof s == \"string\") {\n              for (let l in n) if (n.hasOwnProperty(l) && l === s) {\n                let c = n[l];\n                if (c && typeof c == \"string\") {\n                  let y = g(c);\n                  r[s] ? r[s] = r[s].concat(y.split(\" \").map(u => `${t}:${u}`)) : r[s] = y.split(\" \").map(u => `${t}:${u}`);\n                } else Array.isArray(c) && c.length > 0 && (r[s] = c.reduce((y, u) => y.concat(`${t}:${u}`), []));\n              }\n            }\n            return r;\n          },\n          U = (t, n = g$1, a$1 = null, s = null) => {\n            var H;\n            let r = n[t];\n            if (!r || b(r)) return null;\n            let l = (H = s == null ? void 0 : s[t]) != null ? H : f == null ? void 0 : f[t];\n            if (l === null) return null;\n            let c = a(l),\n              y = Array.isArray(m.responsiveVariants) && m.responsiveVariants.length > 0 || m.responsiveVariants === !0,\n              u = h == null ? void 0 : h[t],\n              b$1 = [];\n            if (typeof c == \"object\" && y) for (let [k, I] of Object.entries(c)) {\n              let te = r[I];\n              if (k === \"initial\") {\n                u = I;\n                continue;\n              }\n              Array.isArray(m.responsiveVariants) && !m.responsiveVariants.includes(k) || (b$1 = K(k, te, b$1, a$1));\n            }\n            let S = r[c] || r[a(u)];\n            return typeof b$1 == \"object\" && typeof a$1 == \"string\" && b$1[a$1] ? Y(b$1, S) : b$1.length > 0 ? (b$1.push(S), b$1) : S;\n          },\n          x = () => g$1 ? Object.keys(g$1).map(t => U(t, g$1)) : null,\n          P = (t, n) => {\n            if (!g$1 || typeof g$1 != \"object\") return null;\n            let a = new Array();\n            for (let s in g$1) {\n              let r = U(s, g$1, t, n),\n                l = t === \"base\" && typeof r == \"string\" ? r : r && r[t];\n              l && (a[a.length] = l);\n            }\n            return a;\n          },\n          W = {};\n        for (let t in f) f[t] !== void 0 && (W[t] = f[t]);\n        let z = (t, n) => {\n            var s;\n            let a = typeof (f == null ? void 0 : f[t]) == \"object\" ? {\n              [t]: (s = f[t]) == null ? void 0 : s.initial\n            } : {};\n            return {\n              ...h,\n              ...W,\n              ...a,\n              ...n\n            };\n          },\n          D = (t = [], n) => {\n            let a = [];\n            for (let {\n              class: s,\n              className: r,\n              ...l\n            } of t) {\n              let c = !0;\n              for (let [y, u] of Object.entries(l)) {\n                let b = z(y, n);\n                if (Array.isArray(u)) {\n                  if (!u.includes(b[y])) {\n                    c = !1;\n                    break;\n                  }\n                } else if (b[y] !== u) {\n                  c = !1;\n                  break;\n                }\n              }\n              c && (s && a.push(s), r && a.push(r));\n            }\n            return a;\n          },\n          G = t => {\n            let n = D(C, t),\n              a = D(e$1 == null ? void 0 : e$1.compoundVariants, t);\n            return e(a, n);\n          },\n          p = t => {\n            let n = G(t);\n            if (!Array.isArray(n)) return n;\n            let a = {};\n            for (let s of n) if (typeof s == \"string\" && (a.base = A(a.base, s)(m)), typeof s == \"object\") for (let [r, l] of Object.entries(s)) a[r] = A(a[r], l)(m);\n            return a;\n          },\n          ee = t => {\n            if (V.length < 1) return null;\n            let n = {};\n            for (let {\n              slots: a = [],\n              class: s,\n              className: r,\n              ...l\n            } of V) {\n              if (!b(l)) {\n                let c = !0;\n                for (let y of Object.keys(l)) {\n                  let u = z(y, t)[y];\n                  if (u === void 0 || u !== l[y]) {\n                    c = !1;\n                    break;\n                  }\n                }\n                if (!c) continue;\n              }\n              for (let c of a) n[c] = n[c] || [], n[c].push([s, r]);\n            }\n            return n;\n          };\n        if (!b(N) || !b(e$1 == null ? void 0 : e$1.slots)) {\n          let t = {};\n          if (typeof w == \"object\" && !b(w)) for (let n of Object.keys(w)) t[n] = a => {\n            var s, r;\n            return A(w[n], P(n, a), ((s = p(a)) != null ? s : [])[n], ((r = ee(a)) != null ? r : [])[n], a == null ? void 0 : a.class, a == null ? void 0 : a.className)(m);\n          };\n          return t;\n        }\n        return A(M, x(), G(), f == null ? void 0 : f.class, f == null ? void 0 : f.className)(m);\n      },\n      _ = () => {\n        if (!(!g$1 || typeof g$1 != \"object\")) return Object.keys(g$1);\n      };\n    return d.variantKeys = _(), d.extend = e$1, d.base = M, d.slots = w, d.variants = g$1, d.defaultVariants = h, d.compoundSlots = V, d.compoundVariants = C, d;\n  };\nexport { A as cn, j as cnBase, re as defaultConfig, ce as tv, Z as voidEmpty };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}