{"ast":null,"code":"import ee, { Fragment as xe, createContext as pe, createRef as Ce, useCallback as Oe, useContext as se, useEffect as be, useMemo as M, useReducer as ge, useRef as S } from \"react\";\nimport { useComputed as ne } from '../../hooks/use-computed.js';\nimport { useDisposables as re } from '../../hooks/use-disposables.js';\nimport { useEvent as x } from '../../hooks/use-event.js';\nimport { useId as Q } from '../../hooks/use-id.js';\nimport { useIsoMorphicEffect as k } from '../../hooks/use-iso-morphic-effect.js';\nimport { useLatestValue as ye } from '../../hooks/use-latest-value.js';\nimport { useOutsideClick as Re } from '../../hooks/use-outside-click.js';\nimport { useResolveButtonType as ve } from '../../hooks/use-resolve-button-type.js';\nimport { useSyncRefs as Y } from '../../hooks/use-sync-refs.js';\nimport { useTreeWalker as Pe } from '../../hooks/use-tree-walker.js';\nimport { calculateActiveIndex as Ae, Focus as R } from '../../utils/calculate-active-index.js';\nimport { disposables as de } from '../../utils/disposables.js';\nimport { forwardRefWithAs as G, render as X, compact as Ee, Features as fe } from '../../utils/render.js';\nimport { isDisabledReactIssue7711 as Se } from '../../utils/bugs.js';\nimport { match as j } from '../../utils/match.js';\nimport { objectToFormEntries as Ie } from '../../utils/form.js';\nimport { sortByDomNode as Le } from '../../utils/focus-management.js';\nimport { Hidden as Ve, Features as De } from '../../internal/hidden.js';\nimport { useOpenClosed as Fe, State as oe, OpenClosedProvider as Me } from '../../internal/open-closed.js';\nimport { Keys as I } from '../keyboard.js';\nimport { useControllable as _e } from '../../hooks/use-controllable.js';\nimport { useWatch as ce } from '../../hooks/use-watch.js';\nimport { useTrackedPointer as he } from '../../hooks/use-tracked-pointer.js';\nimport { isMobile as Be } from '../../utils/platform.js';\nimport { useOwnerDocument as ke } from '../../hooks/use-owner.js';\nvar we = (e => (e[e.Open = 0] = \"Open\", e[e.Closed = 1] = \"Closed\", e))(we || {}),\n  Ue = (e => (e[e.Single = 0] = \"Single\", e[e.Multi = 1] = \"Multi\", e))(Ue || {}),\n  Ne = (e => (e[e.Pointer = 0] = \"Pointer\", e[e.Other = 1] = \"Other\", e))(Ne || {}),\n  He = (n => (n[n.OpenCombobox = 0] = \"OpenCombobox\", n[n.CloseCombobox = 1] = \"CloseCombobox\", n[n.GoToOption = 2] = \"GoToOption\", n[n.RegisterOption = 3] = \"RegisterOption\", n[n.UnregisterOption = 4] = \"UnregisterOption\", n[n.RegisterLabel = 5] = \"RegisterLabel\", n))(He || {});\nfunction ae(t, a = e => e) {\n  let e = t.activeOptionIndex !== null ? t.options[t.activeOptionIndex] : null,\n    r = Le(a(t.options.slice()), b => b.dataRef.current.domRef.current),\n    l = e ? r.indexOf(e) : null;\n  return l === -1 && (l = null), {\n    options: r,\n    activeOptionIndex: l\n  };\n}\nlet Ge = {\n    [1](t) {\n      var a;\n      return (a = t.dataRef.current) != null && a.disabled || t.comboboxState === 1 ? t : {\n        ...t,\n        activeOptionIndex: null,\n        comboboxState: 1\n      };\n    },\n    [0](t) {\n      var e;\n      if ((e = t.dataRef.current) != null && e.disabled || t.comboboxState === 0) return t;\n      let a = t.activeOptionIndex;\n      if (t.dataRef.current) {\n        let {\n            isSelected: r\n          } = t.dataRef.current,\n          l = t.options.findIndex(b => r(b.dataRef.current.value));\n        l !== -1 && (a = l);\n      }\n      return {\n        ...t,\n        comboboxState: 0,\n        activeOptionIndex: a\n      };\n    },\n    [2](t, a) {\n      var l, b, n, d;\n      if ((l = t.dataRef.current) != null && l.disabled || (b = t.dataRef.current) != null && b.optionsRef.current && !((n = t.dataRef.current) != null && n.optionsPropsRef.current.static) && t.comboboxState === 1) return t;\n      let e = ae(t);\n      if (e.activeOptionIndex === null) {\n        let o = e.options.findIndex(i => !i.dataRef.current.disabled);\n        o !== -1 && (e.activeOptionIndex = o);\n      }\n      let r = Ae(a, {\n        resolveItems: () => e.options,\n        resolveActiveIndex: () => e.activeOptionIndex,\n        resolveId: o => o.id,\n        resolveDisabled: o => o.dataRef.current.disabled\n      });\n      return {\n        ...t,\n        ...e,\n        activeOptionIndex: r,\n        activationTrigger: (d = a.trigger) != null ? d : 1\n      };\n    },\n    [3]: (t, a) => {\n      var b, n;\n      let e = {\n          id: a.id,\n          dataRef: a.dataRef\n        },\n        r = ae(t, d => [...d, e]);\n      t.activeOptionIndex === null && (b = t.dataRef.current) != null && b.isSelected(a.dataRef.current.value) && (r.activeOptionIndex = r.options.indexOf(e));\n      let l = {\n        ...t,\n        ...r,\n        activationTrigger: 1\n      };\n      return (n = t.dataRef.current) != null && n.__demoMode && t.dataRef.current.value === void 0 && (l.activeOptionIndex = 0), l;\n    },\n    [4]: (t, a) => {\n      let e = ae(t, r => {\n        let l = r.findIndex(b => b.id === a.id);\n        return l !== -1 && r.splice(l, 1), r;\n      });\n      return {\n        ...t,\n        ...e,\n        activationTrigger: 1\n      };\n    },\n    [5]: (t, a) => ({\n      ...t,\n      labelId: a.id\n    })\n  },\n  le = pe(null);\nle.displayName = \"ComboboxActionsContext\";\nfunction Z(t) {\n  let a = se(le);\n  if (a === null) {\n    let e = new Error(`<${t} /> is missing a parent <Combobox /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(e, Z), e;\n  }\n  return a;\n}\nlet ie = pe(null);\nie.displayName = \"ComboboxDataContext\";\nfunction J(t) {\n  let a = se(ie);\n  if (a === null) {\n    let e = new Error(`<${t} /> is missing a parent <Combobox /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(e, J), e;\n  }\n  return a;\n}\nfunction Xe(t, a) {\n  return j(a.type, Ge, t, a);\n}\nlet je = xe;\nfunction Je(t, a) {\n  let {\n      value: e,\n      defaultValue: r,\n      onChange: l,\n      form: b,\n      name: n,\n      by: d = (u, T) => u === T,\n      disabled: o = !1,\n      __demoMode: i = !1,\n      nullable: A = !1,\n      multiple: O = !1,\n      ...C\n    } = t,\n    [f = O ? [] : void 0, g] = _e(e, l, r),\n    [m, c] = ge(Xe, {\n      dataRef: Ce(),\n      comboboxState: i ? 0 : 1,\n      options: [],\n      activeOptionIndex: null,\n      activationTrigger: 1,\n      labelId: null\n    }),\n    D = S(!1),\n    _ = S({\n      static: !1,\n      hold: !1\n    }),\n    w = S(null),\n    U = S(null),\n    N = S(null),\n    K = S(null),\n    h = x(typeof d == \"string\" ? (u, T) => {\n      let v = d;\n      return (u == null ? void 0 : u[v]) === (T == null ? void 0 : T[v]);\n    } : d),\n    H = Oe(u => j(p.mode, {\n      [1]: () => f.some(T => h(T, u)),\n      [0]: () => h(f, u)\n    }), [f]),\n    p = M(() => ({\n      ...m,\n      optionsPropsRef: _,\n      labelRef: w,\n      inputRef: U,\n      buttonRef: N,\n      optionsRef: K,\n      value: f,\n      defaultValue: r,\n      disabled: o,\n      mode: O ? 1 : 0,\n      get activeOptionIndex() {\n        if (D.current && m.activeOptionIndex === null && m.options.length > 0) {\n          let u = m.options.findIndex(T => !T.dataRef.current.disabled);\n          if (u !== -1) return u;\n        }\n        return m.activeOptionIndex;\n      },\n      compare: h,\n      isSelected: H,\n      nullable: A,\n      __demoMode: i\n    }), [f, r, o, O, A, i, m]),\n    y = S(p.activeOptionIndex !== null ? p.options[p.activeOptionIndex] : null);\n  be(() => {\n    let u = p.activeOptionIndex !== null ? p.options[p.activeOptionIndex] : null;\n    y.current !== u && (y.current = u);\n  }), k(() => {\n    m.dataRef.current = p;\n  }, [p]), Re([p.buttonRef, p.inputRef, p.optionsRef], () => te.closeCombobox(), p.comboboxState === 0);\n  let E = M(() => ({\n      open: p.comboboxState === 0,\n      disabled: o,\n      activeIndex: p.activeOptionIndex,\n      activeOption: p.activeOptionIndex === null ? null : p.options[p.activeOptionIndex].dataRef.current.value,\n      value: f\n    }), [p, o, f]),\n    B = x(u => {\n      let T = p.options.find(v => v.id === u);\n      T && V(T.dataRef.current.value);\n    }),\n    s = x(() => {\n      if (p.activeOptionIndex !== null) {\n        let {\n          dataRef: u,\n          id: T\n        } = p.options[p.activeOptionIndex];\n        V(u.current.value), te.goToOption(R.Specific, T);\n      }\n    }),\n    W = x(() => {\n      c({\n        type: 0\n      }), D.current = !0;\n    }),\n    L = x(() => {\n      c({\n        type: 1\n      }), D.current = !1;\n    }),\n    $ = x((u, T, v) => (D.current = !1, u === R.Specific ? c({\n      type: 2,\n      focus: R.Specific,\n      id: T,\n      trigger: v\n    }) : c({\n      type: 2,\n      focus: u,\n      trigger: v\n    }))),\n    P = x((u, T) => (c({\n      type: 3,\n      id: u,\n      dataRef: T\n    }), () => {\n      var v;\n      ((v = y.current) == null ? void 0 : v.id) === u && (D.current = !0), c({\n        type: 4,\n        id: u\n      });\n    })),\n    F = x(u => (c({\n      type: 5,\n      id: u\n    }), () => c({\n      type: 5,\n      id: null\n    }))),\n    V = x(u => j(p.mode, {\n      [0]() {\n        return g == null ? void 0 : g(u);\n      },\n      [1]() {\n        let T = p.value.slice(),\n          v = T.findIndex(q => h(q, u));\n        return v === -1 ? T.push(u) : T.splice(v, 1), g == null ? void 0 : g(T);\n      }\n    })),\n    te = M(() => ({\n      onChange: V,\n      registerOption: P,\n      registerLabel: F,\n      goToOption: $,\n      closeCombobox: L,\n      openCombobox: W,\n      selectActiveOption: s,\n      selectOption: B\n    }), []),\n    Te = a === null ? {} : {\n      ref: a\n    },\n    z = S(null),\n    me = re();\n  return be(() => {\n    z.current && r !== void 0 && me.addEventListener(z.current, \"reset\", () => {\n      g == null || g(r);\n    });\n  }, [z, g]), ee.createElement(le.Provider, {\n    value: te\n  }, ee.createElement(ie.Provider, {\n    value: p\n  }, ee.createElement(Me, {\n    value: j(p.comboboxState, {\n      [0]: oe.Open,\n      [1]: oe.Closed\n    })\n  }, n != null && f != null && Ie({\n    [n]: f\n  }).map(([u, T], v) => ee.createElement(Ve, {\n    features: De.Hidden,\n    ref: v === 0 ? q => {\n      var ue;\n      z.current = (ue = q == null ? void 0 : q.closest(\"form\")) != null ? ue : null;\n    } : void 0,\n    ...Ee({\n      key: u,\n      as: \"input\",\n      type: \"hidden\",\n      hidden: !0,\n      readOnly: !0,\n      form: b,\n      name: u,\n      value: T\n    })\n  })), X({\n    ourProps: Te,\n    theirProps: C,\n    slot: E,\n    defaultTag: je,\n    name: \"Combobox\"\n  }))));\n}\nlet Ke = \"input\";\nfunction We(t, a) {\n  var p, y, E, B;\n  let e = Q(),\n    {\n      id: r = `headlessui-combobox-input-${e}`,\n      onChange: l,\n      displayValue: b,\n      type: n = \"text\",\n      ...d\n    } = t,\n    o = J(\"Combobox.Input\"),\n    i = Z(\"Combobox.Input\"),\n    A = Y(o.inputRef, a),\n    O = ke(o.inputRef),\n    C = S(!1),\n    f = re(),\n    g = x(() => {\n      i.onChange(null), o.optionsRef.current && (o.optionsRef.current.scrollTop = 0), i.goToOption(R.Nothing);\n    }),\n    m = function () {\n      var s;\n      return typeof b == \"function\" && o.value !== void 0 ? (s = b(o.value)) != null ? s : \"\" : typeof o.value == \"string\" ? o.value : \"\";\n    }();\n  ce(([s, W], [L, $]) => {\n    if (C.current) return;\n    let P = o.inputRef.current;\n    P && (($ === 0 && W === 1 || s !== L) && (P.value = s), requestAnimationFrame(() => {\n      if (C.current || !P || (O == null ? void 0 : O.activeElement) !== P) return;\n      let {\n        selectionStart: F,\n        selectionEnd: V\n      } = P;\n      Math.abs((V != null ? V : 0) - (F != null ? F : 0)) === 0 && F === 0 && P.setSelectionRange(P.value.length, P.value.length);\n    }));\n  }, [m, o.comboboxState, O]), ce(([s], [W]) => {\n    if (s === 0 && W === 1) {\n      if (C.current) return;\n      let L = o.inputRef.current;\n      if (!L) return;\n      let $ = L.value,\n        {\n          selectionStart: P,\n          selectionEnd: F,\n          selectionDirection: V\n        } = L;\n      L.value = \"\", L.value = $, V !== null ? L.setSelectionRange(P, F, V) : L.setSelectionRange(P, F);\n    }\n  }, [o.comboboxState]);\n  let c = S(!1),\n    D = x(() => {\n      c.current = !0;\n    }),\n    _ = x(() => {\n      f.nextFrame(() => {\n        c.current = !1;\n      });\n    }),\n    w = x(s => {\n      switch (C.current = !0, s.key) {\n        case I.Enter:\n          if (C.current = !1, o.comboboxState !== 0 || c.current) return;\n          if (s.preventDefault(), s.stopPropagation(), o.activeOptionIndex === null) {\n            i.closeCombobox();\n            return;\n          }\n          i.selectActiveOption(), o.mode === 0 && i.closeCombobox();\n          break;\n        case I.ArrowDown:\n          return C.current = !1, s.preventDefault(), s.stopPropagation(), j(o.comboboxState, {\n            [0]: () => {\n              i.goToOption(R.Next);\n            },\n            [1]: () => {\n              i.openCombobox();\n            }\n          });\n        case I.ArrowUp:\n          return C.current = !1, s.preventDefault(), s.stopPropagation(), j(o.comboboxState, {\n            [0]: () => {\n              i.goToOption(R.Previous);\n            },\n            [1]: () => {\n              i.openCombobox(), f.nextFrame(() => {\n                o.value || i.goToOption(R.Last);\n              });\n            }\n          });\n        case I.Home:\n          if (s.shiftKey) break;\n          return C.current = !1, s.preventDefault(), s.stopPropagation(), i.goToOption(R.First);\n        case I.PageUp:\n          return C.current = !1, s.preventDefault(), s.stopPropagation(), i.goToOption(R.First);\n        case I.End:\n          if (s.shiftKey) break;\n          return C.current = !1, s.preventDefault(), s.stopPropagation(), i.goToOption(R.Last);\n        case I.PageDown:\n          return C.current = !1, s.preventDefault(), s.stopPropagation(), i.goToOption(R.Last);\n        case I.Escape:\n          return C.current = !1, o.comboboxState !== 0 ? void 0 : (s.preventDefault(), o.optionsRef.current && !o.optionsPropsRef.current.static && s.stopPropagation(), o.nullable && o.mode === 0 && o.value === null && g(), i.closeCombobox());\n        case I.Tab:\n          if (C.current = !1, o.comboboxState !== 0) return;\n          o.mode === 0 && i.selectActiveOption(), i.closeCombobox();\n          break;\n      }\n    }),\n    U = x(s => {\n      l == null || l(s), o.nullable && o.mode === 0 && s.target.value === \"\" && g(), i.openCombobox();\n    }),\n    N = x(() => {\n      C.current = !1;\n    }),\n    K = ne(() => {\n      if (o.labelId) return [o.labelId].join(\" \");\n    }, [o.labelId]),\n    h = M(() => ({\n      open: o.comboboxState === 0,\n      disabled: o.disabled\n    }), [o]),\n    H = {\n      ref: A,\n      id: r,\n      role: \"combobox\",\n      type: n,\n      \"aria-controls\": (p = o.optionsRef.current) == null ? void 0 : p.id,\n      \"aria-expanded\": o.comboboxState === 0,\n      \"aria-activedescendant\": o.activeOptionIndex === null || (y = o.options[o.activeOptionIndex]) == null ? void 0 : y.id,\n      \"aria-labelledby\": K,\n      \"aria-autocomplete\": \"list\",\n      defaultValue: (B = (E = t.defaultValue) != null ? E : o.defaultValue !== void 0 ? b == null ? void 0 : b(o.defaultValue) : null) != null ? B : o.defaultValue,\n      disabled: o.disabled,\n      onCompositionStart: D,\n      onCompositionEnd: _,\n      onKeyDown: w,\n      onChange: U,\n      onBlur: N\n    };\n  return X({\n    ourProps: H,\n    theirProps: d,\n    slot: h,\n    defaultTag: Ke,\n    name: \"Combobox.Input\"\n  });\n}\nlet $e = \"button\";\nfunction qe(t, a) {\n  var g;\n  let e = J(\"Combobox.Button\"),\n    r = Z(\"Combobox.Button\"),\n    l = Y(e.buttonRef, a),\n    b = Q(),\n    {\n      id: n = `headlessui-combobox-button-${b}`,\n      ...d\n    } = t,\n    o = re(),\n    i = x(m => {\n      switch (m.key) {\n        case I.ArrowDown:\n          return m.preventDefault(), m.stopPropagation(), e.comboboxState === 1 && r.openCombobox(), o.nextFrame(() => {\n            var c;\n            return (c = e.inputRef.current) == null ? void 0 : c.focus({\n              preventScroll: !0\n            });\n          });\n        case I.ArrowUp:\n          return m.preventDefault(), m.stopPropagation(), e.comboboxState === 1 && (r.openCombobox(), o.nextFrame(() => {\n            e.value || r.goToOption(R.Last);\n          })), o.nextFrame(() => {\n            var c;\n            return (c = e.inputRef.current) == null ? void 0 : c.focus({\n              preventScroll: !0\n            });\n          });\n        case I.Escape:\n          return e.comboboxState !== 0 ? void 0 : (m.preventDefault(), e.optionsRef.current && !e.optionsPropsRef.current.static && m.stopPropagation(), r.closeCombobox(), o.nextFrame(() => {\n            var c;\n            return (c = e.inputRef.current) == null ? void 0 : c.focus({\n              preventScroll: !0\n            });\n          }));\n        default:\n          return;\n      }\n    }),\n    A = x(m => {\n      if (Se(m.currentTarget)) return m.preventDefault();\n      e.comboboxState === 0 ? r.closeCombobox() : (m.preventDefault(), r.openCombobox()), o.nextFrame(() => {\n        var c;\n        return (c = e.inputRef.current) == null ? void 0 : c.focus({\n          preventScroll: !0\n        });\n      });\n    }),\n    O = ne(() => {\n      if (e.labelId) return [e.labelId, n].join(\" \");\n    }, [e.labelId, n]),\n    C = M(() => ({\n      open: e.comboboxState === 0,\n      disabled: e.disabled,\n      value: e.value\n    }), [e]),\n    f = {\n      ref: l,\n      id: n,\n      type: ve(t, e.buttonRef),\n      tabIndex: -1,\n      \"aria-haspopup\": \"listbox\",\n      \"aria-controls\": (g = e.optionsRef.current) == null ? void 0 : g.id,\n      \"aria-expanded\": e.comboboxState === 0,\n      \"aria-labelledby\": O,\n      disabled: e.disabled,\n      onClick: A,\n      onKeyDown: i\n    };\n  return X({\n    ourProps: f,\n    theirProps: d,\n    slot: C,\n    defaultTag: $e,\n    name: \"Combobox.Button\"\n  });\n}\nlet Qe = \"label\";\nfunction Ye(t, a) {\n  let e = Q(),\n    {\n      id: r = `headlessui-combobox-label-${e}`,\n      ...l\n    } = t,\n    b = J(\"Combobox.Label\"),\n    n = Z(\"Combobox.Label\"),\n    d = Y(b.labelRef, a);\n  k(() => n.registerLabel(r), [r]);\n  let o = x(() => {\n      var O;\n      return (O = b.inputRef.current) == null ? void 0 : O.focus({\n        preventScroll: !0\n      });\n    }),\n    i = M(() => ({\n      open: b.comboboxState === 0,\n      disabled: b.disabled\n    }), [b]);\n  return X({\n    ourProps: {\n      ref: d,\n      id: r,\n      onClick: o\n    },\n    theirProps: l,\n    slot: i,\n    defaultTag: Qe,\n    name: \"Combobox.Label\"\n  });\n}\nlet Ze = \"ul\",\n  ze = fe.RenderStrategy | fe.Static;\nfunction eo(t, a) {\n  let e = Q(),\n    {\n      id: r = `headlessui-combobox-options-${e}`,\n      hold: l = !1,\n      ...b\n    } = t,\n    n = J(\"Combobox.Options\"),\n    d = Y(n.optionsRef, a),\n    o = Fe(),\n    i = (() => o !== null ? (o & oe.Open) === oe.Open : n.comboboxState === 0)();\n  k(() => {\n    var f;\n    n.optionsPropsRef.current.static = (f = t.static) != null ? f : !1;\n  }, [n.optionsPropsRef, t.static]), k(() => {\n    n.optionsPropsRef.current.hold = l;\n  }, [n.optionsPropsRef, l]), Pe({\n    container: n.optionsRef.current,\n    enabled: n.comboboxState === 0,\n    accept(f) {\n      return f.getAttribute(\"role\") === \"option\" ? NodeFilter.FILTER_REJECT : f.hasAttribute(\"role\") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;\n    },\n    walk(f) {\n      f.setAttribute(\"role\", \"none\");\n    }\n  });\n  let A = ne(() => {\n      var f, g;\n      return (g = n.labelId) != null ? g : (f = n.buttonRef.current) == null ? void 0 : f.id;\n    }, [n.labelId, n.buttonRef.current]),\n    O = M(() => ({\n      open: n.comboboxState === 0\n    }), [n]),\n    C = {\n      \"aria-labelledby\": A,\n      role: \"listbox\",\n      \"aria-multiselectable\": n.mode === 1 ? !0 : void 0,\n      id: r,\n      ref: d\n    };\n  return X({\n    ourProps: C,\n    theirProps: b,\n    slot: O,\n    defaultTag: Ze,\n    features: ze,\n    visible: i,\n    name: \"Combobox.Options\"\n  });\n}\nlet oo = \"li\";\nfunction to(t, a) {\n  var H, p;\n  let e = Q(),\n    {\n      id: r = `headlessui-combobox-option-${e}`,\n      disabled: l = !1,\n      value: b,\n      ...n\n    } = t,\n    d = J(\"Combobox.Option\"),\n    o = Z(\"Combobox.Option\"),\n    i = d.activeOptionIndex !== null ? d.options[d.activeOptionIndex].id === r : !1,\n    A = d.isSelected(b),\n    O = S(null),\n    C = ye({\n      disabled: l,\n      value: b,\n      domRef: O,\n      textValue: (p = (H = O.current) == null ? void 0 : H.textContent) == null ? void 0 : p.toLowerCase()\n    }),\n    f = Y(a, O),\n    g = x(() => o.selectOption(r));\n  k(() => o.registerOption(r, C), [C, r]);\n  let m = S(!d.__demoMode);\n  k(() => {\n    if (!d.__demoMode) return;\n    let y = de();\n    return y.requestAnimationFrame(() => {\n      m.current = !0;\n    }), y.dispose;\n  }, []), k(() => {\n    if (d.comboboxState !== 0 || !i || !m.current || d.activationTrigger === 0) return;\n    let y = de();\n    return y.requestAnimationFrame(() => {\n      var E, B;\n      (B = (E = O.current) == null ? void 0 : E.scrollIntoView) == null || B.call(E, {\n        block: \"nearest\"\n      });\n    }), y.dispose;\n  }, [O, i, d.comboboxState, d.activationTrigger, d.activeOptionIndex]);\n  let c = x(y => {\n      if (l) return y.preventDefault();\n      g(), d.mode === 0 && o.closeCombobox(), Be() || requestAnimationFrame(() => {\n        var E;\n        return (E = d.inputRef.current) == null ? void 0 : E.focus();\n      });\n    }),\n    D = x(() => {\n      if (l) return o.goToOption(R.Nothing);\n      o.goToOption(R.Specific, r);\n    }),\n    _ = he(),\n    w = x(y => _.update(y)),\n    U = x(y => {\n      _.wasMoved(y) && (l || i || o.goToOption(R.Specific, r, 0));\n    }),\n    N = x(y => {\n      _.wasMoved(y) && (l || i && (d.optionsPropsRef.current.hold || o.goToOption(R.Nothing)));\n    }),\n    K = M(() => ({\n      active: i,\n      selected: A,\n      disabled: l\n    }), [i, A, l]);\n  return X({\n    ourProps: {\n      id: r,\n      ref: f,\n      role: \"option\",\n      tabIndex: l === !0 ? void 0 : -1,\n      \"aria-disabled\": l === !0 ? !0 : void 0,\n      \"aria-selected\": A,\n      disabled: void 0,\n      onClick: c,\n      onFocus: D,\n      onPointerEnter: w,\n      onMouseEnter: w,\n      onPointerMove: U,\n      onMouseMove: U,\n      onPointerLeave: N,\n      onMouseLeave: N\n    },\n    theirProps: n,\n    slot: K,\n    defaultTag: oo,\n    name: \"Combobox.Option\"\n  });\n}\nlet no = G(Je),\n  ro = G(qe),\n  ao = G(We),\n  lo = G(Ye),\n  io = G(eo),\n  uo = G(to),\n  qo = Object.assign(no, {\n    Input: ao,\n    Button: ro,\n    Label: lo,\n    Options: io,\n    Option: uo\n  });\nexport { qo as Combobox };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}