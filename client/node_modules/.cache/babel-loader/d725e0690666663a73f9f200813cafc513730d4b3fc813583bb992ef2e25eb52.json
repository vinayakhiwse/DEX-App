{"ast":null,"code":"/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n    * Copyright 2020 Adobe. All rights reserved.\n    * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License. You may obtain a copy\n    * of the License at http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software distributed under\n    * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n    * OF ANY KIND, either express or implied. See the License for the specific language\n    * governing permissions and limitations under the License.\n    */let $488c6ddbf4ef74c2$var$formatterCache = new Map();\nlet $488c6ddbf4ef74c2$var$supportsSignDisplay = false;\ntry {\n  // @ts-ignore\n  $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat(\"de-DE\", {\n    signDisplay: \"exceptZero\"\n  }).resolvedOptions().signDisplay === \"exceptZero\";\n  // eslint-disable-next-line no-empty\n} catch (e) {}\nlet $488c6ddbf4ef74c2$var$supportsUnit = false;\ntry {\n  // @ts-ignore\n  $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat(\"de-DE\", {\n    style: \"unit\",\n    unit: \"degree\"\n  }).resolvedOptions().style === \"unit\";\n  // eslint-disable-next-line no-empty\n} catch (e) {}\n// Polyfill for units since Safari doesn't support them yet. See https://bugs.webkit.org/show_bug.cgi?id=215438.\n// Currently only polyfilling the unit degree in narrow format for ColorSlider in our supported locales.\n// Values were determined by switching to each locale manually in Chrome.\nconst $488c6ddbf4ef74c2$var$UNITS = {\n  degree: {\n    narrow: {\n      default: \"\\xb0\",\n      \"ja-JP\": \" 度\",\n      \"zh-TW\": \"度\",\n      \"sl-SI\": \" \\xb0\"\n    }\n  }\n};\nclass $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 {\n  /** Formats a number value as a string, according to the locale and options provided to the constructor. */format(value) {\n    let res = \"\";\n    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);else res = this.numberFormatter.format(value);\n    if (this.options.style === \"unit\" && !$488c6ddbf4ef74c2$var$supportsUnit) {\n      var _UNITS_unit;\n      let {\n        unit: unit,\n        unitDisplay = \"short\",\n        locale: locale\n      } = this.resolvedOptions();\n      let values = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];\n      res += values[locale] || values.default;\n    }\n    return res;\n  }\n  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */\n  formatToParts(value) {\n    // TODO: implement signDisplay for formatToParts\n    // @ts-ignore\n    return this.numberFormatter.formatToParts(value);\n  }\n  /** Formats a number range as a string. */\n  formatRange(start, end) {\n    // @ts-ignore\n    if (typeof this.numberFormatter.formatRange === \"function\")\n      // @ts-ignore\n      return this.numberFormatter.formatRange(start, end);\n    if (end < start) throw new RangeError(\"End date must be >= start date\");\n    // Very basic fallback for old browsers.\n    return `${this.format(start)} – ${this.format(end)}`;\n  }\n  /** Formats a number range as an array of parts. */\n  formatRangeToParts(start, end) {\n    // @ts-ignore\n    if (typeof this.numberFormatter.formatRangeToParts === \"function\")\n      // @ts-ignore\n      return this.numberFormatter.formatRangeToParts(start, end);\n    if (end < start) throw new RangeError(\"End date must be >= start date\");\n    let startParts = this.numberFormatter.formatToParts(start);\n    let endParts = this.numberFormatter.formatToParts(end);\n    return [...startParts.map(p => ({\n      ...p,\n      source: \"startRange\"\n    })), {\n      type: \"literal\",\n      value: \" – \",\n      source: \"shared\"\n    }, ...endParts.map(p => ({\n      ...p,\n      source: \"endRange\"\n    }))];\n  }\n  /** Returns the resolved formatting options based on the values passed to the constructor. */\n  resolvedOptions() {\n    let options = this.numberFormatter.resolvedOptions();\n    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options = {\n      ...options,\n      signDisplay: this.options.signDisplay\n    };\n    if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === \"unit\") options = {\n      ...options,\n      style: \"unit\",\n      unit: this.options.unit,\n      unitDisplay: this.options.unitDisplay\n    };\n    return options;\n  }\n  constructor(locale, options = {}) {\n    this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);\n    this.options = options;\n  }\n}\nfunction $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options = {}) {\n  let {\n    numberingSystem: numberingSystem\n  } = options;\n  if (numberingSystem && locale.indexOf(\"-u-nu-\") === -1) locale = `${locale}-u-nu-${numberingSystem}`;\n  if (options.style === \"unit\" && !$488c6ddbf4ef74c2$var$supportsUnit) {\n    var _UNITS_unit;\n    let {\n      unit: unit,\n      unitDisplay = \"short\"\n    } = options;\n    if (!unit) throw new Error('unit option must be provided with style: \"unit\"');\n    if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);\n    options = {\n      ...options,\n      style: \"decimal\"\n    };\n  }\n  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : \"\");\n  if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);\n  let numberFormatter = new Intl.NumberFormat(locale, options);\n  $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);\n  return numberFormatter;\n}\nfunction $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {\n  if (signDisplay === \"auto\") return numberFormat.format(num);else if (signDisplay === \"never\") return numberFormat.format(Math.abs(num));else {\n    let needsPositiveSign = false;\n    if (signDisplay === \"always\") needsPositiveSign = num > 0 || Object.is(num, 0);else if (signDisplay === \"exceptZero\") {\n      if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);else needsPositiveSign = num > 0;\n    }\n    if (needsPositiveSign) {\n      let negative = numberFormat.format(-num);\n      let noSign = numberFormat.format(num);\n      // ignore RTL/LTR marker character\n      let minus = negative.replace(noSign, \"\").replace(/\\u200e|\\u061C/, \"\");\n      if ([...minus].length !== 1) console.warn(\"@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case\");\n      let positive = negative.replace(noSign, \"!!!\").replace(minus, \"+\").replace(\"!!!\", noSign);\n      return positive;\n    } else return numberFormat.format(num);\n  }\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nconst $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp(\"^.*\\\\(.*\\\\).*$\");\nconst $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [\"latn\", \"arab\", \"hanidec\"];\nclass $6c7bd7858deea686$export$cd11ab140839f11d {\n  /**\n  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.\n  */\n  parse(value) {\n    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);\n  }\n  /**\n  * Returns whether the given string could potentially be a valid number. This should be used to\n  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity\n  * of the minus/plus sign characters can be checked.\n  */\n  isValidPartialNumber(value, minValue, maxValue) {\n    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue);\n  }\n  /**\n  * Returns a numbering system for which the given string is valid in the current locale.\n  * If no numbering system could be detected, the default numbering system for the current\n  * locale is returned.\n  */\n  getNumberingSystem(value) {\n    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;\n  }\n  constructor(locale, options = {}) {\n    this.locale = locale;\n    this.options = options;\n  }\n}\nconst $6c7bd7858deea686$var$numberParserCache = new Map();\nfunction $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {\n  // First try the default numbering system for the provided locale\n  let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);\n  // If that doesn't match, and the locale doesn't include a hard coded numbering system,\n  // try each of the other supported numbering systems until we find one that matches.\n  if (!locale.includes(\"-nu-\") && !defaultParser.isValidPartialNumber(value)) {\n    for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS) if (numberingSystem !== defaultParser.options.numberingSystem) {\n      let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes(\"-u-\") ? \"-nu-\" : \"-u-nu-\") + numberingSystem, options);\n      if (parser.isValidPartialNumber(value)) return parser;\n    }\n  }\n  return defaultParser;\n}\nfunction $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {\n  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : \"\");\n  let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);\n  if (!parser) {\n    parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);\n    $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);\n  }\n  return parser;\n}\n// The actual number parser implementation. Instances of this class are cached\n// based on the locale, options, and detected numbering system.\nclass $6c7bd7858deea686$var$NumberParserImpl {\n  parse(value) {\n    // to parse the number, we need to remove anything that isn't actually part of the number, for example we want '-10.40' not '-10.40 USD'\n    let fullySanitizedValue = this.sanitize(value);\n    // Remove group characters, and replace decimal points and numerals with ASCII values.\n    fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, \"\").replace(this.symbols.decimal, \".\").replace(this.symbols.minusSign, \"-\").replace(this.symbols.numeral, this.symbols.index);\n    let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;\n    if (isNaN(newValue)) return NaN;\n    // accounting will always be stripped to a positive number, so if it's accounting and has a () around everything, then we need to make it negative again\n    if (this.options.currencySign === \"accounting\" && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;\n    // when reading the number, if it's a percent, then it should be interpreted as being divided by 100\n    if (this.options.style === \"percent\") {\n      newValue /= 100;\n      var _this_options_maximumFractionDigits;\n      // after dividing to get the percent value, javascript may get .0210999999 instead of .0211, so fix the number of fraction digits\n      newValue = +newValue.toFixed(((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) + 2);\n    }\n    return newValue;\n  }\n  sanitize(value) {\n    // Remove literals and whitespace, which are allowed anywhere in the string\n    value = value.replace(this.symbols.literals, \"\");\n    // Replace the ASCII minus sign with the minus sign used in the current locale\n    // so that both are allowed in case the user's keyboard doesn't have the locale's minus sign.\n    value = value.replace(\"-\", this.symbols.minusSign);\n    // In arab numeral system, their decimal character is 1643, but most keyboards don't type that\n    // instead they use the , (44) character or apparently the (1548) character.\n    if (this.options.numberingSystem === \"arab\") {\n      value = value.replace(\",\", this.symbols.decimal);\n      value = value.replace(String.fromCharCode(1548), this.symbols.decimal);\n      value = $6c7bd7858deea686$var$replaceAll(value, \".\", this.symbols.group);\n    }\n    // fr-FR group character is char code 8239, but that's not a key on the french keyboard,\n    // so allow 'period' as a group char and replace it with a space\n    if (this.options.locale === \"fr-FR\") value = $6c7bd7858deea686$var$replaceAll(value, \".\", String.fromCharCode(8239));\n    return value;\n  }\n  isValidPartialNumber(value, minValue = -Infinity, maxValue = Infinity) {\n    value = this.sanitize(value);\n    // Remove minus or plus sign, which must be at the start of the string.\n    if (value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue > 0) value = value.slice(this.symbols.plusSign.length);\n    // Numbers cannot start with a group separator\n    if (value.startsWith(this.symbols.group)) return false;\n    // Remove numerals, groups, and decimals\n    value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, \"\").replace(this.symbols.numeral, \"\").replace(this.symbols.decimal, \"\");\n    // The number is valid if there are no remaining characters\n    return value.length === 0;\n  }\n  constructor(locale, options = {}) {\n    this.formatter = new Intl.NumberFormat(locale, options);\n    this.options = this.formatter.resolvedOptions();\n    this.symbols = $6c7bd7858deea686$var$getSymbols(this.formatter, this.options, options);\n  }\n}\nconst $6c7bd7858deea686$var$nonLiteralParts = new Set([\"decimal\", \"fraction\", \"integer\", \"minusSign\", \"plusSign\", \"group\"]);\n// This list is derived from https://www.unicode.org/cldr/charts/43/supplemental/language_plural_rules.html#comparison and includes\n// all unique numbers which we need to check in order to determine all the plural forms for a given locale.\n// See: https://github.com/adobe/react-spectrum/pull/5134/files#r1337037855 for used script\nconst $6c7bd7858deea686$var$pluralNumbers = [0, 4, 2, 1, 11, 20, 3, 7, 100, 21, 0.1, 1.1];\nfunction $6c7bd7858deea686$var$getSymbols(formatter, intlOptions, originalOptions) {\n  var _allParts_find, _posAllParts_find, _allParts_find1, _allParts_find2;\n  // Note: some locale's don't add a group symbol until there is a ten thousands place\n  let allParts = formatter.formatToParts(-10000.111);\n  let posAllParts = formatter.formatToParts(10000.111);\n  let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map(n => formatter.formatToParts(n));\n  var _allParts_find_value;\n  let minusSign = (_allParts_find_value = (_allParts_find = allParts.find(p => p.type === \"minusSign\")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : \"-\";\n  let plusSign = (_posAllParts_find = posAllParts.find(p => p.type === \"plusSign\")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;\n  // Safari does not support the signDisplay option, but our number parser polyfills it.\n  // If no plus sign was returned, but the original options contained signDisplay, default to the '+' character.\n  // @ts-ignore\n  if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === \"exceptZero\" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === \"always\")) plusSign = \"+\";\n  let decimal = (_allParts_find1 = allParts.find(p => p.type === \"decimal\")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;\n  let group = (_allParts_find2 = allParts.find(p => p.type === \"group\")) === null || _allParts_find2 === void 0 ? void 0 : _allParts_find2.value;\n  // this set is also for a regex, it's all literals that might be in the string we want to eventually parse that\n  // don't contribute to the numerical value\n  let allPartsLiterals = allParts.filter(p => !$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map(p => $6c7bd7858deea686$var$escapeRegex(p.value));\n  let pluralPartsLiterals = pluralParts.flatMap(p => p.filter(p => !$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map(p => $6c7bd7858deea686$var$escapeRegex(p.value)));\n  let sortedLiterals = [...new Set([...allPartsLiterals, ...pluralPartsLiterals])].sort((a, b) => b.length - a.length);\n  let literals = sortedLiterals.length === 0 ? new RegExp(\"[\\\\p{White_Space}]\", \"gu\") : new RegExp(`${sortedLiterals.join(\"|\")}|[\\\\p{White_Space}]`, \"gu\");\n  // These are for replacing non-latn characters with the latn equivalent\n  let numerals = [...new Intl.NumberFormat(intlOptions.locale, {\n    useGrouping: false\n  }).format(9876543210)].reverse();\n  let indexes = new Map(numerals.map((d, i) => [d, i]));\n  let numeral = new RegExp(`[${numerals.join(\"\")}]`, \"g\");\n  let index = d => String(indexes.get(d));\n  return {\n    minusSign: minusSign,\n    plusSign: plusSign,\n    decimal: decimal,\n    group: group,\n    literals: literals,\n    numeral: numeral,\n    index: index\n  };\n}\nfunction $6c7bd7858deea686$var$replaceAll(str, find, replace) {\n  // @ts-ignore\n  if (str.replaceAll)\n    // @ts-ignore\n    return str.replaceAll(find, replace);\n  return str.split(find).join(replace);\n}\nfunction $6c7bd7858deea686$var$escapeRegex(string) {\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\nexport { $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 as NumberFormatter, $6c7bd7858deea686$export$cd11ab140839f11d as NumberParser };\n//# sourceMappingURL=module.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}