{"ast":null,"code":"import A, { createContext as Q, createRef as de, useContext as Z, useEffect as ee, useMemo as _, useReducer as ge, useRef as J, useState as ce } from \"react\";\nimport { match as k } from '../../utils/match.js';\nimport { forwardRefWithAs as X, render as Y, Features as te } from '../../utils/render.js';\nimport { optionalRef as Se, useSyncRefs as j } from '../../hooks/use-sync-refs.js';\nimport { useId as V } from '../../hooks/use-id.js';\nimport { Keys as w } from '../keyboard.js';\nimport { isDisabledReactIssue7711 as ve } from '../../utils/bugs.js';\nimport { getFocusableElements as ne, Focus as G, focusIn as U, isFocusableElement as Ae, FocusableMode as Re, FocusResult as le } from '../../utils/focus-management.js';\nimport { OpenClosedProvider as Oe, State as $, useOpenClosed as Te } from '../../internal/open-closed.js';\nimport { useResolveButtonType as Ce } from '../../hooks/use-resolve-button-type.js';\nimport { useOutsideClick as Me } from '../../hooks/use-outside-click.js';\nimport { getOwnerDocument as Fe } from '../../utils/owner.js';\nimport { useOwnerDocument as ae } from '../../hooks/use-owner.js';\nimport { useEventListener as Ie } from '../../hooks/use-event-listener.js';\nimport { Hidden as pe, Features as se } from '../../internal/hidden.js';\nimport { useEvent as g } from '../../hooks/use-event.js';\nimport { useTabDirection as me, Direction as N } from '../../hooks/use-tab-direction.js';\nimport '../../utils/micro-task.js';\nimport { useLatestValue as ye } from '../../hooks/use-latest-value.js';\nimport { useIsoMorphicEffect as xe } from '../../hooks/use-iso-morphic-effect.js';\nimport { useMainTreeNode as Le, useRootContainers as Be } from '../../hooks/use-root-containers.js';\nimport { useNestedPortals as De } from '../../components/portal/portal.js';\nvar he = (u => (u[u.Open = 0] = \"Open\", u[u.Closed = 1] = \"Closed\", u))(he || {}),\n  He = (e => (e[e.TogglePopover = 0] = \"TogglePopover\", e[e.ClosePopover = 1] = \"ClosePopover\", e[e.SetButton = 2] = \"SetButton\", e[e.SetButtonId = 3] = \"SetButtonId\", e[e.SetPanel = 4] = \"SetPanel\", e[e.SetPanelId = 5] = \"SetPanelId\", e))(He || {});\nlet _e = {\n    [0]: t => {\n      let o = {\n        ...t,\n        popoverState: k(t.popoverState, {\n          [0]: 1,\n          [1]: 0\n        })\n      };\n      return o.popoverState === 0 && (o.__demoMode = !1), o;\n    },\n    [1](t) {\n      return t.popoverState === 1 ? t : {\n        ...t,\n        popoverState: 1\n      };\n    },\n    [2](t, o) {\n      return t.button === o.button ? t : {\n        ...t,\n        button: o.button\n      };\n    },\n    [3](t, o) {\n      return t.buttonId === o.buttonId ? t : {\n        ...t,\n        buttonId: o.buttonId\n      };\n    },\n    [4](t, o) {\n      return t.panel === o.panel ? t : {\n        ...t,\n        panel: o.panel\n      };\n    },\n    [5](t, o) {\n      return t.panelId === o.panelId ? t : {\n        ...t,\n        panelId: o.panelId\n      };\n    }\n  },\n  ue = Q(null);\nue.displayName = \"PopoverContext\";\nfunction oe(t) {\n  let o = Z(ue);\n  if (o === null) {\n    let u = new Error(`<${t} /> is missing a parent <Popover /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(u, oe), u;\n  }\n  return o;\n}\nlet ie = Q(null);\nie.displayName = \"PopoverAPIContext\";\nfunction fe(t) {\n  let o = Z(ie);\n  if (o === null) {\n    let u = new Error(`<${t} /> is missing a parent <Popover /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(u, fe), u;\n  }\n  return o;\n}\nlet Pe = Q(null);\nPe.displayName = \"PopoverGroupContext\";\nfunction Ee() {\n  return Z(Pe);\n}\nlet re = Q(null);\nre.displayName = \"PopoverPanelContext\";\nfunction Ge() {\n  return Z(re);\n}\nfunction Ne(t, o) {\n  return k(o.type, _e, t, o);\n}\nlet ke = \"div\";\nfunction we(t, o) {\n  var D;\n  let {\n      __demoMode: u = !1,\n      ...R\n    } = t,\n    O = J(null),\n    n = j(o, Se(l => {\n      O.current = l;\n    })),\n    e = J([]),\n    v = ge(Ne, {\n      __demoMode: u,\n      popoverState: u ? 0 : 1,\n      buttons: e,\n      button: null,\n      buttonId: null,\n      panel: null,\n      panelId: null,\n      beforePanelSentinel: de(),\n      afterPanelSentinel: de()\n    }),\n    [{\n      popoverState: P,\n      button: s,\n      buttonId: I,\n      panel: p,\n      panelId: T,\n      beforePanelSentinel: m,\n      afterPanelSentinel: S\n    }, i] = v,\n    a = ae((D = O.current) != null ? D : s),\n    E = _(() => {\n      if (!s || !p) return !1;\n      for (let K of document.querySelectorAll(\"body > *\")) if (Number(K == null ? void 0 : K.contains(s)) ^ Number(K == null ? void 0 : K.contains(p))) return !0;\n      let l = ne(),\n        F = l.indexOf(s),\n        q = (F + l.length - 1) % l.length,\n        W = (F + 1) % l.length,\n        z = l[q],\n        be = l[W];\n      return !p.contains(z) && !p.contains(be);\n    }, [s, p]),\n    C = ye(I),\n    H = ye(T),\n    x = _(() => ({\n      buttonId: C,\n      panelId: H,\n      close: () => i({\n        type: 1\n      })\n    }), [C, H, i]),\n    M = Ee(),\n    h = M == null ? void 0 : M.registerPopover,\n    f = g(() => {\n      var l;\n      return (l = M == null ? void 0 : M.isFocusWithinPopoverGroup()) != null ? l : (a == null ? void 0 : a.activeElement) && ((s == null ? void 0 : s.contains(a.activeElement)) || (p == null ? void 0 : p.contains(a.activeElement)));\n    });\n  ee(() => h == null ? void 0 : h(x), [h, x]);\n  let [y, b] = De(),\n    d = Be({\n      mainTreeNodeRef: M == null ? void 0 : M.mainTreeNodeRef,\n      portals: y,\n      defaultContainers: [s, p]\n    });\n  Ie(a == null ? void 0 : a.defaultView, \"focus\", l => {\n    var F, q, W, z;\n    l.target !== window && l.target instanceof HTMLElement && P === 0 && (f() || s && p && (d.contains(l.target) || (q = (F = m.current) == null ? void 0 : F.contains) != null && q.call(F, l.target) || (z = (W = S.current) == null ? void 0 : W.contains) != null && z.call(W, l.target) || i({\n      type: 1\n    })));\n  }, !0), Me(d.resolveContainers, (l, F) => {\n    i({\n      type: 1\n    }), Ae(F, Re.Loose) || (l.preventDefault(), s == null || s.focus());\n  }, P === 0);\n  let L = g(l => {\n      i({\n        type: 1\n      });\n      let F = (() => l ? l instanceof HTMLElement ? l : \"current\" in l && l.current instanceof HTMLElement ? l.current : s : s)();\n      F == null || F.focus();\n    }),\n    r = _(() => ({\n      close: L,\n      isPortalled: E\n    }), [L, E]),\n    c = _(() => ({\n      open: P === 0,\n      close: L\n    }), [P, L]),\n    B = {\n      ref: n\n    };\n  return A.createElement(re.Provider, {\n    value: null\n  }, A.createElement(ue.Provider, {\n    value: v\n  }, A.createElement(ie.Provider, {\n    value: r\n  }, A.createElement(Oe, {\n    value: k(P, {\n      [0]: $.Open,\n      [1]: $.Closed\n    })\n  }, A.createElement(b, null, Y({\n    ourProps: B,\n    theirProps: R,\n    slot: c,\n    defaultTag: ke,\n    name: \"Popover\"\n  }), A.createElement(d.MainTreeNode, null))))));\n}\nlet Ue = \"button\";\nfunction We(t, o) {\n  let u = V(),\n    {\n      id: R = `headlessui-popover-button-${u}`,\n      ...O\n    } = t,\n    [n, e] = oe(\"Popover.Button\"),\n    {\n      isPortalled: v\n    } = fe(\"Popover.Button\"),\n    P = J(null),\n    s = `headlessui-focus-sentinel-${V()}`,\n    I = Ee(),\n    p = I == null ? void 0 : I.closeOthers,\n    m = Ge() !== null;\n  ee(() => {\n    if (!m) return e({\n      type: 3,\n      buttonId: R\n    }), () => {\n      e({\n        type: 3,\n        buttonId: null\n      });\n    };\n  }, [m, R, e]);\n  let [S] = ce(() => Symbol()),\n    i = j(P, o, m ? null : r => {\n      if (r) n.buttons.current.push(S);else {\n        let c = n.buttons.current.indexOf(S);\n        c !== -1 && n.buttons.current.splice(c, 1);\n      }\n      n.buttons.current.length > 1 && console.warn(\"You are already using a <Popover.Button /> but only 1 <Popover.Button /> is supported.\"), r && e({\n        type: 2,\n        button: r\n      });\n    }),\n    a = j(P, o),\n    E = ae(P),\n    C = g(r => {\n      var c, B, D;\n      if (m) {\n        if (n.popoverState === 1) return;\n        switch (r.key) {\n          case w.Space:\n          case w.Enter:\n            r.preventDefault(), (B = (c = r.target).click) == null || B.call(c), e({\n              type: 1\n            }), (D = n.button) == null || D.focus();\n            break;\n        }\n      } else switch (r.key) {\n        case w.Space:\n        case w.Enter:\n          r.preventDefault(), r.stopPropagation(), n.popoverState === 1 && (p == null || p(n.buttonId)), e({\n            type: 0\n          });\n          break;\n        case w.Escape:\n          if (n.popoverState !== 0) return p == null ? void 0 : p(n.buttonId);\n          if (!P.current || E != null && E.activeElement && !P.current.contains(E.activeElement)) return;\n          r.preventDefault(), r.stopPropagation(), e({\n            type: 1\n          });\n          break;\n      }\n    }),\n    H = g(r => {\n      m || r.key === w.Space && r.preventDefault();\n    }),\n    x = g(r => {\n      var c, B;\n      ve(r.currentTarget) || t.disabled || (m ? (e({\n        type: 1\n      }), (c = n.button) == null || c.focus()) : (r.preventDefault(), r.stopPropagation(), n.popoverState === 1 && (p == null || p(n.buttonId)), e({\n        type: 0\n      }), (B = n.button) == null || B.focus()));\n    }),\n    M = g(r => {\n      r.preventDefault(), r.stopPropagation();\n    }),\n    h = n.popoverState === 0,\n    f = _(() => ({\n      open: h\n    }), [h]),\n    y = Ce(t, P),\n    b = m ? {\n      ref: a,\n      type: y,\n      onKeyDown: C,\n      onClick: x\n    } : {\n      ref: i,\n      id: n.buttonId,\n      type: y,\n      \"aria-expanded\": n.popoverState === 0,\n      \"aria-controls\": n.panel ? n.panelId : void 0,\n      onKeyDown: C,\n      onKeyUp: H,\n      onClick: x,\n      onMouseDown: M\n    },\n    d = me(),\n    L = g(() => {\n      let r = n.panel;\n      if (!r) return;\n      function c() {\n        k(d.current, {\n          [N.Forwards]: () => U(r, G.First),\n          [N.Backwards]: () => U(r, G.Last)\n        }) === le.Error && U(ne().filter(D => D.dataset.headlessuiFocusGuard !== \"true\"), k(d.current, {\n          [N.Forwards]: G.Next,\n          [N.Backwards]: G.Previous\n        }), {\n          relativeTo: n.button\n        });\n      }\n      c();\n    });\n  return A.createElement(A.Fragment, null, Y({\n    ourProps: b,\n    theirProps: O,\n    slot: f,\n    defaultTag: Ue,\n    name: \"Popover.Button\"\n  }), h && !m && v && A.createElement(pe, {\n    id: s,\n    features: se.Focusable,\n    \"data-headlessui-focus-guard\": !0,\n    as: \"button\",\n    type: \"button\",\n    onFocus: L\n  }));\n}\nlet Ke = \"div\",\n  je = te.RenderStrategy | te.Static;\nfunction Ve(t, o) {\n  let u = V(),\n    {\n      id: R = `headlessui-popover-overlay-${u}`,\n      ...O\n    } = t,\n    [{\n      popoverState: n\n    }, e] = oe(\"Popover.Overlay\"),\n    v = j(o),\n    P = Te(),\n    s = (() => P !== null ? (P & $.Open) === $.Open : n === 0)(),\n    I = g(m => {\n      if (ve(m.currentTarget)) return m.preventDefault();\n      e({\n        type: 1\n      });\n    }),\n    p = _(() => ({\n      open: n === 0\n    }), [n]);\n  return Y({\n    ourProps: {\n      ref: v,\n      id: R,\n      \"aria-hidden\": !0,\n      onClick: I\n    },\n    theirProps: O,\n    slot: p,\n    defaultTag: Ke,\n    features: je,\n    visible: s,\n    name: \"Popover.Overlay\"\n  });\n}\nlet $e = \"div\",\n  Je = te.RenderStrategy | te.Static;\nfunction Xe(t, o) {\n  let u = V(),\n    {\n      id: R = `headlessui-popover-panel-${u}`,\n      focus: O = !1,\n      ...n\n    } = t,\n    [e, v] = oe(\"Popover.Panel\"),\n    {\n      close: P,\n      isPortalled: s\n    } = fe(\"Popover.Panel\"),\n    I = `headlessui-focus-sentinel-before-${V()}`,\n    p = `headlessui-focus-sentinel-after-${V()}`,\n    T = J(null),\n    m = j(T, o, f => {\n      v({\n        type: 4,\n        panel: f\n      });\n    }),\n    S = ae(T);\n  xe(() => (v({\n    type: 5,\n    panelId: R\n  }), () => {\n    v({\n      type: 5,\n      panelId: null\n    });\n  }), [R, v]);\n  let i = Te(),\n    a = (() => i !== null ? (i & $.Open) === $.Open : e.popoverState === 0)(),\n    E = g(f => {\n      var y;\n      switch (f.key) {\n        case w.Escape:\n          if (e.popoverState !== 0 || !T.current || S != null && S.activeElement && !T.current.contains(S.activeElement)) return;\n          f.preventDefault(), f.stopPropagation(), v({\n            type: 1\n          }), (y = e.button) == null || y.focus();\n          break;\n      }\n    });\n  ee(() => {\n    var f;\n    t.static || e.popoverState === 1 && ((f = t.unmount) == null || f) && v({\n      type: 4,\n      panel: null\n    });\n  }, [e.popoverState, t.unmount, t.static, v]), ee(() => {\n    if (e.__demoMode || !O || e.popoverState !== 0 || !T.current) return;\n    let f = S == null ? void 0 : S.activeElement;\n    T.current.contains(f) || U(T.current, G.First);\n  }, [e.__demoMode, O, T, e.popoverState]);\n  let C = _(() => ({\n      open: e.popoverState === 0,\n      close: P\n    }), [e, P]),\n    H = {\n      ref: m,\n      id: R,\n      onKeyDown: E,\n      onBlur: O && e.popoverState === 0 ? f => {\n        var b, d, L, r, c;\n        let y = f.relatedTarget;\n        y && T.current && ((b = T.current) != null && b.contains(y) || (v({\n          type: 1\n        }), ((L = (d = e.beforePanelSentinel.current) == null ? void 0 : d.contains) != null && L.call(d, y) || (c = (r = e.afterPanelSentinel.current) == null ? void 0 : r.contains) != null && c.call(r, y)) && y.focus({\n          preventScroll: !0\n        })));\n      } : void 0,\n      tabIndex: -1\n    },\n    x = me(),\n    M = g(() => {\n      let f = T.current;\n      if (!f) return;\n      function y() {\n        k(x.current, {\n          [N.Forwards]: () => {\n            var d;\n            U(f, G.First) === le.Error && ((d = e.afterPanelSentinel.current) == null || d.focus());\n          },\n          [N.Backwards]: () => {\n            var b;\n            (b = e.button) == null || b.focus({\n              preventScroll: !0\n            });\n          }\n        });\n      }\n      y();\n    }),\n    h = g(() => {\n      let f = T.current;\n      if (!f) return;\n      function y() {\n        k(x.current, {\n          [N.Forwards]: () => {\n            var B;\n            if (!e.button) return;\n            let b = ne(),\n              d = b.indexOf(e.button),\n              L = b.slice(0, d + 1),\n              c = [...b.slice(d + 1), ...L];\n            for (let D of c.slice()) if (D.dataset.headlessuiFocusGuard === \"true\" || (B = e.panel) != null && B.contains(D)) {\n              let l = c.indexOf(D);\n              l !== -1 && c.splice(l, 1);\n            }\n            U(c, G.First, {\n              sorted: !1\n            });\n          },\n          [N.Backwards]: () => {\n            var d;\n            U(f, G.Previous) === le.Error && ((d = e.button) == null || d.focus());\n          }\n        });\n      }\n      y();\n    });\n  return A.createElement(re.Provider, {\n    value: R\n  }, a && s && A.createElement(pe, {\n    id: I,\n    ref: e.beforePanelSentinel,\n    features: se.Focusable,\n    \"data-headlessui-focus-guard\": !0,\n    as: \"button\",\n    type: \"button\",\n    onFocus: M\n  }), Y({\n    ourProps: H,\n    theirProps: n,\n    slot: C,\n    defaultTag: $e,\n    features: Je,\n    visible: a,\n    name: \"Popover.Panel\"\n  }), a && s && A.createElement(pe, {\n    id: p,\n    ref: e.afterPanelSentinel,\n    features: se.Focusable,\n    \"data-headlessui-focus-guard\": !0,\n    as: \"button\",\n    type: \"button\",\n    onFocus: h\n  }));\n}\nlet Ye = \"div\";\nfunction qe(t, o) {\n  let u = J(null),\n    R = j(u, o),\n    [O, n] = ce([]),\n    e = Le(),\n    v = g(i => {\n      n(a => {\n        let E = a.indexOf(i);\n        if (E !== -1) {\n          let C = a.slice();\n          return C.splice(E, 1), C;\n        }\n        return a;\n      });\n    }),\n    P = g(i => (n(a => [...a, i]), () => v(i))),\n    s = g(() => {\n      var E;\n      let i = Fe(u);\n      if (!i) return !1;\n      let a = i.activeElement;\n      return (E = u.current) != null && E.contains(a) ? !0 : O.some(C => {\n        var H, x;\n        return ((H = i.getElementById(C.buttonId.current)) == null ? void 0 : H.contains(a)) || ((x = i.getElementById(C.panelId.current)) == null ? void 0 : x.contains(a));\n      });\n    }),\n    I = g(i => {\n      for (let a of O) a.buttonId.current !== i && a.close();\n    }),\n    p = _(() => ({\n      registerPopover: P,\n      unregisterPopover: v,\n      isFocusWithinPopoverGroup: s,\n      closeOthers: I,\n      mainTreeNodeRef: e.mainTreeNodeRef\n    }), [P, v, s, I, e.mainTreeNodeRef]),\n    T = _(() => ({}), []),\n    m = t,\n    S = {\n      ref: R\n    };\n  return A.createElement(Pe.Provider, {\n    value: p\n  }, Y({\n    ourProps: S,\n    theirProps: m,\n    slot: T,\n    defaultTag: Ye,\n    name: \"Popover.Group\"\n  }), A.createElement(e.MainTreeNode, null));\n}\nlet ze = X(we),\n  Qe = X(We),\n  Ze = X(Ve),\n  et = X(Xe),\n  tt = X(qe),\n  kt = Object.assign(ze, {\n    Button: Qe,\n    Overlay: Ze,\n    Panel: et,\n    Group: tt\n  });\nexport { kt as Popover };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}