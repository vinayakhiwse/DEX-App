{"ast":null,"code":"import { flushSync as $eCAIO$flushSync } from \"react-dom\";\nimport { useRef as $eCAIO$useRef, useEffect as $eCAIO$useEffect, useMemo as $eCAIO$useMemo } from \"react\";\nimport { getFocusableTreeWalker as $eCAIO$getFocusableTreeWalker, focusSafely as $eCAIO$focusSafely } from \"@react-aria/focus\";\nimport { useRouter as $eCAIO$useRouter, focusWithoutScrolling as $eCAIO$focusWithoutScrolling, useEvent as $eCAIO$useEvent, scrollIntoViewport as $eCAIO$scrollIntoViewport, scrollIntoView as $eCAIO$scrollIntoView, mergeProps as $eCAIO$mergeProps, isAppleDevice as $eCAIO$isAppleDevice, isMac as $eCAIO$isMac, openLink as $eCAIO$openLink, isScrollable as $eCAIO$isScrollable } from \"@react-aria/utils\";\nimport { getInteractionModality as $eCAIO$getInteractionModality, usePress as $eCAIO$usePress, useLongPress as $eCAIO$useLongPress } from \"@react-aria/interactions\";\nimport { useLocale as $eCAIO$useLocale, useCollator as $eCAIO$useCollator } from \"@react-aria/i18n\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n    * Copyright 2020 Adobe. All rights reserved.\n    * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License. You may obtain a copy\n    * of the License at http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software distributed under\n    * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n    * OF ANY KIND, either express or implied. See the License for the specific language\n    * governing permissions and limitations under the License.\n    */\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nfunction $feb5ffebff200149$export$d3e3bd3e26688c04(e) {\n  // Ctrl + Arrow Up/Arrow Down has a system wide meaning on macOS, so use Alt instead.\n  // On Windows and Ubuntu, Alt + Space has a system wide meaning.\n  return (0, $eCAIO$isAppleDevice)() ? e.altKey : e.ctrlKey;\n}\nfunction $feb5ffebff200149$export$16792effe837dba3(e) {\n  if ((0, $eCAIO$isMac)()) return e.metaKey;\n  return e.ctrlKey;\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n/**\n * Controls how long to wait before clearing the typeahead buffer.\n */\nconst $fb3050f43d946246$var$TYPEAHEAD_DEBOUNCE_WAIT_MS = 1000; // 1 second\nfunction $fb3050f43d946246$export$e32c88dfddc6e1d8(options) {\n  let {\n    keyboardDelegate: keyboardDelegate,\n    selectionManager: selectionManager,\n    onTypeSelect: onTypeSelect\n  } = options;\n  let state = (0, $eCAIO$useRef)({\n    search: \"\",\n    timeout: null\n  }).current;\n  let onKeyDown = e => {\n    let character = $fb3050f43d946246$var$getStringForKey(e.key);\n    if (!character || e.ctrlKey || e.metaKey || !e.currentTarget.contains(e.target)) return;\n    // Do not propagate the Spacebar event if it's meant to be part of the search.\n    // When we time out, the search term becomes empty, hence the check on length.\n    // Trimming is to account for the case of pressing the Spacebar more than once,\n    // which should cycle through the selection/deselection of the focused item.\n    if (character === \" \" && state.search.trim().length > 0) {\n      e.preventDefault();\n      if (!(\"continuePropagation\" in e)) e.stopPropagation();\n    }\n    state.search += character;\n    // Use the delegate to find a key to focus.\n    // Prioritize items after the currently focused item, falling back to searching the whole list.\n    let key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey);\n    // If no key found, search from the top.\n    if (key == null) key = keyboardDelegate.getKeyForSearch(state.search);\n    if (key != null) {\n      selectionManager.setFocusedKey(key);\n      if (onTypeSelect) onTypeSelect(key);\n    }\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(() => {\n      state.search = \"\";\n    }, $fb3050f43d946246$var$TYPEAHEAD_DEBOUNCE_WAIT_MS);\n  };\n  return {\n    typeSelectProps: {\n      // Using a capturing listener to catch the keydown event before\n      // other hooks in order to handle the Spacebar event.\n      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null\n    }\n  };\n}\nfunction $fb3050f43d946246$var$getStringForKey(key) {\n  // If the key is of length 1, it is an ASCII value.\n  // Otherwise, if there are no ASCII characters in the key name,\n  // it is a Unicode character.\n  // See https://www.w3.org/TR/uievents-key/\n  if (key.length === 1 || !/^[A-Z]/i.test(key)) return key;\n  return \"\";\n}\nfunction $ae20dd8cbca75726$export$d6daf82dcd84e87c(options) {\n  let {\n    selectionManager: manager,\n    keyboardDelegate: delegate,\n    ref: ref,\n    autoFocus = false,\n    shouldFocusWrap = false,\n    disallowEmptySelection = false,\n    disallowSelectAll = false,\n    selectOnFocus = manager.selectionBehavior === \"replace\",\n    disallowTypeAhead = false,\n    shouldUseVirtualFocus: shouldUseVirtualFocus,\n    allowsTabNavigation = false,\n    isVirtualized: isVirtualized,\n    // If no scrollRef is provided, assume the collection ref is the scrollable region\n    scrollRef = ref,\n    linkBehavior = \"action\"\n  } = options;\n  let {\n    direction: direction\n  } = (0, $eCAIO$useLocale)();\n  let router = (0, $eCAIO$useRouter)();\n  let onKeyDown = e => {\n    // Prevent option + tab from doing anything since it doesn't move focus to the cells, only buttons/checkboxes\n    if (e.altKey && e.key === \"Tab\") e.preventDefault();\n    // Keyboard events bubble through portals. Don't handle keyboard events\n    // for elements outside the collection (e.g. menus).\n    if (!ref.current.contains(e.target)) return;\n    const navigateToKey = (key, childFocus) => {\n      if (key != null) {\n        if (manager.isLink(key) && linkBehavior === \"selection\" && selectOnFocus && !(0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e)) {\n          // Set focused key and re-render synchronously to bring item into view if needed.\n          (0, $eCAIO$flushSync)(() => {\n            manager.setFocusedKey(key, childFocus);\n          });\n          let item = scrollRef.current.querySelector(`[data-key=\"${key}\"]`);\n          router.open(item, e);\n          return;\n        }\n        manager.setFocusedKey(key, childFocus);\n        if (manager.isLink(key) && linkBehavior === \"override\") return;\n        if (e.shiftKey && manager.selectionMode === \"multiple\") manager.extendSelection(key);else if (selectOnFocus && !(0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e)) manager.replaceSelection(key);\n      }\n    };\n    switch (e.key) {\n      case \"ArrowDown\":\n        if (delegate.getKeyBelow) {\n          var _delegate_getFirstKey, _delegate_getFirstKey1;\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null ? delegate.getKeyBelow(manager.focusedKey) : (_delegate_getFirstKey = delegate.getFirstKey) === null || _delegate_getFirstKey === void 0 ? void 0 : _delegate_getFirstKey.call(delegate);\n          if (nextKey == null && shouldFocusWrap) nextKey = (_delegate_getFirstKey1 = delegate.getFirstKey) === null || _delegate_getFirstKey1 === void 0 ? void 0 : _delegate_getFirstKey1.call(delegate, manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case \"ArrowUp\":\n        if (delegate.getKeyAbove) {\n          var _delegate_getLastKey, _delegate_getLastKey1;\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null ? delegate.getKeyAbove(manager.focusedKey) : (_delegate_getLastKey = delegate.getLastKey) === null || _delegate_getLastKey === void 0 ? void 0 : _delegate_getLastKey.call(delegate);\n          if (nextKey == null && shouldFocusWrap) nextKey = (_delegate_getLastKey1 = delegate.getLastKey) === null || _delegate_getLastKey1 === void 0 ? void 0 : _delegate_getLastKey1.call(delegate, manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case \"ArrowLeft\":\n        if (delegate.getKeyLeftOf) {\n          var _delegate_getFirstKey2, _delegate_getLastKey2;\n          e.preventDefault();\n          let nextKey = delegate.getKeyLeftOf(manager.focusedKey);\n          if (nextKey == null && shouldFocusWrap) nextKey = direction === \"rtl\" ? (_delegate_getFirstKey2 = delegate.getFirstKey) === null || _delegate_getFirstKey2 === void 0 ? void 0 : _delegate_getFirstKey2.call(delegate, manager.focusedKey) : (_delegate_getLastKey2 = delegate.getLastKey) === null || _delegate_getLastKey2 === void 0 ? void 0 : _delegate_getLastKey2.call(delegate, manager.focusedKey);\n          navigateToKey(nextKey, direction === \"rtl\" ? \"first\" : \"last\");\n        }\n        break;\n      case \"ArrowRight\":\n        if (delegate.getKeyRightOf) {\n          var _delegate_getLastKey3, _delegate_getFirstKey3;\n          e.preventDefault();\n          let nextKey = delegate.getKeyRightOf(manager.focusedKey);\n          if (nextKey == null && shouldFocusWrap) nextKey = direction === \"rtl\" ? (_delegate_getLastKey3 = delegate.getLastKey) === null || _delegate_getLastKey3 === void 0 ? void 0 : _delegate_getLastKey3.call(delegate, manager.focusedKey) : (_delegate_getFirstKey3 = delegate.getFirstKey) === null || _delegate_getFirstKey3 === void 0 ? void 0 : _delegate_getFirstKey3.call(delegate, manager.focusedKey);\n          navigateToKey(nextKey, direction === \"rtl\" ? \"last\" : \"first\");\n        }\n        break;\n      case \"Home\":\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          let firstKey = delegate.getFirstKey(manager.focusedKey, (0, $feb5ffebff200149$export$16792effe837dba3)(e));\n          manager.setFocusedKey(firstKey);\n          if ((0, $feb5ffebff200149$export$16792effe837dba3)(e) && e.shiftKey && manager.selectionMode === \"multiple\") manager.extendSelection(firstKey);else if (selectOnFocus) manager.replaceSelection(firstKey);\n        }\n        break;\n      case \"End\":\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          let lastKey = delegate.getLastKey(manager.focusedKey, (0, $feb5ffebff200149$export$16792effe837dba3)(e));\n          manager.setFocusedKey(lastKey);\n          if ((0, $feb5ffebff200149$export$16792effe837dba3)(e) && e.shiftKey && manager.selectionMode === \"multiple\") manager.extendSelection(lastKey);else if (selectOnFocus) manager.replaceSelection(lastKey);\n        }\n        break;\n      case \"PageDown\":\n        if (delegate.getKeyPageBelow) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case \"PageUp\":\n        if (delegate.getKeyPageAbove) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case \"a\":\n        if ((0, $feb5ffebff200149$export$16792effe837dba3)(e) && manager.selectionMode === \"multiple\" && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n        break;\n      case \"Escape\":\n        e.preventDefault();\n        if (!disallowEmptySelection) manager.clearSelection();\n        break;\n      case \"Tab\":\n        if (!allowsTabNavigation) {\n          // There may be elements that are \"tabbable\" inside a collection (e.g. in a grid cell).\n          // However, collections should be treated as a single tab stop, with arrow key navigation internally.\n          // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.\n          // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element\n          // in the collection, so that the browser default behavior will apply starting from that element\n          // rather than the currently focused one.\n          if (e.shiftKey) ref.current.focus();else {\n            let walker = (0, $eCAIO$getFocusableTreeWalker)(ref.current, {\n              tabbable: true\n            });\n            let next;\n            let last;\n            do {\n              last = walker.lastChild();\n              if (last) next = last;\n            } while (last);\n            if (next && !next.contains(document.activeElement)) (0, $eCAIO$focusWithoutScrolling)(next);\n          }\n          break;\n        }\n    }\n  };\n  // Store the scroll position so we can restore it later.\n  let scrollPos = (0, $eCAIO$useRef)({\n    top: 0,\n    left: 0\n  });\n  (0, $eCAIO$useEvent)(scrollRef, \"scroll\", isVirtualized ? null : () => {\n    scrollPos.current = {\n      top: scrollRef.current.scrollTop,\n      left: scrollRef.current.scrollLeft\n    };\n  });\n  let onFocus = e => {\n    if (manager.isFocused) {\n      // If a focus event bubbled through a portal, reset focus state.\n      if (!e.currentTarget.contains(e.target)) manager.setFocused(false);\n      return;\n    }\n    // Focus events can bubble through portals. Ignore these events.\n    if (!e.currentTarget.contains(e.target)) return;\n    manager.setFocused(true);\n    if (manager.focusedKey == null) {\n      let navigateToFirstKey = key => {\n        if (key != null) {\n          manager.setFocusedKey(key);\n          if (selectOnFocus) manager.replaceSelection(key);\n        }\n      };\n      // If the user hasn't yet interacted with the collection, there will be no focusedKey set.\n      // Attempt to detect whether the user is tabbing forward or backward into the collection\n      // and either focus the first or last item accordingly.\n      let relatedTarget = e.relatedTarget;\n      var _manager_lastSelectedKey, _manager_firstSelectedKey;\n      if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) navigateToFirstKey((_manager_lastSelectedKey = manager.lastSelectedKey) !== null && _manager_lastSelectedKey !== void 0 ? _manager_lastSelectedKey : delegate.getLastKey());else navigateToFirstKey((_manager_firstSelectedKey = manager.firstSelectedKey) !== null && _manager_firstSelectedKey !== void 0 ? _manager_firstSelectedKey : delegate.getFirstKey());\n    } else if (!isVirtualized) {\n      // Restore the scroll position to what it was before.\n      scrollRef.current.scrollTop = scrollPos.current.top;\n      scrollRef.current.scrollLeft = scrollPos.current.left;\n    }\n    if (!isVirtualized && manager.focusedKey != null) {\n      // Refocus and scroll the focused item into view if it exists within the scrollable region.\n      let element = scrollRef.current.querySelector(`[data-key=\"${manager.focusedKey}\"]`);\n      if (element) {\n        // This prevents a flash of focus on the first/last element in the collection, or the collection itself.\n        if (!element.contains(document.activeElement)) (0, $eCAIO$focusWithoutScrolling)(element);\n        let modality = (0, $eCAIO$getInteractionModality)();\n        if (modality === \"keyboard\") (0, $eCAIO$scrollIntoViewport)(element, {\n          containingElement: ref.current\n        });\n      }\n    }\n  };\n  let onBlur = e => {\n    // Don't set blurred and then focused again if moving focus within the collection.\n    if (!e.currentTarget.contains(e.relatedTarget)) manager.setFocused(false);\n  };\n  const autoFocusRef = (0, $eCAIO$useRef)(autoFocus);\n  (0, $eCAIO$useEffect)(() => {\n    if (autoFocusRef.current) {\n      let focusedKey = null;\n      // Check focus strategy to determine which item to focus\n      if (autoFocus === \"first\") focusedKey = delegate.getFirstKey();\n      if (autoFocus === \"last\") focusedKey = delegate.getLastKey();\n      // If there are any selected keys, make the first one the new focus target\n      let selectedKeys = manager.selectedKeys;\n      if (selectedKeys.size) focusedKey = selectedKeys.values().next().value;\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey);\n      // If no default focus key is selected, focus the collection itself.\n      if (focusedKey == null && !shouldUseVirtualFocus) (0, $eCAIO$focusSafely)(ref.current);\n    }\n    autoFocusRef.current = false;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  // If not virtualized, scroll the focused element into view when the focusedKey changes.\n  // When virtualized, Virtualizer handles this internally.\n  let lastFocusedKey = (0, $eCAIO$useRef)(manager.focusedKey);\n  (0, $eCAIO$useEffect)(() => {\n    let modality = (0, $eCAIO$getInteractionModality)();\n    if (manager.isFocused && manager.focusedKey != null && (scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current)) {\n      let element = scrollRef.current.querySelector(`[data-key=\"${manager.focusedKey}\"]`);\n      if (element && modality === \"keyboard\") {\n        if (!isVirtualized) (0, $eCAIO$scrollIntoView)(scrollRef.current, element);\n        (0, $eCAIO$scrollIntoViewport)(element, {\n          containingElement: ref.current\n        });\n      }\n    }\n    // If the focused key becomes null (e.g. the last item is deleted), focus the whole collection.\n    if (manager.isFocused && manager.focusedKey == null && lastFocusedKey.current != null) (0, $eCAIO$focusSafely)(ref.current);\n    lastFocusedKey.current = manager.focusedKey;\n  }, [isVirtualized, scrollRef, manager.focusedKey, manager.isFocused, ref]);\n  let handlers = {\n    onKeyDown: onKeyDown,\n    onFocus: onFocus,\n    onBlur: onBlur,\n    onMouseDown(e) {\n      // Ignore events that bubbled through portals.\n      if (scrollRef.current === e.target)\n        // Prevent focus going to the collection when clicking on the scrollbar.\n        e.preventDefault();\n    }\n  };\n  let {\n    typeSelectProps: typeSelectProps\n  } = (0, $fb3050f43d946246$export$e32c88dfddc6e1d8)({\n    keyboardDelegate: delegate,\n    selectionManager: manager\n  });\n  if (!disallowTypeAhead) handlers = (0, $eCAIO$mergeProps)(typeSelectProps, handlers);\n  // If nothing is focused within the collection, make the collection itself tabbable.\n  // This will be marshalled to either the first or last item depending on where focus came from.\n  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try\n  // to move real DOM focus to the element anyway.\n  let tabIndex;\n  if (!shouldUseVirtualFocus) tabIndex = manager.focusedKey == null ? 0 : -1;\n  return {\n    collectionProps: {\n      ...handlers,\n      tabIndex: tabIndex\n    }\n  };\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $880e95eb8b93ba9a$export$ecf600387e221c37(options) {\n  let {\n    selectionManager: manager,\n    key: key,\n    ref: ref,\n    shouldSelectOnPressUp: shouldSelectOnPressUp,\n    shouldUseVirtualFocus: shouldUseVirtualFocus,\n    focus: focus,\n    isDisabled: isDisabled,\n    onAction: onAction,\n    allowsDifferentPressOrigin: allowsDifferentPressOrigin,\n    linkBehavior = \"action\"\n  } = options;\n  let router = (0, $eCAIO$useRouter)();\n  let onSelect = e => {\n    if (e.pointerType === \"keyboard\" && (0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e)) manager.toggleSelection(key);else {\n      if (manager.selectionMode === \"none\") return;\n      if (manager.isLink(key)) {\n        if (linkBehavior === \"selection\") {\n          router.open(ref.current, e);\n          // Always set selected keys back to what they were so that select and combobox close.\n          manager.setSelectedKeys(manager.selectedKeys);\n          return;\n        } else if (linkBehavior === \"override\" || linkBehavior === \"none\") return;\n      }\n      if (manager.selectionMode === \"single\") {\n        if (manager.isSelected(key) && !manager.disallowEmptySelection) manager.toggleSelection(key);else manager.replaceSelection(key);\n      } else if (e && e.shiftKey) manager.extendSelection(key);else if (manager.selectionBehavior === \"toggle\" || e && ((0, $feb5ffebff200149$export$16792effe837dba3)(e) || e.pointerType === \"touch\" || e.pointerType === \"virtual\"))\n        // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n        manager.toggleSelection(key);else manager.replaceSelection(key);\n    }\n  };\n  // Focus the associated DOM node when this item becomes the focusedKey\n  (0, $eCAIO$useEffect)(() => {\n    let isFocused = key === manager.focusedKey;\n    if (isFocused && manager.isFocused && !shouldUseVirtualFocus) {\n      if (focus) focus();else if (document.activeElement !== ref.current) (0, $eCAIO$focusSafely)(ref.current);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [ref, key, manager.focusedKey, manager.childFocusStrategy, manager.isFocused, shouldUseVirtualFocus]);\n  isDisabled = isDisabled || manager.isDisabled(key);\n  // Set tabIndex to 0 if the element is focused, or -1 otherwise so that only the last focused\n  // item is tabbable.  If using virtual focus, don't set a tabIndex at all so that VoiceOver\n  // on iOS 14 doesn't try to move real DOM focus to the item anyway.\n  let itemProps = {};\n  if (!shouldUseVirtualFocus && !isDisabled) itemProps = {\n    tabIndex: key === manager.focusedKey ? 0 : -1,\n    onFocus(e) {\n      if (e.target === ref.current) manager.setFocusedKey(key);\n    }\n  };else if (isDisabled) itemProps.onMouseDown = e => {\n    // Prevent focus going to the body when clicking on a disabled item.\n    e.preventDefault();\n  };\n  // With checkbox selection, onAction (i.e. navigation) becomes primary, and occurs on a single click of the row.\n  // Clicking the checkbox enters selection mode, after which clicking anywhere on any row toggles selection for that row.\n  // With highlight selection, onAction is secondary, and occurs on double click. Single click selects the row.\n  // With touch, onAction occurs on single tap, and long press enters selection mode.\n  let isLinkOverride = manager.isLink(key) && linkBehavior === \"override\";\n  let hasLinkAction = manager.isLink(key) && linkBehavior !== \"selection\" && linkBehavior !== \"none\";\n  let allowsSelection = !isDisabled && manager.canSelectItem(key) && !isLinkOverride;\n  let allowsActions = (onAction || hasLinkAction) && !isDisabled;\n  let hasPrimaryAction = allowsActions && (manager.selectionBehavior === \"replace\" ? !allowsSelection : !allowsSelection || manager.isEmpty);\n  let hasSecondaryAction = allowsActions && allowsSelection && manager.selectionBehavior === \"replace\";\n  let hasAction = hasPrimaryAction || hasSecondaryAction;\n  let modality = (0, $eCAIO$useRef)(null);\n  let longPressEnabled = hasAction && allowsSelection;\n  let longPressEnabledOnPressStart = (0, $eCAIO$useRef)(false);\n  let hadPrimaryActionOnPressStart = (0, $eCAIO$useRef)(false);\n  let performAction = e => {\n    if (onAction) onAction();\n    if (hasLinkAction) router.open(ref.current, e);\n  };\n  // By default, selection occurs on pointer down. This can be strange if selecting an\n  // item causes the UI to disappear immediately (e.g. menus).\n  // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.\n  // onPress requires a pointer down event on the same element as pointer up. For menus,\n  // we want to be able to have the pointer down on the trigger that opens the menu and\n  // the pointer up on the menu item rather than requiring a separate press.\n  // For keyboard events, selection still occurs on key down.\n  let itemPressProps = {};\n  if (shouldSelectOnPressUp) {\n    itemPressProps.onPressStart = e => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      if (e.pointerType === \"keyboard\" && (!hasAction || $880e95eb8b93ba9a$var$isSelectionKey())) onSelect(e);\n    };\n    // If allowsDifferentPressOrigin, make selection happen on pressUp (e.g. open menu on press down, selection on menu item happens on press up.)\n    // Otherwise, have selection happen onPress (prevents listview row selection when clicking on interactable elements in the row)\n    if (!allowsDifferentPressOrigin) itemPressProps.onPress = e => {\n      if (hasPrimaryAction || hasSecondaryAction && e.pointerType !== \"mouse\") {\n        if (e.pointerType === \"keyboard\" && !$880e95eb8b93ba9a$var$isActionKey()) return;\n        performAction(e);\n      } else if (e.pointerType !== \"keyboard\" && allowsSelection) onSelect(e);\n    };else {\n      itemPressProps.onPressUp = hasPrimaryAction ? null : e => {\n        if (e.pointerType !== \"keyboard\" && allowsSelection) onSelect(e);\n      };\n      itemPressProps.onPress = hasPrimaryAction ? performAction : null;\n    }\n  } else {\n    itemPressProps.onPressStart = e => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      hadPrimaryActionOnPressStart.current = hasPrimaryAction;\n      // Select on mouse down unless there is a primary action which will occur on mouse up.\n      // For keyboard, select on key down. If there is an action, the Space key selects on key down,\n      // and the Enter key performs onAction on key up.\n      if (allowsSelection && (e.pointerType === \"mouse\" && !hasPrimaryAction || e.pointerType === \"keyboard\" && (!allowsActions || $880e95eb8b93ba9a$var$isSelectionKey()))) onSelect(e);\n    };\n    itemPressProps.onPress = e => {\n      // Selection occurs on touch up. Primary actions always occur on pointer up.\n      // Both primary and secondary actions occur on Enter key up. The only exception\n      // is secondary actions, which occur on double click with a mouse.\n      if (e.pointerType === \"touch\" || e.pointerType === \"pen\" || e.pointerType === \"virtual\" || e.pointerType === \"keyboard\" && hasAction && $880e95eb8b93ba9a$var$isActionKey() || e.pointerType === \"mouse\" && hadPrimaryActionOnPressStart.current) {\n        if (hasAction) performAction(e);else if (allowsSelection) onSelect(e);\n      }\n    };\n  }\n  itemProps[\"data-key\"] = key;\n  itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;\n  let {\n    pressProps: pressProps,\n    isPressed: isPressed\n  } = (0, $eCAIO$usePress)(itemPressProps);\n  // Double clicking with a mouse with selectionBehavior = 'replace' performs an action.\n  let onDoubleClick = hasSecondaryAction ? e => {\n    if (modality.current === \"mouse\") {\n      e.stopPropagation();\n      e.preventDefault();\n      performAction(e);\n    }\n  } : undefined;\n  // Long pressing an item with touch when selectionBehavior = 'replace' switches the selection behavior\n  // to 'toggle'. This changes the single tap behavior from performing an action (i.e. navigating) to\n  // selecting, and may toggle the appearance of a UI affordance like checkboxes on each item.\n  let {\n    longPressProps: longPressProps\n  } = (0, $eCAIO$useLongPress)({\n    isDisabled: !longPressEnabled,\n    onLongPress(e) {\n      if (e.pointerType === \"touch\") {\n        onSelect(e);\n        manager.setSelectionBehavior(\"toggle\");\n      }\n    }\n  });\n  // Prevent native drag and drop on long press if we also select on long press.\n  // Once the user is in selection mode, they can long press again to drag.\n  // Use a capturing listener to ensure this runs before useDrag, regardless of\n  // the order the props get merged.\n  let onDragStartCapture = e => {\n    if (modality.current === \"touch\" && longPressEnabledOnPressStart.current) e.preventDefault();\n  };\n  // Prevent default on link clicks so that we control exactly\n  // when they open (to match selection behavior).\n  let onClick = manager.isLink(key) ? e => {\n    if (!(0, $eCAIO$openLink).isOpening) e.preventDefault();\n  } : undefined;\n  return {\n    itemProps: (0, $eCAIO$mergeProps)(itemProps, allowsSelection || hasPrimaryAction ? pressProps : {}, longPressEnabled ? longPressProps : {}, {\n      onDoubleClick: onDoubleClick,\n      onDragStartCapture: onDragStartCapture,\n      onClick: onClick\n    }),\n    isPressed: isPressed,\n    isSelected: manager.isSelected(key),\n    isFocused: manager.isFocused && manager.focusedKey === key,\n    isDisabled: isDisabled,\n    allowsSelection: allowsSelection,\n    hasAction: hasAction\n  };\n}\nfunction $880e95eb8b93ba9a$var$isActionKey() {\n  let event = window.event;\n  return (event === null || event === void 0 ? void 0 : event.key) === \"Enter\";\n}\nfunction $880e95eb8b93ba9a$var$isSelectionKey() {\n  let event = window.event;\n  return (event === null || event === void 0 ? void 0 : event.key) === \" \" || (event === null || event === void 0 ? void 0 : event.code) === \"Space\";\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nclass $2a25aae57d74318e$export$a05409b8bb224a5a {\n  getNextKey(key) {\n    key = this.collection.getKeyAfter(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === \"item\" && !this.disabledKeys.has(key)) return key;\n      key = this.collection.getKeyAfter(key);\n    }\n    return null;\n  }\n  getPreviousKey(key) {\n    key = this.collection.getKeyBefore(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === \"item\" && !this.disabledKeys.has(key)) return key;\n      key = this.collection.getKeyBefore(key);\n    }\n    return null;\n  }\n  findKey(key, nextKey, shouldSkip) {\n    let item = this.getItem(key);\n    if (!item) return null;\n    // Find the item above or below in the same column.\n    let prevRect = item.getBoundingClientRect();\n    do {\n      key = nextKey(key);\n      item = this.getItem(key);\n    } while (item && shouldSkip(prevRect, item.getBoundingClientRect()));\n    return key;\n  }\n  isSameRow(prevRect, itemRect) {\n    return prevRect.top === itemRect.top || prevRect.left !== itemRect.left;\n  }\n  isSameColumn(prevRect, itemRect) {\n    return prevRect.left === itemRect.left || prevRect.top !== itemRect.top;\n  }\n  getKeyBelow(key) {\n    if (this.layout === \"grid\" && this.orientation === \"vertical\") return this.findKey(key, key => this.getNextKey(key), this.isSameRow);else return this.getNextKey(key);\n  }\n  getKeyAbove(key) {\n    if (this.layout === \"grid\" && this.orientation === \"vertical\") return this.findKey(key, key => this.getPreviousKey(key), this.isSameRow);else return this.getPreviousKey(key);\n  }\n  getNextColumn(key, right) {\n    return right ? this.getPreviousKey(key) : this.getNextKey(key);\n  }\n  getKeyRightOf(key) {\n    if (this.layout === \"grid\") {\n      if (this.orientation === \"vertical\") return this.getNextColumn(key, this.direction === \"rtl\");else return this.findKey(key, key => this.getNextColumn(key, this.direction === \"rtl\"), this.isSameColumn);\n    } else if (this.orientation === \"horizontal\") return this.getNextColumn(key, this.direction === \"rtl\");\n    return null;\n  }\n  getKeyLeftOf(key) {\n    if (this.layout === \"grid\") {\n      if (this.orientation === \"vertical\") return this.getNextColumn(key, this.direction === \"ltr\");else return this.findKey(key, key => this.getNextColumn(key, this.direction === \"ltr\"), this.isSameColumn);\n    } else if (this.orientation === \"horizontal\") return this.getNextColumn(key, this.direction === \"ltr\");\n    return null;\n  }\n  getFirstKey() {\n    let key = this.collection.getFirstKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === \"item\" && !this.disabledKeys.has(key)) return key;\n      key = this.collection.getKeyAfter(key);\n    }\n    return null;\n  }\n  getLastKey() {\n    let key = this.collection.getLastKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === \"item\" && !this.disabledKeys.has(key)) return key;\n      key = this.collection.getKeyBefore(key);\n    }\n    return null;\n  }\n  getItem(key) {\n    return this.ref.current.querySelector(`[data-key=\"${key}\"]`);\n  }\n  getKeyPageAbove(key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) return null;\n    if (!(0, $eCAIO$isScrollable)(menu)) return this.getFirstKey();\n    let containerRect = menu.getBoundingClientRect();\n    let itemRect = item.getBoundingClientRect();\n    if (this.orientation === \"horizontal\") {\n      let containerX = containerRect.x - menu.scrollLeft;\n      let pageX = Math.max(0, itemRect.x - containerX + itemRect.width - containerRect.width);\n      while (item && itemRect.x - containerX > pageX) {\n        key = this.getKeyAbove(key);\n        item = key == null ? null : this.getItem(key);\n        itemRect = item === null || item === void 0 ? void 0 : item.getBoundingClientRect();\n      }\n    } else {\n      let containerY = containerRect.y - menu.scrollTop;\n      let pageY = Math.max(0, itemRect.y - containerY + itemRect.height - containerRect.height);\n      while (item && itemRect.y - containerY > pageY) {\n        key = this.getKeyAbove(key);\n        item = key == null ? null : this.getItem(key);\n        itemRect = item === null || item === void 0 ? void 0 : item.getBoundingClientRect();\n      }\n    }\n    return key !== null && key !== void 0 ? key : this.getFirstKey();\n  }\n  getKeyPageBelow(key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) return null;\n    if (!(0, $eCAIO$isScrollable)(menu)) return this.getLastKey();\n    let containerRect = menu.getBoundingClientRect();\n    let itemRect = item.getBoundingClientRect();\n    if (this.orientation === \"horizontal\") {\n      let containerX = containerRect.x - menu.scrollLeft;\n      let pageX = Math.min(menu.scrollWidth, itemRect.x - containerX - itemRect.width + containerRect.width);\n      while (item && itemRect.x - containerX < pageX) {\n        key = this.getKeyBelow(key);\n        item = key == null ? null : this.getItem(key);\n        itemRect = item === null || item === void 0 ? void 0 : item.getBoundingClientRect();\n      }\n    } else {\n      let containerY = containerRect.y - menu.scrollTop;\n      let pageY = Math.min(menu.scrollHeight, itemRect.y - containerY - itemRect.height + containerRect.height);\n      while (item && itemRect.y - containerY < pageY) {\n        key = this.getKeyBelow(key);\n        item = key == null ? null : this.getItem(key);\n        itemRect = item === null || item === void 0 ? void 0 : item.getBoundingClientRect();\n      }\n    }\n    return key !== null && key !== void 0 ? key : this.getLastKey();\n  }\n  getKeyForSearch(search, fromKey) {\n    if (!this.collator) return null;\n    let collection = this.collection;\n    let key = fromKey || this.getFirstKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      let substring = item.textValue.slice(0, search.length);\n      if (item.textValue && this.collator.compare(substring, search) === 0) return key;\n      key = this.getKeyBelow(key);\n    }\n    return null;\n  }\n  constructor(...args) {\n    if (args.length === 1) {\n      let opts = args[0];\n      this.collection = opts.collection;\n      this.ref = opts.ref;\n      this.collator = opts.collator;\n      this.disabledKeys = opts.disabledKeys || new Set();\n      this.orientation = opts.orientation;\n      this.direction = opts.direction;\n      this.layout = opts.layout || \"stack\";\n    } else {\n      this.collection = args[0];\n      this.disabledKeys = args[1];\n      this.ref = args[2];\n      this.collator = args[3];\n      this.layout = \"stack\";\n      this.orientation = \"vertical\";\n    }\n    // If this is a vertical stack, remove the left/right methods completely\n    // so they aren't called by useDroppableCollection.\n    if (this.layout === \"stack\" && this.orientation === \"vertical\") {\n      this.getKeyLeftOf = undefined;\n      this.getKeyRightOf = undefined;\n    }\n  }\n}\nfunction $982254629710d113$export$b95089534ab7c1fd(props) {\n  let {\n    selectionManager: selectionManager,\n    collection: collection,\n    disabledKeys: disabledKeys,\n    ref: ref,\n    keyboardDelegate: keyboardDelegate\n  } = props;\n  // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n  let collator = (0, $eCAIO$useCollator)({\n    usage: \"search\",\n    sensitivity: \"base\"\n  });\n  let disabledBehavior = selectionManager.disabledBehavior;\n  let delegate = (0, $eCAIO$useMemo)(() => keyboardDelegate || new (0, $2a25aae57d74318e$export$a05409b8bb224a5a)(collection, disabledBehavior === \"selection\" ? new Set() : disabledKeys, ref, collator), [keyboardDelegate, collection, disabledKeys, ref, collator, disabledBehavior]);\n  let {\n    collectionProps: collectionProps\n  } = (0, $ae20dd8cbca75726$export$d6daf82dcd84e87c)({\n    ...props,\n    ref: ref,\n    selectionManager: selectionManager,\n    keyboardDelegate: delegate\n  });\n  return {\n    listProps: collectionProps\n  };\n}\nexport { $ae20dd8cbca75726$export$d6daf82dcd84e87c as useSelectableCollection, $880e95eb8b93ba9a$export$ecf600387e221c37 as useSelectableItem, $982254629710d113$export$b95089534ab7c1fd as useSelectableList, $2a25aae57d74318e$export$a05409b8bb224a5a as ListKeyboardDelegate, $fb3050f43d946246$export$e32c88dfddc6e1d8 as useTypeSelect };\n//# sourceMappingURL=module.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}